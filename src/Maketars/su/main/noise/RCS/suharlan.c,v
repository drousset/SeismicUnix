head	1.10;
access;
symbols;
locks
	john:1.10; strict;
comment	@ * @;


1.10
date	2011.11.12.00.22.43;	author john;	state Exp;
branches;
next	1.9;

1.9
date	2011.09.09.22.31.59;	author john;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.05.18.08.35;	author john;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.05.20.48.11;	author john;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.5;

1.5
date	97.07.28.22.36.46;	author john;	state Exp;
branches;
next	1.4;

1.4
date	96.09.17.19.17.23;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	96.09.13.21.49.05;	author john;	state Exp;
branches;
next	1.2;

1.2
date	96.08.09.18.51.15;	author john;	state Exp;
branches;
next	1.1;

1.1
date	96.08.09.16.26.07;	author john;	state Exp;
branches;
next	;


desc
@Bill Harlan's Tau_P data processing technique
@


1.10
log
@copyright
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SUHARLAN: $Revision: 1.9 $ ; $Date: 2011/09/09 22:31:59 $	*/

#include "su.h"
#include "segy.h"
#include "header.h"
#include "taup.h"
#include <time.h>
#include <signal.h>

/**************************** self documentation *****************************/
char *sdoc[] = {
"									",
" SUHARLAN - signal-noise separation by the invertible linear		",
"	    transformation method of Harlan, 1984			",
"									",
"   suharlan <infile >outfile  [optional parameters]			",
"									",
" Required Parameters:						 	",
" <none>								",
"									",
" Optional Parameters:							",
" FLAGS:								",
" niter=1	number of requested iterations				",
" anenv=1	=1 for positive analytic envelopes			",
"		=0 for no analytic envelopes (not recommended)		",
" scl=0		=1 to scale output traces (not recommended)		",
" plot=3	=0 for no plots. =1 for 1-D plots only			",
"		=2 for 2-D plots only. =3 for all plots			",
" norm=1	=0 not to normalize reliability values			",
" verbose=1	=0 not to print processing information			",
" rgt=2		=1 for uniform random generator				",
"		=2 for gaussian random generator			",
" sts=1		=0 for no smoothing (not recommended)			",
"									",
" tmpdir= 	 if non-empty, use the value as a directory path	",
"		 prefix for storing temporary files; else if the	",
"	         the CWP_TMPDIR environment variable is set use		",
"	         its value for the path; else use tmpfile()		",
"									",
" General Parameters:							",
" dx=20		offset sampling interval (m)				",
" fx=0	  	offset on first trace (m)				",
" dt=0.004	time sampling interval (s)				",
"									",
" Tau-P Transform Parameters:						",
" gopt=1	=1 for parabolic transform. =2 for Foster/Mosher	",
"		=3 for linear. =4 for absolute value of linear		",
" pmin1=-400	minimum moveout at farthest offset for fwd transf(ms)	",
" pmax1=400	maximum moveout at farthest offset for fwd transf(ms)	",
" pmin2=pmin1	minimum moveout at farthest offset for inv transf(ms)	",
" pmax2=pmax1	maximum moveout at farthest offset for inv transf(ms)	",
" np=100	number of p-values for taup transform			",
" prewhite=0.01	prewhitening value (suggested between 0.1 and 0,01)	",
" offref=2000	reference offset for p-values (m)			",
" depthref=500	reference depth for Foster/Mosher taup (if gopt=4)	",
" pmula=pmax1	maximum p-value preserved in the data (ms)		",
" pmulb=pmax1	minimum p-value muted on the data (ms)			",
" ninterp=0	number of traces to interpolate in input data		",
"									",
" Extraction Parameters:						",
" nintlh=50	number of intervals (bins) in histograms		",
" sditer=5	number of steepest descent iterations to compute ps	",
" c=0.04	maximum noise allowed in a sample of signal(%)		",
" rel1=0.5	reliability value for first pass of the extraction	",
" rel2=0.75	reliability value for second pass of the extraction	",
"								   	",
" Smoothing Parameters:							", 
" r1=10		number of points for damped lsq vertical smoothing	",
" r2=2		number of points for damped lsq horizontal smoothing	",
"								   	",
"								   	",
" Output Files:								",
" signal=out_signal 	name of output file for extracted signal	",
" noise=out_noise 	name of output file for extracted noise		",
"									",
" 									",
" Notes:								",
" The signal-noise separation algorithm was developed by Dr. Bill Harlan",
" in 1984. It can be used to separate events that can be focused by a	",
" linear transformation (signal) from events that can't (noise). The	",
" linear transform is whatever is well siuted for the application at	",
" hand. Here, only the discrete Radon transform is used, so the program	",
" is capable of separating events focused by that transform (linear,	",
" parabolic or time-invariantly hyperbolic). Should other transform be	",
" required, the changes to the program will be relatively		",
" straightforward.							",
"									",
" The reliability parameter is the most critical one to determine what	",
" to extract as signal and what to reject as noise. It should be tested	",
" for every dataset. The way to test it is to start with a small value,	",
" say 0.1 or 0.01. If too much noise is present in the extracted noise,	",
" it is too low. If too much signal was extracted, that is, part of the	",
" signal was lost, it is too big. All other parameters have good default",
" values and should perhaps not be changed in a first encounter with the",
" program. The transform parameters are also critical. They should be	",
" chosen such that no aliasing is present and such that the range of	",
" interesting slopes is spanned by the transform but not much more. The ",
" program suradon.c has more documentation on the transform paramters.	",
"									",
NULL};

/*
 * Credits:
 * 	Gabriel Alvarez CWP (1995) 
 *	Some subroutines are direct translations to C from Fortran versions
 * 	written by Dr. Bill Harlan (1984)
 *
 * References:
 *
 * 	Harlan, S., Claerbout, J., and Roca, F. (1984), Signal/noise
 *	separation and velocity estimation, Geophysics, v. 49, no. 11,
 *	p 1869-1880. 
 *
 * 	Harlan, S. (1988), Separation of signal and noise applied to
 *	vertical seismic profiles, Geophysics, v. 53, no. 7,
 *	p 932-946. 
 *
 *	Alvarez, G. (1995), Comparison of moveout-based approaches to
 *	ground roll and multiple suppression, MSc., Department of 
 *	Geophysics, Colorado School of Mines, (Chapter 3 deals
 *	exclusively with this method).
 *
 */
/************************** end self doc *************************************/

/* Prototypes of functions used internally */
void separate_signal_noise(int verbose, int rgt, int sts, int norm, int anenv,
	int scl, int plot, int seed, int sditer, int niter, int nintlh,
	float dt, int nt, int nx, int gopt, float prewhite, int ninterp,
	float offref, float depthref, float interoff, float pmin1, float pmax1,
	float pmin2, float pmax2, int np, float dx, float c, float rel1,
	float rel2, float r1, float r2,float fx, float pmula, float pmulb,
	float **in_traces, float **signal, float **noise);

void extract_signal (int verbose, int norm, int anenv, int sts, int plot,
	int sditer, int nintlh, float c, float r, int nx, int nt, float r1,
	float r2, float **traces, float **rand_traces);

void expected_value(int nintlh, int nx, int nt, int rindex, float *pspn,
	float *pn, float *ps, float *xamps, float **traces, float *Esd);

void compute_reliability(int norm, int nx, int nt, int nintlh, int rindex,
	float c, float *ps, float *pn, float *pspn, float **traces,
	float *reliability);

void zero_noisy_samples(int anenv, int sts, int nx, int nt, float r1,
	float r2, float r, int nintlh, float *amps, float **traces,
	float **anenv_traces, float *rel);

void compute_histogram_stuff(int verbose, int nx, int nt, int nintlh,
	float **traces, float **rand_traces, int *rindex, float *amps,
	float *xamps);

void make_histogram(int nintlh, int nt, int nx, float **traces, float *amps, 
	float *pdf);

void compute_analytic_envelopes(int sgn, int nx, int nt, float **traces, 
	float **analytic_envelopes);

void scale_traces(int scl, int nx, int nt, float **in_traces, 
	float **out_traces);

void scale_one_trace(int ns, float *in_trace, float *out_trace);

void matrix_transpose(int n1, int n2, float **matrix, float **tr_matrix);

float dot_product(int ns, float *vector1, float *vector2);

void compute_max_min_sum(int nx, int nt, float *min, float *max, float *sum,
	float **data);

void plot_one_d(int npoints, float *xamps, float *data, char *plotname);

void plot_two_d(int npoints, float *data, char *plotname);

void conv1(int nx, int fx, float *x, int ny, int fy, float *y, int nz,
	int fz, float *z, int flag, float perc);

void deconvolve_histograms(int nsamples, int mean_index, int niter,
	float *pd, float *pn, float *ps);

void gradient(int ns, int si, float rmax, float *pd, float *pn,
	float *ps, float *grad);

void cross_entropy(int ns, int si, float rmax, float *pd, float *pn,
	float *ps, float *fvalue);

float divide(float rmax, float a, float b);

void golden_search(float fvalue, int *iter, float *xvalue, float *alpha);

static void closefiles(void);

/* Globals (so can trap signal) defining temporary disk files */
char tracefile[BUFSIZ];	/* filename for the file of traces	*/
char headerfile[BUFSIZ];/* filename for the file of headers	*/
FILE *tracefp;		/* fp for trace storage file		*/
FILE *headerfp;		/* fp for header storage file		*/


segy tro1,tro2,tro3;

int
main(int argc, char **argv)
{
	int ix, it;		/* loop counters */
	int anenv;		/* =1 for analytic envelopes */
	int scl;		/* =1 to apply trace scaling */
	int plot;		/* flag for producing plots */
	int seed;		/* seed for random number generator */
	int verbose;		/* flag to print processing information */
	int rgt;		/* random number generator type */
	int sts;		/* vertical and horizontal smoothing */
	int sditer;		/* # of steepest descent iterations for ps */
	int nintlh;		/* number of intervals per local histogram */
	int norm;		/* option to normalize reliability indicator */
	float c;		/* maximum error allowed for reliability */
	float rel1;		/* minimum allowed reliability (first pass) */
	float rel2;		/* minimum allowed reliability (second pass) */
	int nt;			/* number of time samples */
	int niter;		/* number of iterations */
	int ntr;		/* number of traces */
	float dx;		/* horizontal sampling interval */
	float fx;		/* offset of first trace */
	float dt;		/* time sampling interval (ms) */
	float r1;		/* vertical smoothing factor for dlsq method */
	float r2;		/*horizontal smoothing factor for dlsq method*/
	int ninterp;		/* traces to interpolate for tau-p transform*/
	int gopt;		/* options for offset function g(x) in taup */
	float offref;		/* offset reference for tau-p transform */
	float pmin1;		/* min moveout in ms at ref offset for fwd tr*/
	float pmax1;		/* max moveout in ms at ref offset for fwd tr*/
	float pmin2;		/* min moveout in ms at ref offset for inv tr*/
	float pmax2;		/* max moveout in ms at ref offset for inv tr*/
	float prewhite;		/* prewhitening factor for tau-p transform */
	float depthref;		/* reference depth if gopt=2 */
	float pmula;		/* maximum slope to keep in the data */
	float pmulb;		/* minimum slope rejected from the data */
	float interoff;		/* intercept offset for tau-p times */
	int np;			/* number of slopes (traces) in Tau-p domain */
	float **traces; 	/* Array for input traces */
	float **out_signal;	/* Array of extracted signal */
	float **out_noise; 	/* Array of extracted noise */
	char *signalfile="";	/* file name for output signal */
	char *noisefile="";	/* file name for output noise */
	FILE *signal_file;	/* File pointer to output signal */
	FILE *noise_file;	/* File pointer to output noise */
	char *tmpdir;		/* directory path for tmp files	*/
	cwp_Bool istmpdir=cwp_false;/* true for user-given path */
	
	/* hook up getpar to handle the parameters */
	initargs(argc,argv);
	requestdoc(1);

	/* get info from first trace */
	if (!gettr(&tro1))  err("can't get first trace");
	nt = tro1.ns;
	dt = (float) tro1.dt/1000000.0;

/* get general flags and set their defaults */
	if (!getparint("anenv",&anenv))			anenv	= 1;
	if (!getparint("scl",&scl))			scl	= 0;
	if (!getparint("plot",&plot))			plot	= 3;
	if (!getparint("norm",&norm))			norm	= 1;
	if (!getparint("verbose",&verbose))		verbose	= 1;
	if (!getparint("rgt",&rgt))			rgt	= 2;
	if (!getparint("sts",&sts))			sts	= 1;
	if (!getparint("gopt",&gopt))			gopt	= 1;

	/* get general parameters and set their defaults */
	if (!getparfloat("dx",&dx)) 			dx	= 20.0;
	if (!getparfloat("fx",&fx)) 			fx	= 0.0;
	if (!getparint("nintlh",&nintlh))		nintlh	= 50;
	if (!getparint("sditer",&sditer))		sditer	= 5;
	if (!getparfloat("c",&c)) 			c	= 0.05;
	if (!getparfloat("rel1",&rel1)) 		rel1	= 0.5;
	if (!getparfloat("rel2",&rel2)) 		rel2	= 0.75;
	if (!getparint("niter",&niter))			niter	= 1;
	if (!getparfloat("dt",&dt))			dt	= 0.004;

	/* get smoothing parameters and set their defaults */
	if (!getparfloat("r1",&r1))			r1	= 10.;
	if (!getparfloat("r2",&r2))			r2	= 2.;

	/* get suradon taup parameters and set their defaults */
	if (!getparfloat("pmin1",&pmin1))		pmin1	= -400.0;
	if (!getparfloat("pmax1",&pmax1))		pmax1	= 400.0;
	if (!getparfloat("pmin2",&pmin2))		pmin2	= pmin1;
	if (!getparfloat("pmax2",&pmax2))		pmax2	= pmax1;
	if (!getparint("np",&np)) 			np	= 100;
	if (!getparfloat("prewhite",&prewhite))		prewhite= 0.01;
	if (!getparfloat("offref",&offref))		offref	= 2000.;
	if (!getparfloat("interoff",&interoff))		interoff= 0.;
	if (!getparfloat("depthref",&depthref))		depthref= 0.;
	if (!getparfloat("pmula",&pmula))		pmula	= pmax1;
	if (!getparfloat("pmulb",&pmulb))		pmulb	= pmax1;
		if (!getparint("ninterp",&ninterp))	ninterp	= 0;

	/* get names of output files */
	if (!getparstring("signal",&signalfile))    signalfile="out_signal";
	if (!getparstring("noise",&noisefile))	    noisefile="out_noise";

	/* get random generator seed */
	if (!getparint("seed", &seed)) { /* if not supplied, use clock */
		if (-1 == (seed = (unsigned int) time((time_t *) NULL))) {
			seed=1;
			warn("time() failed to set seed, setting it to one");
		}
	}

	/* Look for user-supplied tmpdir */
	if (!getparstring("tmpdir",&tmpdir) &&
	    !(tmpdir = getenv("CWP_TMPDIR"))) tmpdir="";
	if (!STREQ(tmpdir, "") && access(tmpdir, WRITE_OK))
		err("you can't write in %s (or it doesn't exist)", tmpdir);

	/* Store traces in tmpfile while getting a count */
	if (STREQ(tmpdir,"")) {
		tracefp = etmpfile();
		headerfp = etmpfile();
		if (verbose) warn("using tmpfile() call");
	} else { /* user-supplied tmpdir */
		char directory[BUFSIZ];
		strcpy(directory, tmpdir);
		strcpy(tracefile, temporary_filename(directory));
		strcpy(headerfile, temporary_filename(directory));
		/* Trap signals so can remove temp files */
		signal(SIGINT,  (void (*) (int)) closefiles);
		signal(SIGQUIT, (void (*) (int)) closefiles);
		signal(SIGHUP,  (void (*) (int)) closefiles);
		signal(SIGTERM, (void (*) (int)) closefiles);
		tracefp = efopen(tracefile, "w+");
		headerfp = efopen(headerfile, "w+");
      		istmpdir=cwp_true;		
		if (verbose) warn("putting temporary files in %s", directory);
	}

	ntr = 0;
	do {
		++ntr;
		fwrite(&tro1, 1, HDRBYTES, headerfp);
		fwrite(tro1.data, FSIZE, nt, tracefp);
	} while (gettr(&tro1));

	/* allocate space */
	traces = alloc2float(nt,ntr);
	out_signal = alloc2float(nt,ntr);
	out_noise = alloc2float(nt,ntr);
	
	/* load traces into an array and close temp file */
	rewind(tracefp);
	for (ix=0; ix<ntr; ix++)
		fread (traces[ix], FSIZE, nt, tracefp);
	efclose (tracefp);

	/* separate bed reflections from diffractions and noise */
	separate_signal_noise (verbose, rgt, sts, norm, anenv, scl, plot, seed,
		sditer, niter, nintlh, dt, nt, ntr, gopt, prewhite, ninterp,
		offref, depthref, interoff, pmin1, pmax1, pmin2, pmax2, np,
		dx, c, rel1, rel2, r1, r2, fx, pmula, pmulb, traces,
		out_signal, out_noise);

	/* write extracted reflections */
	if (*signalfile !='\0') {
		if ((signal_file=fopen(signalfile,"w"))==NULL)
			err("cannot open signal file=%s\n",signalfile);
		erewind(headerfp);
		{	register int itr;
			for (itr=0; itr<ntr; itr++) {
				fread(&tro1, 1, HDRBYTES, headerfp);
				for (it=0; it<nt; it++)
					tro1.data[it]=out_signal[itr][it];
				fputtr(signal_file, &tro1);
			}
			efclose (signal_file);
		}
	}

	/* write extracted diffractions */
	if (*noisefile!='\0') {
		if ((noise_file=efopen(noisefile,"w"))==NULL)
			err("cannot open noise file=%s\n",noisefile);
		erewind(headerfp);
		{	register int itr;
			for (itr=0; itr<ntr; itr++) {
				efread(&tro2, 1, HDRBYTES, headerfp);
				for (it=0; it<nt; it++)
					tro2.data[it]=out_noise[itr][it];
				fputtr(noise_file, &tro2);
			}
			efclose (noise_file);
		}
	}

	/* free workspace */
	free2float(out_signal);
	free2float(out_noise);
	free2float(traces);
	efclose(headerfp);
	if (istmpdir) eremove(headerfile);
	if (istmpdir) eremove(tracefile);

	return(CWP_Exit());
}

/******************************************************************************

	Subroutine to separate (extract) focused energy (signal)
	from unfocused energy (noise), after applying an invertible
			linear transformation.

******************************************************************************/
void separate_signal_noise(int verbose, int rgt, int sts, int norm, int anenv,
	int scl, int plot, int seed, int sditer, int niter, int nintlh,
	float dt, int nt, int nx, int gopt, float prewhite, int ninterp,
	float offref, float depthref, float interoff, float pmin1, float pmax1,
	float pmin2, float pmax2, int np, float dx, float c, float rel1,
	float rel2, float r1, float r2,float fx, float pmula, float pmulb,
	float **in_traces, float **signal, float **noise)
/******************************************************************************
Input parameters:
Flags:
verbose		=1 to print processing information 
		=0 not to
rgt		=1 for uniform random generator
		=2 for gaussian random generator
anenv		=0 not to use analytic envelopes
		=1 to use signed analytic envelopes for extractions
		=2 to use positive analytic envelopes for extractions
		=3 to use negative analytic envelopes for extractions
scl		=0 do not apply trace scaling
		=1 apply trace by trace scaling to extracted signal
		=2 apply scaling by time slices
		=3 apply both scalings
plot		=0 not to produce any plots
		=1 to produce plots of histograms, Esd and reliability only
		=2 to also produce 2-D plots (in t-x and taup domains) 
		=3 to produce only 2-D plots (in t-x and taup domains) 
gopt		=1 for parabolic tau-p transform: g(x)=offset**2
		=2 for Foster/Mosher pseudo-hyperbolic tau-p transform
			g(x)=sqrt(ref_depth**2+offset**2)-ref_depth
		=3 linear tau-p: g(x)=offset
		=4 abs linear tau-p: g(x)=abs(offset)
		=5 for new pseudo-hyperbolic tau-p transform
			g(x)=1/ref_vel*sqrt(ref_vel**2+offset**2)


General Parameters:
seed		seed for random number generator
niter		number of iterations for extraction process
nintlh		number of intervals (bins) for making histograms
dt		time sampling interval
nt		number of time samples
nx		number of horizontal samples (traces)
fx		offset on first trace
c		maximum allowed error for reliability computation (in percent)
rel1		minimum reliability value to accept a sample as reliable 
		(first pass)
rel2		minimum reliability value to accept a sample as reliable 
		(second pass)

Taup transform parameters:
prewhite	prewhitening factor to stabilize inverse tau-p transform
		(in percent)
ninterp		number of traces to interpolate between each pair of input 
		traces prior to taup computation
offref		reference maximum offset to which tau-p times are associated 
pmin	    minimum moveout (slope) in ms on reference offset
pmin	    maximum moveout (slope) in ms on reference offset
np		number of slopes (traces) in tau-p domain
traces	  input traces

Smoothing parameters:
r1		vertical (time) soothing factor. Usually 1<r1<=20
r2		horizontal soothing factor. Usually 1<r2<=20

Input Data:
in_traces	2-D array[nx][nt] of input traces

Output Data:
signal		2-D array[nx][nt] of extracted signal
noise		2-D array[nx][nt] of noise
*******************************************************************************
Note:
In this subroutine, the different iterations are basically the same except that
an updated noise model is used. The original data array is used in every 
iteration to compute the data histogram.
******************************************************************************/
{
	int ix,ip,it,iter;		/* loop counters */
	float dp;			/* moveout sampling interva (ms) */
	float rand=0.;			/* random number */
	float rel=0.;			/* minimum reliability for extraction */
	float **traces_taup;		/* array to store tau_p traces */
	float **temp_traces_taup;
	float **noise_taup;
	char *plotname="";

	if (plot<0||plot>3) err ("plot flag has to be 0<=plot<=3");
	
	/* number of required dips to avoid aliasing in tau-p domain */
	dp=(pmax1-pmin1)/(np-1);

	/* if requested, print processing information */
	if (verbose==1) warn("nx=%d nt=%d\n",nx,nt);

	/* allocate working space */
	temp_traces_taup=alloc2float(nt,np);
	traces_taup = alloc2float(nt,np);
	noise_taup = alloc2float(nt,np);

	/* compute forward global slant stack of input traces */
		forward_p_transform (nx, nt, dt, pmax1, pmin1, dp, depthref,
		60., 80., 4., 20., 400, 5, 1, 0, ninterp, 1, prewhite,
		interoff, offref, gopt, dx, fx, pmula, pmulb, in_traces,
		traces_taup);

	/* if requested, plot input data and its taup transform */
	if (plot==2||plot==3) { 
		plotname="input";
		plot_two_d (nx*nt, in_traces[0], plotname);
		plotname="input_taup";
		plot_two_d (nx*nt, traces_taup[0], plotname);
	}

	/* save input traces */
	for (ix=0; ix<nx; ix++) 
		for (it=0; it<nt; it++) {
			noise[ix][it]=in_traces[ix][it];
	}

	/* save taup traces */
	for (ip=0; ip<np; ip++) 
		for (it=0; it<nt; it++) {
			temp_traces_taup[ip][it]=traces_taup[ip][it];
	}

	/* do bed reflections extraction (one or two iterations) */
	for (iter=0; iter<niter; iter++) {

		/* compute seed for random generator */
		if (rgt==1) sranuni(seed);	
		else if (rgt==2) srannor(seed);

			/* compute array of noise (randomly reversed) traces */
			for (ix=0; ix<nx; ix++) {
			
			if (rgt==1) rand=2.0*franuni()-1.0;
			else if (rgt==2) rand=frannor();
			
				if (rand < 0.0) {	
					for (it=0; it<nt; it++) 
						noise[ix][it] *=-1.0;
			}
		}


		/* compute global slant stack of noise traces */
		forward_p_transform (nx, nt, dt, pmax1, pmin1, dp, depthref,
			60., 80., 4., 20., 400, 5, 1, 0, ninterp, 1, prewhite,
			interoff, offref, gopt, dx, fx, pmula, pmulb,
			noise, noise_taup);

		/* if requested, plot RRT and their tau-p transform */
		if (plot==2||plot==3) {		
			if (iter==0) plotname="rand1";
			else if (iter==1) plotname="rand2";
			plot_two_d (nx*nt, noise[0], plotname);
			if (iter==0) plotname="rtaup1";
			else if (iter==1) plotname="rtaup2";
			plot_two_d (nx*nt, noise_taup[0], plotname);
		}

		/* extract signal from diffractions and noise in taup domain */
		if (iter==0) rel=rel1;
		else if (iter==1) rel=rel2;
		extract_signal (verbose, norm, anenv, sts, plot, sditer, 
			nintlh, c, rel, np, nt, r1, r2, traces_taup,
			noise_taup);

		/* inverse slant stack to get extracted reflections in t-x dom*/
		inverse_p_transform (nx, nt, dt, pmax2, pmin2, dp, depthref,
			60., 80., interoff, offref, gopt, dx, fx, traces_taup,
			signal);

		/* if requested, output plot of extracted signal ad its taup*/
		if (plot==2||plot==3) { 
			if (iter==0) plotname="signal1";
			else if (iter==1) plotname="signal2";
			plot_two_d (nx*nt, signal[0], plotname);
			if (iter==0) plotname="staup1";
			else if (iter==1) plotname="staup2";
			plot_two_d (nx*nt, traces_taup[0], plotname);
		}

		/* if requested, scale filtered traces with respect to input */
		if (scl !=0) {
			scale_traces (scl, nx, nt, in_traces, signal); 

			/* if requested, output plot of scaled signal */
			if (plot==2) {
				if (iter==0) plotname="s1scaled";
				else if (iter==1) plotname="s2scaled";
				plot_two_d (nx*nt, signal[0], plotname);
			}
		}
	
		/* subtract signal from data to estimate noise */
			for (ix=0; ix<nx; ix++) 
					for (it=0; it<nt; it++) {
				if (scl !=-1) {
					noise[ix][it]=in_traces[ix][it]-
							signal[ix][it];
				}
			}

		/* recover the taup-transformed data */
			for (ip=0; ip<np; ip++) 
					for (it=0; it<nt; it++) {
				traces_taup[ip][it]=temp_traces_taup[ip][it];
		}

		/* if requested, output plot of extracted noise */
		if (plot==2||plot==3) {  
			if (iter==0) plotname="noise1";
			else if (iter==1) plotname="noise2";
			plot_two_d (nx*nt, noise[0], plotname);
		}
	}

	/* clean up */
	free2float(temp_traces_taup);
	free2float(traces_taup);
	free2float(noise_taup);
}

/******************************************************************************

	Subroutine to extract linear reflections from behind diffractions
				and noise

******************************************************************************/
void extract_signal (int verbose, int norm, int anenv, int sts, int plot,
	int sditer, int nintlh, float c, float r, int nx, int nt, float r1,
	float r2, float **traces, float **rand_traces)
/******************************************************************************
Input:

Flags:
anenv		=0 not to use analytic envelopes
		=1 to use signed analytic envelopes
		=2 to use positive analytic envelopes	
		=3 to use negative analytic envelopes
sts		=0 not to smooth estimaded signal amplitudes
		=1 do damped least squares temporal and spatial smoothing
plot		=0 don't make any plots
		=1 make plots of histograms, reliability and Esd

General Parameters:
sditer		number of steepest descent iterations for ps computation
nintlh		number of intervals (bins) per histogram
nx		number of horizontal samples (traces)
nt		number of vertical samples

Smoothing Parameters:
r1		vertical smoothing factor (if (sts=1). 1<=r1<=20
r2		horizontal smoothing factor (if (sts=1). 1<=r2<=20

Data:
traces		2-D array[nx][nt] of tau-p transformed input traces
rand_traces	2-D array[nx][nt] of randomly reversed tau-p transformed traces

Output:
traces		2-D array[nx][nt] of tau-p transformed extracted signal traces
rand_traces	2-D array[nx][nt] of tau-p transformed extracted noise traces
******************************************************************************/
{
	int ix;			/* loop counters */
	int rindex=0;		/* reference index for histograms */
	float spd,sps,spn;	/* auxiliary variables to test unit area */
	float spspn;		/* auxilliary variable			*/
	float *pd;	   	/* array of data probability values */
	float *ps;		/* array of signal probability values */
	float *pn;		/* array of noise probability values */
	float **anenv_traces;	/* 2-D array of analytic envelopes */
	float *reliability;	/* 2-D array of computed reliability indicator*/
	float *Esd;		/* 2-D array of expected values */
	float *xamps;		/* 1-d array of reference amplitudes */
	float *amps;		/* 1-d array of amplitudes in histograms */
	float *pspn;		/* 1-d array of ps*pn */
	char *plotname="";	/* pointer to name of output plot files */
	static int count;

	/* if requested, print processing information */
	if (verbose==1) {
	    warn("PARAMETERS: c=%g rel=%g r1=%g r2=%g\n",c,r,r1,r2); 
	    warn("FLAGS: anenv=%d plot=%d sts=%d\n",anenv,plot,sts);
	}

	/* allocate space */
	pd = alloc1float(nintlh);
	ps = alloc1float(nintlh);
	pn = alloc1float(nintlh);
	amps=alloc1float(nintlh);
	xamps=alloc1float(nintlh);
	pspn=alloc1float(nintlh);
	Esd = alloc1float(nintlh);
	reliability = alloc1float(nintlh);
	anenv_traces=alloc2float(nt,nx);

	/* if requested, compute analytic envelopes */
	if (anenv !=0) 
		compute_analytic_envelopes (anenv,nx,nt,traces,anenv_traces); 

	/* compute histogram parameters */
	compute_histogram_stuff (verbose, nx, nt, nintlh, traces, rand_traces,
		&rindex, amps, xamps);

	/* compute pd(x) and pn(x) via local histograms */
	make_histogram (nintlh, nt, nx, traces, amps, pd);
	make_histogram (nintlh, nt, nx, rand_traces, amps, pn);

	/* smooth noise histogram */
	smooth_histogram (nintlh, pn);

	/* compute ps(x) via minimization of cross-entropy */
	deconvolve_histograms (nintlh, rindex, sditer, pd, pn, ps);

	/* compute ps(x) convolved with pn(x) */
	conv (nintlh, -rindex, ps, nintlh, -rindex, pn, nintlh, -rindex, pspn);

	/* coumpute array of expected values */
		expected_value (nintlh, nx, nt, rindex, pspn, pn, ps, xamps, traces,
		Esd);

	/* compute reliability as a bounded convolution */
	compute_reliability (norm, nx, nt, nintlh, rindex, c, ps, pn, pspn,
		traces, reliability);

	/* zero out noisy samples depending on their reliability */
	zero_noisy_samples (anenv, sts, nx, nt, r1, r2, r, nintlh, amps,
		traces, anenv_traces, reliability);

	/* check constraint of unit area for histograms */
	if (verbose==1) {
		spd=spn=sps=spspn=0.0;
		for (ix=0;ix<nintlh;ix++) {
			spd +=pd[ix];
			spn +=pn[ix];
			sps +=ps[ix];
			spspn +=pspn[ix];
		}
	
		if (verbose) {
			warn("Area under the curve for pd=%g\n",spd);
			warn("Area under the curve for pn=%g\n",spn);
			warn("Area under the curve for ps=%g\n",sps);
			warn("Area under the curve for ps*pn=%g\n",spspn);
		}
	}	

	/* if requested, output plots of histograms, Esd and reliabilities */
	count++;
	if (plot==1||plot==3) {
		if (count==1) plotname="pd1";
		else if (count==2) plotname="pd2";
		plot_one_d (nintlh, xamps, pd, plotname);
		if (count==1) plotname="pn1";
		else if (count==2) plotname="pn2";
		plot_one_d (nintlh, xamps, pn, plotname);
		if (count==1) plotname="ps1";
		else if (count==2) plotname="ps2";
		plot_one_d (nintlh, xamps, ps, plotname);
		if (count==1) plotname="pspn1";
		else if (count==2) plotname="pspn2";
		plot_one_d (nintlh, xamps, pspn, plotname);
		if (count==1) plotname="Esd1";
		else if (count==2) plotname="Esd2";
		plot_one_d (nintlh, xamps, Esd, plotname);
		if (count==1) plotname="rel1";
		else if (count==2) plotname="rel2";
		plot_one_d (nintlh, xamps, reliability, plotname);
	}

	/* free allocated space */
	free2float(anenv_traces);
	free1float(pd);
	free1float(ps);
	free1float(pn);
	free1float(pspn);
	free1float(amps);
	free1float(xamps);
	free1float(Esd);
	free1float(reliability);
}

/******************************************************************************

	Subroutine to compute an array of expected values E(s|d)

******************************************************************************/
void expected_value (int nintlh, int nx, int nt, int rindex, float *pspn,
	float *pn, float *ps, float *xamps, float **traces, float *Esd)
/******************************************************************************
Input:
anenv		=0 do not use analytic envelopes
		!=0 use analytic envelopes
clipf		=1 use the maximum amplitude as the clip value for division
		=2 use the sample amplitude as the clip value for division
nintlh	  number of intervals (bins) per histogram
nx		number of horizontal samples (traces) (ignored)
nt		number of vertical (time) samples (ignored)
rindex		histogram index of mean data sample
pspn		1-D array[nintlh] of ps convolved with pn
ps		1-D array[nintlh] of signal probability density function
pn		1-D array[nintlh] of noise probability density function
pd		1-D array[nintlh] of data probability density function
traces    	2-D array[nx][nt] of input traces
anenv_traces    2-D array[nx][nt] of analytic envelopes traces

Output Parameters:
Esd		1-D array[nintlh] of E(s|d) values for reference amplitudes
*******************************************************************************
expected_value uses Harlan's description of the process. It only computes
the Esd indicator for the reference amplitudes, (bin centers) and applies
linear interpolation for all other amplitudes.
******************************************************************************/
{
	int ix;			/* loop counters */
	float *xps;		/* array of x*ps(x) */
	float max;		/* maxumum amplitude in input data */

	ix = 0*nt*nx; traces += ix;
	max=xamps[nintlh-1]+(xamps[1]-xamps[0]);

	/* allocate working space */
	xps = alloc1float(nintlh);

	/* compute the product x*ps(x) */
	for (ix=0; ix<nintlh; ix++) xps[ix] = xamps[ix]*ps[ix];

	/* compute the convolution of xps(x) with pn(x) */
	conv (nintlh, -rindex, xps, nintlh, -rindex, pn, nintlh, -rindex, Esd);

	/* compute Esd for reference amplitudes (histogram bin centers) */
	for (ix=0; ix<nintlh; ix++) {
	
		/* do the division */
		Esd[ix]=divide(max,Esd[ix],pspn[ix]);
	}

	/* free allocated space */
	free1float(xps);
}

/******************************************************************************

	Compute reliability via bounded convolution

******************************************************************************/
void compute_reliability (int norm, int nx, int nt, int nintlh, int rindex,
	float c, float *ps, float *pn, float *pspn, float **traces,
	float *reliability)
/******************************************************************************
Input:
anenv		=0 not to use analytic envelopes
		!=0 use analytic envelopes
nx		number of hotizontal samples (traces) (ignored)
nt		number of vertical samples (samples per trace)
nintlh		number of bins per histogram
rindex		index of reference amplitude for histograms
c		maximum allowed error in percent
ps		1-D array[nintlh] of signal probability density histogram
pn		1-D array[nintlh] of noise probability density histogram
pspn		1-D array[nintlh] of ps convolved with pn
traces		2-D array[nx][nt] of input traces (ignored)
anenv_races	2-D array[nx][nt] of input analytic envelopes traces


Output:
reliability	1-D array[nintlh] of reliability values for bin centers
*******************************************************************************
Note:
This subroutine computes the reliability as a bounded convolution without 
explicitly computing the expected value of the signal given the data (Esd
indicator), assuming that for high amplitude samples the signal and the data
amplitudes are about the same, so in the limits of integration for the 
reliability indicator the s (signal) is implicitly replaced by d (data).
The reliability of a given sample is assumed to be that of the histogram bin 
to which it belongs)
******************************************************************************/
{
	int i;				/* loop counters */
	float max=-999999999;
	float *numerator;		/* numnerator of reliability */

	i = nt*nx*0;
	traces += i;
	/* allocate working space */
	numerator=alloc1float(nintlh);

	/* compute numerator of reliability as a bounded convolution */
		conv1 (nintlh, -rindex, ps, nintlh, -rindex, pn, nintlh, -rindex,			numerator, -1, c);

	/* compute reliability for bin centers */
	for (i=0; i<nintlh; i++) 
	  	reliability[i]=divide (1.0, numerator[i], pspn[i]);
	
	/* if requested normalize reliability */
	if (norm==1) {	
		for (i=0; i<nintlh; i++) {
			if (max<reliability[i]) max=reliability[i];
		}

		for (i=0; i<nintlh; i++) {
			reliability[i] /=max;
		}
	}

	/* free allocated space */
	free1float(numerator);
}

/******************************************************************************

	Subroutine to zero out noisy samples based on their Esd value

******************************************************************************/
void zero_noisy_samples (int anenv, int sts, int nx, int nt, float r1,
	float r2, float r, int nintlh, float *amps, float **traces, 
	float **anenv_traces, float *rel)
/******************************************************************************
Input parameters:
anenv		=1 use analytic envelopes
		=0 don't use them
sts		flag for smoothing
nx		number of horizontal samples (traces)
nt		number of vertical samples 
r		samples with reliability >r are kept 
nintlh		number of intervals in histograms	
Esd		1-D array[nintlh] of expected values for reference amplitudes
traces		2-D array[nx][nt] of input traces
anenv_traces	2-D array[nx][nt] of analytic envelope traces
rel	 	1-D array[nintlh] of reliability values for reference amplitudes

traces		2-D array[nx][nt] of extracted (focused) signal
******************************************************************************/
{
	int it,ix;		/* loop counters */
	int index=0;		/* sample index */
	float d;		/* sample amplitude */	
	float **oz;		/* array of ones and zeros */

	/* allocate working space */
	oz=alloc2float(nt,nx);

	/* create array of ones and zeros depending on reliability value */
	for (ix=0; ix<nx; ix++)
		for (it=0; it<nt; it++) {

			/* get sample amplitude */
			if (anenv==0) d=traces[ix][it];	 
			else d=anenv_traces[ix][it];

			/* find to which bin sample d belongs */
			xindex (nintlh, amps, d, &index);
			
			/* flag sample with zero or one */
			if (rel[index]<r) oz[ix][it]=0.0;
			else oz[ix][it]=1.0;
		}

	/* if requested, smooth array of zeros and ones horizontally and vert*/
	if (sts !=0) {
		dlsq_smoothing (nt, nx, 0, nt, 0, nx, r1, r2, 0, oz);
	}

	/* multiply data by smoothed array of ones and zeros */
	for (ix=0; ix<nx; ix++)
		for (it=0; it<nt; it++) 
			traces[ix][it] *=oz[ix][it];

	/* free allocated space */
	free2float(oz);
}

/******************************************************************************

	Subroutine to compute minimum, maximum, interval width and 
			amplitudes for histograms

******************************************************************************/
void compute_histogram_stuff (int verbose, int nx, int nt, int nintlh,
	float **traces, float **rand_traces, int *rindex, float *amps,
	float *xamps)
/******************************************************************************
Input:
nx		number of traces in input array
nt		number of samples per trace
nintlh		number of intervals (bins) in a histogram
rindex		pointer to reference index
traces		2-D array[nx][nt] of input traces
rand_traces	2-D array[nx][nt] of randomly reversed traces

Output:
amps		1-D array[nintlh] of left end bin amplitudes in histograms
xamps		1-D array[nintlh] of bin centers in histograms
		computed min, max and del_int values 
******************************************************************************/
{
	int ix;			/* loop counter */
	float del_int;		/* histogram bin width */
	float min1,max1;	/* minimum and maximum amplitudes of data */
	float min2,max2;	/* minimum and maximum amplitudes of noise */
	float fint;		/* auxiliary variable */
	float sum1=0.0;
	float sum2=0.0;
	float min;
	float max;

	/* compute min, max and sum of input array */
	compute_max_min_sum (nx, nt, &min1, &max1, &sum1, traces);  

	/* compute min, max and sum of randomly reversed array */
	compute_max_min_sum (nx, nt, &min2, &max2, &sum2, rand_traces);
	
	/* compute minimum and maximummbin amplitudes and bin interval */
	min = min1-0.5*(max2-min2);
	max = max1+0.5*(max2-min2);
	del_int = (max-min)/(nintlh-1);
	fint = min;
	min -= del_int/2.0;
	max += del_int/2.0;
		
	/* compute array of amplitudes for histograms */
	for (ix=0; ix<nintlh; ix++) {
		amps[ix]=min+del_int*ix;
		xamps[ix]=fint+del_int*ix;
	}

	/* find interval for the mean value of data histogram */
	xindex (nintlh, amps, sum1/(nt*nx), rindex);

	/* if requested, print processin information */
	if (verbose==1) {
		warn("for histograms: min=%g max=%g",min,max);
		warn("first bin=%g binwidth=%g\n",fint,del_int);
	}
}


/******************************************************************************

	Subroutine to compute one-dimensional histograms

******************************************************************************/
void make_histogram (int nintlh, int nt, int nx, float **traces, float *amps, 
	float *pdf)
/******************************************************************************
Input:
nintlh	  number of intervals per local histogram
nt		number of time samples
nx		number of horizontal samples
amps		1-D array[nintlh] of histogram amplitudes
traces		2-D array[nx][nt] of input traces

Output:
pdf		1-D array[nintlh] of computed  probabilty density function
******************************************************************************/
{
	int i,it,ix;   			/* loop counters */
	int index=0;			/* search index */
	int ns=nt*nx;			/* total number of samples */

	/* initialize pdf array */
	for (i=0; i<nintlh; i++) pdf[i]=0.0;

	/* compute histogram of data samples */
	for (ix=0; ix<nx; ix++) 
		for (it=0; it<nt; it++) {

			/* find interval to which sample belongs */
			xindex (nintlh, amps, traces[ix][it], &index);

			/* update interval frequencies */
			pdf[index] +=1.0;
		}

	/* normalize frequencies to get probability density distribution */
	for (i=0; i<nintlh; i++) pdf[i] /=ns;
}

/******************************************************************************

	Subroutine to compute the analytic envelopeis of an input 2-D
				array of traces

******************************************************************************/
void compute_analytic_envelopes (int sgn, int nx, int nt, float **traces, 
	float **analytic_envelopes)
/******************************************************************************
Input:
sgn			=1 compute signed analytic envelopes
			=2 compute positive analytic envelopes
			=3 compute negative analytic envelopes
			=4 compute signed square of analytic envelope
			=5 compute positive square analytic envelopes
			=6 compute negative analytic envelopes
nx			number of traces
nt			number of samples per trace
traces			2-D array[nx][nt] of input traces

Output:
analytic_envelopes	2-D array[nx][nt] of computed analytic envelops 	
******************************************************************************/
{
	int ix, it;			/* loop counters */
	float amp1,amp2,amp3;		/* auxiliary variables */
	float *hilbert_trace;		/* hilbert transform for 1 trace */

	/* allocate working space */
	hilbert_trace=alloc1float(nt);

	for (ix=0; ix<nx; ix++) {

		/* compute hilbert transform of current trace */
		hilbert (nt, traces[ix], hilbert_trace);

		for (it=0; it<nt; it++) {
			amp1=hilbert_trace[it];
			amp2=traces[ix][it];

			/* compute squared analytic envelopes */
			amp3=amp1*amp1+amp2*amp2;

			/* take care of square root */
			if (sgn==1||sgn==2||sgn==3) amp3=sqrt(amp3);

			/* take care of sign */
			if (sgn==3||sgn==6) analytic_envelopes[ix][it] =-amp3;
			else if (sgn==1||sgn==4) {
				if(amp2<0.0) analytic_envelopes[ix][it] =-amp3;
				else analytic_envelopes[ix][it] = amp3;
			} else {
				analytic_envelopes[ix][it]=amp3;
			}
		}
	}

	/* free allocated space */
	free1float(hilbert_trace);
}


/******************************************************************************

	Subroutine to scale output traces to the same amplitude level
			of the input traces

******************************************************************************/
void scale_traces (int scl, int nx, int nt, float **in_traces, 
	float **out_traces)
/******************************************************************************
Input parameters:
scl		=1 for trace scaling only
		=2 for time sice scaling only
		=3 for both 
nx		number of traces
nt		number of samples per trace
in_traces	reference set of traces to scale out_traces
out_traces	set of traces to be scaled according to amplitudes of
		in_traces

Output parameters:
out_traces	set of scaled traces
******************************************************************************/
{
	int ix,it;

	/* if requested, apply trace by trace scaling */
	if (scl==1||scl==3) {

		/* loop over traces */
		for (ix=0; ix<nx; ix++) { 
			scale_one_trace (nt,in_traces[ix],out_traces[ix]);
		}
	}  

	/* if requested, apply scaling by time sices */
	if (scl==2||scl==3) {
		float **temp_in;		/* transpose of in_traces */
		float **temp_out;		/* transpose of out_traces */

		/* allocate working space */
		temp_in=alloc2float(nx,nt);
		temp_out=alloc2float(nx,nt);

		/* transpose input and output arrays */
		matrix_transpose (nx, nt, in_traces, temp_in);
		matrix_transpose (nx, nt, out_traces, temp_out);

		/* loop over time slices */
		for (it=0; it<nt; it++) {
			scale_one_trace (nx, temp_in[it], temp_out[it]);
		}

		/* transpose output back */
		matrix_transpose (nt, nx, temp_out, out_traces);

		/* free allocated space */
		free2float(temp_in);
		free2float(temp_out);
	}
}

/******************************************************************************

	Subroutine to scale one trace to the same amplitude level of another

******************************************************************************/
void scale_one_trace (int ns, float *in_trace, float *out_trace)
/******************************************************************************
Input parameters:
ns		number of samples in trace to scale 
in_trace	reference trace to scale out_trace
out_trace 	trace to be scaled according to amplitudes of in_trace

Output parameters:
out_trace	scaled trace
******************************************************************************/	
{
	int is;
	float num,den;
	float scale;

	/* compute dot product of reference traces */
	num = dot_product (ns, in_trace, in_trace);

	/* compute dot product of output traces */	
	den = dot_product (ns, out_trace, out_trace);

	/* compute scale factor */
	if (den==0.0) {
		return;
	} else {
		scale = sqrt(num/den);	

		/* apply scale factor to each sample */
		for (is=0; is<ns; is++) {
			out_trace[is] *=scale;
		}
	}	
}

/******************************************************************************

		Subroutine to transpose a matrix

******************************************************************************/
void matrix_transpose (int n1, int n2, float **matrix, float **tr_matrix)
/******************************************************************************
Input:
n1		number of number of columns in input matrix
n2		number of rows in input matrix
matrix		2-D array[n1][n2] to be transposed

Output:
tr_matrix	2-D array[n2][n1] of transposed matrix
******************************************************************************/
{
	int i1,i2;			/* loop counters */

	for (i1=0;i1<n1;i1++)
		for (i2=0;i2<n2;i2++)
			tr_matrix[i2][i1]=matrix[i1][i2];
}

/******************************************************************************
	
		compute the dot product of two time series

******************************************************************************/
float dot_product (int ns, float *vector1, float *vector2)
/******************************************************************************
Input:
ns		number of samples in vectors
vector1		array[ns] of first vector
vector2		array[ns] of second vector

Output:
		dot product of vector1 and vector2
******************************************************************************/
{
	int is;
	float sum=0.0;

	/* compute the dot product */
	for (is=0; is<ns; is++) sum +=vector1[is]*vector2[is]; 

	/* output result */
	return(sum);
}

/******************************************************************************

	Subroutine to compute the maximum, minimum and sum of the
			samples in a 2-D array

******************************************************************************/
void compute_max_min_sum (int nx, int nt, float *min, float *max, float *sum,
	float **data)
/******************************************************************************
Input:
nx		number of horizontal samples (traces)
nt		number of vertical samples (samples per trace)
min		pointer to output minimum value
max		pointer to output maximum value
sum		pointer to output sum
data		2-D array[nx][nt] of traces

Output:
		max, min and sum values
******************************************************************************/
#define MAXVAL 9999999
{
	int ix,it;		/* loop counters */
	float d;		/* auxiliary variable for sample amplitude */

	/* initialize output variables */
	*min=MAXVAL;
	*max=-MAXVAL;
	*sum=0.0;
	
	for (ix=0; ix<nx; ix++)
		for (it=0; it<nt; it++) {

			/* get sample amplitude */
			d=data[ix][it];
	
			/* compute max, min and sum */
			if (d<*min) *min=d;
			if (d>*max) *max=d;
			*sum +=d;
		}
}

/******************************************************************************

		Output data for a one dimensional plot

******************************************************************************/
void plot_one_d (int npoints, float *xamps, float *data, char *plotname)
/******************************************************************************
Input Parameters:
npoints		number of opints to plot
xamps		1-D array [npoints] of abscissa values
data		1-D array [npoints] of ordinate values
plotname	character array of plot name

Output:
		Binary file called plotname
******************************************************************************/
{
	FILE *out;		/* file pointer to output data */

	out=fopen(plotname,"w");
	fwrite (xamps, sizeof(float), npoints, out);
	fclose(out);
	out=fopen(plotname,"a");
	fwrite (data, sizeof(float), npoints, out);
	fclose(out);
}

/******************************************************************************

		Subroutine to output a two-dimensional plot

******************************************************************************/
void plot_two_d (int npoints, float *data, char *plotname)
/******************************************************************************
Input Parameters:
npoints		number of points in output plot
data		1-D array [npoints] of data to plot
plotname	character array of plotname

Output:
		file called plotname ready to plot 
******************************************************************************/
{
	FILE *out;

	out=fopen(plotname,"w"); 
	fwrite (data, sizeof(float), npoints, out);
	fclose(out);
}

/******************************************************************************

	Subroutine to compute convolution, correlation or bounded
		convolution of two input 1-D arrays

******************************************************************************/
void conv1 (int nx, int fx, float *x, int ny, int fy, float *y, int nz,
	int fz, float *z, int flag, float perc)
/******************************************************************************
Input:
nx		number of samples in first input array
fx		index of first sample of first input array
x[nx]		first input array
ny		number of samples in second input array
fy		index of first sample of second input array
y[ny]		second input array
nz		number of samples in output array
fz		index of first sample in output array
flag		=0 for convolution, =1 for correlation and =-1 for bounded
		convolution
perc		Desired percentage for bounded convolution.
		=1 for regular convolution and correlation

Output:
z[nz]		convolution or correlation of arrays x and y

Note: z cannot be equal to x or y
*******************************************************************************
This subroutine is a direct translation to C of a Fortran version written
by Dr. Bill Harlan, 1984.
******************************************************************************/
{
	int ix,iy,iz;
	int jx,jy,jz;
	float rl,rr,r,s;

	/* initialize output array */
	for (iz=0; iz<nz; iz++) z[iz]=0.0;

	/* compute convolution or correlation */	
	for (iz=1; iz<=nz; iz++) {
		jz=iz+fz-1;

		for (ix=1; ix<=nx; ix++) {
			
			jx=ix+fx-1;
			jy=jz-jx;

			/* correlation, change the sign */
			if (flag==1) jy=jz+jx;
		
			iy=jy-fy+1;

			/* exit inner loop if out of bounds */
			if (iy<1||iy>ny) continue;
	
			s=1;	/* for normal convolution or correlation */
	
			/* if bounded convolution is desired */
			if (flag==-1) {
				r=jz;
				r=ABS(r)*perc;
				rl=jy-0.5;
				rr=jy+0.5;
				if (rl>r) rl=r;
				if (rl<-r) rl=-r;
				if (rr>r) rr=r;
				if (rr<-r) rr=-r;
				s=rr-rl;
			}

			/* update sum */
			z[iz-1] += s*x[ix-1]*y[iy-1];
		}
	}
}
	
/******************************************************************************

	Subroutine to compute ps(x) as a deconvolution of pd(x)
		and pn(x) with constraints of positivity and
				unit area

******************************************************************************/
void deconvolve_histograms (int nsamples, int mean_index, int niter,
	float *pd, float *pn, float *ps)
/******************************************************************************
Input:
nsamples	Number of samples in histograms
mean index	Index of the mean value sample in data histogram 
niter		Number of iterations for golden search (usually 10 will suffice)
pd		Array [nsamples] of data probability density function
pn		Array [nsamples] of noise probability density function

Output:
ps		Array [nsamples] of signal probability density function
*******************************************************************************
Note:
The deconvolved signal probability density funcion is computed by an
optimization algorithm in which the "best" ps(x) is computed to maximize the
probability (the fit) of the data histogram via minization of a suitable
cross-entropy indicator. The minization is performed for ps(x) with 
constraints of positivity adn unit area.
*******************************************************************************
Credits:
Translated to C by Gabriel Alvarez (1995) from a FORTRAN IV version
	written by Dr. Bill Harlan (1982)   
******************************************************************************/
{
	int j;			/* loop counter */
	int ndiv=20;		/* number of iteration for golden search */
	int iter;		/* index of iterations */
	int idiv;		/* index of golden search */
	float r1,r2;		/* proportions for ps updating */
	float rmax=1000.;	/* clip value for division of histograms */
	float alpha=0.5;	/* optimum golden search value */
	float xvalue=FLT_MIN;	/* optimum golden search x-value */
	float fvalue=0.0;       /* value of cross-entropy estimator */
	float scale=1.0;	/* some sort of scaling factor */
	float xgold;		/* x-value obtained from the golden search */
	float agold = 0;	/* alpha obtained from the golden search */
	float sum;
	float *psp=NULL;	/* array of trial perturbed ps */
	float *grad=NULL;	/* array of computed gradient */

	/* allocate working space */
	psp = alloc1float(nsamples);
	grad = alloc1float(nsamples);

	/* initialize ps array to a spike at the mean amplitude of histograms */
	for (j=0; j<nsamples; j++) ps[j]=0.0;
	ps[mean_index]=1.0;

	/* main loop */
	for (iter=0; iter<niter; iter++) {
		
		/* scale down alphas if last search was too large */ 
		/* xvalue should have the smallest non-zero value */
		/* previously used */
		scale = 2*alpha;
		if (alpha==0.0) scale = 2*xvalue;
		if (scale>1.0) scale = 1.0;

		/* compute normalized gradient of the cross-entropy estimator */
		gradient (nsamples, mean_index, rmax, pd, pn, ps, grad);

		/* do golden search to come up with optimum alpha value */
		idiv=1;
		while (idiv > 0 /*TRUE*/) {
			golden_search (fvalue, &idiv, &xgold, &agold);

			/* update xvalue and alpha */
			xvalue = xgold*scale;
			alpha = agold*scale;

			/* test to check loop exiting condition */
			if (idiv>=ndiv) break;

			/* compute trial ratios */
			r1 = 1.0 - xvalue;
			r2 = xvalue;

			/* update trial ps using trial ratios r1 and r2 */
			sum=0.0;
			for (j=0; j<nsamples; j++) {
				psp[j]=r1*ps[j]+r2*grad[j];
				sum +=psp[j];
			}

			/* normalize updated ps */
			for (j=0; j<nsamples; j++) psp[j] /=ABS(sum);

			/* compute cross-entropy estimator for updated ps */
			cross_entropy (nsamples, mean_index, rmax, pd, pn, 
				psp, &fvalue);
		}

		/* compute optimum ratios from optimum alpha */
		r1 = 1.0 - alpha;
		r2 = alpha;

		/* update ps using optimum ratios r1 and r2 */
		sum=0.0;
		for (j=0; j<nsamples; j++) {
			ps[j]=r1*ps[j]+r2*grad[j];
			sum +=ps[j];
		}

		/* normalize updated ps */
		for (j=0; j<nsamples; j++) ps[j] /=ABS(sum);
	}

	/* free allocated space */
	free1float(grad);
	free1float(psp);
}

/******************************************************************************

	Subroutine to compute the gradient of the cross-entropy estimator 
	  for constrained deconvolution of probability density
				functions

******************************************************************************/
void gradient (int ns, int si, float rmax, float *pd, float *pn,
	float *ps, float *grad)
/******************************************************************************
Input parameters:
ns		number of samples (intervals) in histograms
si		sample index of mean value in histograms
rmax		clip value for division of histograms
pd		data probability density function
pn		noise probability density function
ps		estimate of signal probability density function

Output value
grad		array of gradient of cross-entropy estimator
*******************************************************************************
Credits:
Translated to C by Gabriel Alvarez (1995) from a Fortran IV  version 
	written by Dr. Bill Harlan (1983)
******************************************************************************/
{
	int j;			/* loop variable */
	float sum;		/* variable to hold sum */
	float *pspn;		/* array for convolution of ps and pn */
	
	/* allocate space */
	pspn = alloc1float(ns);

	/* do convolution of pn with estimate of ps */
	conv (ns, -si, pn, ns, -si, ps, ns, -si, pspn); 

	/* divide pd and pspn term by term */
	for (j=0; j<ns; j++)
		pspn[j] = divide (rmax, pd[j], pspn[j]);

	/* cross-correlate pn with  pd/(ps*pn) */
	xcor (ns, -si, pn, ns, -si, pspn, ns, -si, grad); 

	/* normalize gradient */
	sum=0.0;
	for (j=0; j<ns; j++) sum +=grad[j];
	for (j=0; j<ns; j++) grad[j] /=ABS(sum);

	/* free allocated space */
	free1float(pspn);
}

/******************************************************************************

	Subroutine to compute cross-entropy estimator 

******************************************************************************/
void cross_entropy (int ns, int si, float rmax, float *pd, float *pn,
	float *ps, float *fvalue)
/******************************************************************************
Input parameters:
ns		number of samples (intervals) in histograms
si		sample index of mean value in histograms
rmax		clip value for division of histograms
pd		data probability density function
pn		noise probability densityu function
ps		estimate of signal probability function

Output value
fvalue		pointer to computed cross-entropy value
*******************************************************************************
Credits:
Translated to C by Gabriel Alvarez (1995) from a Fortran IV  version 
	written by Dr. Bill Harlan (1983)
******************************************************************************/
{
	int j;			/* loop counter */
	float sum=0.0;		/* to store the sum */
	float *pspn;		/* variable for convolution of ps and pn */

	/* allocate working space */
	pspn = alloc1float(ns);

	/* convolve ps and pn */
	conv (ns, -si, ps, ns, -si, pn, ns, -si, pspn);

	/* compute (ps*pn)/pd */
	for (j=0; j<ns; j++)
		pspn[j]=divide (rmax, pspn[j], pd[j]);
	
	/* compute the sum */
	for (j=0; j<ns; j++) {
		
		/* compute pd/(ps*pn) as the inverse of (ps*pn)/pd */
		pspn[j]=divide (rmax, 1.0, pspn[j]);

		/* multiply pd by log(pd/(ps*pn)) */
		sum +=pd[j]*log(pspn[j]);
	}

	/* output the result */
	*fvalue=sum;
} 

/******************************************************************************

	Subroutine to compute a=b/c  with a given clip value

******************************************************************************/
float divide(float rmax, float a, float b) 
/******************************************************************************
Input:
rmax		clip value
a		numerator
b		denominator

Output:	
		quotient=a/b
*******************************************************************************
Credits:
Translated to C by Gabriel Alvarez (1995) from a Fortran IV  version 
	written by Dr. Bill Harlan (1983)
******************************************************************************/
#define BIG 1000000000.0
{
	float quotient;			/* variable to hold the quotient a/b */

	/* check to see if both a and b are larger than BIG */ 	
	if (ABS(a)>BIG && ABS(b)>BIG) {
		a /=BIG;
		b /=BIG;
	} 
	
	/* check again */
	if (ABS(a)>BIG && ABS(b)>BIG) {
		a /=BIG;
		b /=BIG;
	} 

	rmax = ABS(rmax);		
	if (ABS(a)<(rmax*ABS(b))) {
		quotient  = a/b;
	
		/* this test will be true only if a and b are very small */
		if (ABS(quotient)>rmax) quotient=0.0;

	} else {
		quotient = rmax;

		/* check to see if quotient should be negative */
		if ((a>0.0 && b<0.0)||(a<0.0 && b>0.0)) quotient *= -1.0;
	}

	/* if numerator is zero, so is the quotient */	
	if (a==0.0) quotient=0.0;

	/* output quotient */
	return(quotient);
}

/******************************************************************************

	Subroutine to perform a one dimensional golden search
		for a functional value in the interval [0,1] 
	
******************************************************************************/
void golden_search (float fvalue, int *iter, float *xvalue, float *alpha)
/******************************************************************************
Input:
iter		index of iteration
fvalue		value of the function to find the minimum

Output:
xvalue		value of x that minimizes de function
alpha		optimum value
*******************************************************************************
Note:
The golden search algorithm used here is not optimum in the sense that it
does not make use of the ability of C to pass pointers to functions in a
subroutine. It was devised this way to cope with Fortran's lack of this
feature. A parabolic interpolation could perhaps be a better option.
*******************************************************************************
Credits:
Translated to C by Gabriel Alvarez (1995) from a Fortran IV  version 
	written by Dr. Bill Harlan (1983)
******************************************************************************/
{
	int j;				/* loop counter */
	static int ifill=0;		/* auxiliary function index */
	int im;				/* auxiliary index */
	float fm;			/* auxiliary variable */
	static float rmag=1.0;		/* golden ratio */
	static float x[4];		/* array to store searching points */
	static float f[4];		/* array to store function values */

	/* test condition for iteration index */
	if (*iter<1) *iter=1;			/* this should never happen */
	if (*iter==1) {
	
		/* define golden ratio */	
		*alpha = 0.0;
		rmag = 0.5*(sqrt(5.0)-1.0);

		/* initialize points for the search */
		x[0] = 0.0;
		x[1] = 1.0-rmag;
		x[2] = rmag;
		x[3] = 1.0;
		f[ifill] = fvalue;
		ifill = *iter-1;

	} else if (*iter<=4) {
	
		/* initialize function values */
		f[ifill] = fvalue;
		ifill = *iter-1;
	} else { 
	
		/* start the search */
		f[ifill] = fvalue;
		im = 0;
		fm = f[0];
		for (j=1; j<4; j++) {
			if (f[j]>=fm) continue;
			im = j;
			fm = f[j];
		}

		/* update bracketing interval */
		*alpha = x[im];
		if ((im==0)||(im==1)) {
			x[3] = x[2];
			f[3] = f[2];
			x[2] = x[1];
			f[2] = f[1];
			x[1] = (x[2] - x[0])*rmag +x[0];
			ifill = 1;
		} else {
			x[0] = x[1];
			f[0] = f[1];
			x[1] = x[2];
			f[1] = f[2];
			x[2] = x[3] - (x[3] - x[1])*rmag;
			ifill = 2;
		}
	}

	/* output values */
	*xvalue = x[ifill];
	*iter=*iter+1;
}

/* for graceful interrupt termination */
static void closefiles(void)
{
	efclose(headerfp);
	efclose(tracefp);
	eremove(headerfile);
	eremove(tracefile);
	exit(EXIT_FAILURE);
}
@


1.9
log
@*** empty log message ***
@
text
@d1 4
a4 1
/* SUHARLAN: $Revision: 1.8 $ ; $Date: 2009/01/05 18:08:35 $	*/
@


1.8
log
@changed selfdoc to read correct program name
@
text
@d1 1
a1 1
/* SUHARLAN: $Revision: 1.7 $ ; $Date: 2008/05/05 20:48:11 $	*/
d1514 1
a1514 1
	float fvalue;		/* value of cross-entropy estimator */
@


1.7
log
@some initialization extra documentation
@
text
@d1 1
a1 1
/* SUHARLAN: $Revision: 1.6 $ ; $Date: 2003/06/09 16:17:07 $	*/
d16 1
a16 1
"   susnlinsep <infile >outfile  [optional parameters]			",
@


1.6
log
@9 June 2003
@
text
@d1 1
a1 1
/* SUHARLAN: $Revision: 1.5 $ ; $Date: 1997/07/28 22:36:46 $	*/
d1517 1
a1517 1
	float agold;		/* alpha obtained from the golden search */
d1519 2
a1520 2
	float *psp;		/* array of trial perturbed ps */
	float *grad;		/* array of computed gradient */
d1533 3
a1535 2
		/* scale down alphas if last search was too large 
		xvalue should have the smallest non-zero value previously used */
@


1.5
log
@changes suggested by Stew Levin to silence SGI compiler warnings, etc
@
text
@d1 1
a1 1
/* SUHARLAN: $Revision: 1.4 $ ; $Date: 1996/09/17 19:17:23 $	*/
d403 1
a403 1
	return EXIT_SUCCESS;
@


1.4
log
@Changed default of np from ntr (not yet defined) to 100 per selfdoc.
Changed parameter signal to signalfile to avoid conflict with
signal.h's signal().  For compatibility also changed parameter noise
to noisefile.  In each, the user parameter was left as is--these are
just internal code changes.  And I'm concerned if I got it right.

Did tmpdir stuff.
@
text
@d1 1
a1 1
/* SUHARLAN: $Revision: 1.3 $ ; $Date: 1996/09/13 21:49:05 $	*/
d249 1
a249 1
	cwp_Bool istmpdir=false;/* true for user-given path */
d334 1
a334 1
      		istmpdir=true;		
d811 2
a812 2
nx		number of horizontal samples (traces)
nt		number of vertical (time) samples
d833 1
d868 1
a868 1
nx		number of hotizontal samples (traces)
d876 1
a876 1
traces		2-D array[nx][nt] of input traces
d897 2
d1544 1
a1544 1
		while (1) {
@


1.3
log
@silenced -Wall messages
@
text
@d1 1
a1 1
/* SUHARLAN: $Revision: 1.8 $ ; $Date: 1996/09/06 16:08:13 $	*/
d8 1
d35 5
d76 2
a77 1
" Notes:								",	
d192 7
d203 2
a204 1
int main(int argc, char **argv)
d227 1
a227 1
	float r2;		/* horizontal smoothing factor for dlsq method*/
d244 2
a245 4
	char *signal="";	/* file name for output signal */
	char *noise="";	 /* file name for output noise */
	FILE *datafp;	   /* File pointer for data storage file */
	FILE *hdrfp;	    /* File pointer for header storage file */
d248 2
d260 1
a260 11
	/* Store traces in tmpfile while getting a count */
	hdrfp = tmpfile();
	datafp = tmpfile();
	ntr = 0;
	do {
		++ntr;
		fwrite(&tro1, 1, HDRBYTES, hdrfp);
		fwrite(tro1.data, FSIZE, nt, datafp);
	} while (gettr(&tro1));

	/* get general flags and set their defaults */
d290 2
a291 2
		if (!getparint("np",&np)) 			np	= ntr;
		if (!getparfloat("prewhite",&prewhite))		prewhite= 0.01;
d297 1
a297 1
		if (!getparint("ninterp",&ninterp))		ninterp	= 0;
d300 2
a301 2
	if (!getparstring("signal",&signal))		signal	="out_signal";
	if (!getparstring("noise",&noise))		noise	="out_noise";
d311 34
d351 1
a351 1
	rewind(datafp);
d353 2
a354 2
		fread (traces[ix], FSIZE, nt, datafp);
	fclose (datafp);
d364 4
a367 4
	if (*signal !='\0') {
		if ((signal_file=fopen(signal,"w"))==NULL)
			err("cannot open signal file=%s\n",signal);
		rewind(hdrfp);
d370 1
a370 1
				fread(&tro1, 1, HDRBYTES, hdrfp);
d375 1
a375 1
			fclose (signal_file);
d380 4
a383 4
	if (*noise!='\0') {
		if ((noise_file=efopen(noise,"w"))==NULL)
			err("cannot open noise file=%s\n",noise);
		rewind(hdrfp);
d386 1
a386 1
				efread(&tro2, 1, HDRBYTES, hdrfp);
d391 1
a391 1
			fclose (noise_file);
d399 3
a401 1
	fclose(hdrfp);
d1840 10
@


1.2
log
@removed subroutine definitions and function prototypes that
were defined in par/lib/smooth.c and par/lib/taup.c
and par/include/taup.h par/include/par.h
respectively. Removed unused variables, fixed complaints
about variables that can be used uniitialized.
@
text
@d1 2
d7 1
@


1.1
log
@Initial revision
@
text
@a2 1
#include "VND.h"
d4 1
d116 1
a116 72
/* beginning of smoothing stuff */
void dlsq_smoothing (int nt, int nx, int ift, int ilt, int ifx, int ilx,
	float r1, float r2, float rw, float **traces);

void SG_smoothing_filter (int np, int nl, int nr, int ld, int m, float *filter);

void rwa_smoothing_filter (int flag, int nl, int nr, float *filter);

void gaussian2d_smoothing (int nx, int nt, int nsx, int nst, float **data);

void gaussian1d_smoothing (int ns, int nsr, float *data);

void smooth_histogram (int nintlh, float *pdf);

/* end of smoothing stuff */

/* beginning of taup stuff */
void fwd_FK_sstack (float dt, int nt, int nx, float xmin, float dx, int np,
	float pmin, float dp, float fmin, float **traces, float **out_traces);

void fwd_tx_sstack (float dt, int nt, int nx, float xmin, float dx, int np,
	float pmin, float dp, float fmin, float **traces, float **out_traces);

void forward_p_transform(int nx, int nt, float dt, float pmax, float pmin,
	float dp, float depthref, float f1, float f2, float freq1, float freq2,
	int lagc, int lent, int lenx, int xopt, int ninterp, int nwin,
	float prewhite, float interoff, float offref, int igopt, float dx,
	float fx, float pmula, float pmulb, float **in_traces,
	float **out_traces);

void inverse_p_transform(int nx, int nt, float dt, float pmax, float pmin,
	float dp, float depthref, float f1, float f2, float interoff,
	float offref, int igopt, float dx, float fx, float **in_traces,
	float **out_traces);

void inv_FK_sstack (float dt, int nt, int nx, float xmin, float dx, int np,
	float pmin, float dp, float fmin, float **traces, float **out_traces); 

void inv_tx_sstack (float dt, int nt, int nx, int npoints, float xmin, 
	float dx, int np, float pmin, float dp, float fmin, float **traces,
	float **out_traces); 

void rho_filter (int npoints, int nt, float dt, float *rho);

float gofx(int igopt, float offset, float intercept_off, float refdepth);

float freqweight(int j, float df, float f1, float f2);

void compute_r( float w, int nx, float *g, int np, float dp, complex *r);

void compute_rhs( float w, int nx, float *g, complex *data, int np, 
		float pmin, float dp, complex *rhs);

int ctoep( int n, complex *r, complex *a, complex *b, complex *f, complex *g );

int ctoephcg( int niter, int n, complex *a, complex *x, complex *y, 
	complex *s, complex *ss, complex *g, complex *rr);

void htmul(int n, complex *a, complex *x, complex *y);

void jea_xinterpolate(float **in_traces, float **out_traces, int ninterp, 
		int nt, int nx, float freq1, float freq2, int lagc, 
		int lent, int lenx, int xopt, float dt, int iopt);

float rcdot(int n, complex *a, complex *b);

void runav(int n,int len,float *a,float *b);

static void taupmute(int ip,int ipa,int ipb,int nt, int ltap, float *rt);

/* end tau p stuff */

d129 1
a129 1
void expected_value (int nintlh, int nx, int nt, int rindex, float *pspn,
d132 1
a132 1
void compute_reliability (int norm, int nx, int nt, int nintlh, int rindex,
d136 1
a136 1
void zero_noisy_samples (int anenv, int sts, int nx, int nt, float r1,
d140 1
a140 1
void compute_histogram_stuff (int verbose, int nx, int nt, int nintlh,
d144 1
a144 1
void make_histogram (int nintlh, int nt, int nx, float **traces, float *amps, 
d147 1
a147 1
void compute_analytic_envelopes (int sgn, int nx, int nt, float **traces, 
d150 1
a150 1
void scale_traces (int scl, int nx, int nt, float **in_traces, 
d153 1
a153 1
void scale_one_trace (int ns, float *in_trace, float *out_trace);
d155 1
a155 1
void matrix_transpose (int n1, int n2, float **matrix, float **tr_matrix);
d157 1
a157 1
float dot_product (int ns, float *vector1, float *vector2);
d159 1
a159 1
void compute_max_min_sum (int nx, int nt, float *min, float *max, float *sum,
d162 1
a162 1
void plot_one_d (int npoints, float *xamps, float *data, char *plotname);
d164 1
a164 1
void plot_two_d (int npoints, float *data, char *plotname);
d166 1
a166 1
void conv1 (int nx, int fx, float *x, int ny, int fy, float *y, int nz,
d169 1
a169 1
void deconvolve_histograms (int nsamples, int mean_index, int niter,
d172 1
a172 1
void gradient (int ns, int si, float rmax, float *pd, float *pn,
d175 1
a175 1
void cross_entropy (int ns, int si, float rmax, float *pd, float *pn,
d180 1
a180 1
void golden_search (float fvalue, int *iter, float *xvalue, float *alpha);
d185 2
a186 1
main(int argc, char **argv)
d353 1
a353 1
	/* free worksapace */
d358 2
a446 1
	int ntfft;			/* number of time fft samples */
d448 2
a449 3
	float rand;			/* random number */
	float tol;			/* tolerance for extractions */
	float rel;			/* minimum reliability for extraction */
a452 1
	FILE *out1;
d461 1
a461 3
	if (verbose==1) {
		fprintf (stderr, "nx=%d nt=%d\n",nx,nt);
	}
d634 1
a634 1
	int i,ix,it,is;		/* loop counters */
d636 2
a637 4
	float spd,sps,spn,spdd;	/* auxiliary variables to test unit area */
	float spspn;		/* auxiliary variable to test unit area */
	float amp1,amp2;	/* auxiliary variables for sample amplitudes */
	float sum;		/* auxiliary variable for sum of input samples*/
d652 2
a653 2
	    fprintf(stderr,"PARAMETERS: c=%g rel=%g r1=%g r2=%g\n",c,r,r1,r2); 
	    fprintf(stderr, "FLAGS: anenv=%d plot=%d sts=%d\n",anenv,plot,sts);
d710 6
a715 4
		fprintf (stderr,"Area under the curve for pd=%g\n",spd);
		fprintf (stderr,"Area under the curve for pn=%g\n",spn);
		fprintf (stderr,"Area under the curve for ps=%g\n",sps);
		fprintf (stderr,"Area under the curve for ps*pn=%g\n",spspn);
d785 1
a785 2
	int ix,it;		/* loop counters */
	float d;		/* auxiliary variable for sample amplitude */
d848 1
a848 3
	int i, ix, it;			/* loop counters */
	int index=0;			/* bin index of given sample */
	float d;			/* sample amplitude */
a904 1
	float amp;		/* auxiliary variable */
d999 2
a1000 2
		fprintf (stderr,"for histograms: min=%g max=%g",min,max);
		fprintf (stderr," frst bin=%g binwidth=%g\n",fint,del_int);
d1131 1
a1131 3
	int ix, it;
	float num,den;
	float scale;
a1316 1
	int ip;			/* number of points */
d1466 1
a1466 1
	float xvalue;		/* optimum golden search x-value */
a1473 1
	FILE *out1;
d1487 1
a1487 1
		xvalue shoud have the smallest non-zero value previously used */
a1795 2756
}

/***********************************Self Documentation************************/
/******************************************************************************
TAUP - Functions to perform forward and inverse taup transforms (radon or
	slant stacks) in t-x, F-K or F-X domains

fwd_FK_sstack		Performs forward taup tranaform in F-K domain, via
			8-point sinc interpolator. Only linear transform is
			possible. Very fast for taup transform of many traces.

fwd_tx_sstack		Performs forward taup transform in t-x domain.
			Only linear transform is implemented, but it is
			straight forward to implement other curves.

forward_p_transform	Performs forward tau-p transform in F-X domain. Uses
			Beylkin's approach. Not very fast but can compute
			linear parabolic or time-independent hyperbolic
			transform. Space coordinate does not need to be 
			uniformly sampled.

inv_FK_sstack		Performs inverse taup transform in F-K domain, via
			8-point sinc interpolation.

inv_tx_sstack		Performs inverse taup transform in t-x domain.

inverse_p_transform	Performs inverse taup transform in F-X domain (Beylkin's
			approach).

rho_filter		Computes rho filter in frequency domain for inverse
			t-x domain transform.

jea_xinterpolate	interpolate input data in space by placing a requested
			number of traces between each pair of input traces
*******************************************************************************
Function Prototypes:
void fwd_FK_sstack (float dt, int nt, int nx, float xmin, float dx, int np,
	float pmin, float dp, float fmin, float **traces, float **out_traces);

void fwd_tx_sstack (float dt, int nt, int nx, float xmin, float dx, int np,
	float pmin, float dp, float fmin, float **traces, float **out_traces);

void forward_p_transform(int nx, int nt, float dt, float pmax, float pmin,
	float dp, float depthref, float f1, float f2, float freq1, float freq2,
	int lagc, int lent, int lenx, int xopt, int ninterp, int nwin,
	float prewhite, float interoff, float offref, int igopt, float dx,
	float fx, float pmula, float pmulb, float **in_traces,
	float **out_traces);

void inverse_p_transform(int nx, int nt, float dt, float pmax, float pmin,
	float dp, float depthref, float f1, float f2, float interoff,
	float offref, int igopt, float dx, float fx, float **in_traces,
	float **out_traces);

void inv_FK_sstack (float dt, int nt, int nx, float xmin, float dx, int np,
	 float pmin, float dp, float fmin, float **traces, float **out_traces); 

void inv_tx_sstack (float dt, int nt, int nx, int npoints, float xmin, 
	float dx, int np, float pmin, float dp, float fmin, float **traces,
	float **out_traces); 

void rho_filter (int npoints, int nt, float dt, float *rho);

void jea_xinterpolate(float **in_traces, float **out_traces, int ninterp,
		int nt, int nx, float freq1, float freq2, int lagc,
		int lent, int lenx, int xopt, float dt, int iopt);
*******************************************************************************
fwd_FK_sstack:
Input:
dt		time sampling interval
nt		number of time samples
nx		number of horizontal samples (traces)
np		number of slopes
pmin	    minimum slope for tau-p transform
dp		slope sampling interval
fmin	    minimum frequency of interest
traces	  2-D array of input traces in t-x domain

Output:
traces	  2-D array of output traces in tau-p domain
*******************************************************************************
Credits:
	Gabriel Alvarez (1994). Based on subroutine ..... in CWP program
	migbzo.c by Dave Hale.
*******************************************************************************
fwd_tx_sstack:
Input:
dt		time sampling interval
nt		number of time samples
nx		number of horizontal samples (traces)
np		number of slopes
pmin	    minimum slope for tau-p transform
dp		slope sampling interval
fmin	    minimum frequency of interest
traces	  2-D array of input traces in t-x domain

Output:
out_traces	2-D array of output traces in tau-p domain
*******************************************************************************
Credits:
	Gabriel Alvarez (1994). 
*******************************************************************************
inv_FK_sstack:
Input:
dt		time sampling interval
nt		number of time samples
nx		number of horizontal samples
np		number of slopes
pmin	    minimum slope for inverse tau-p transform
dp		slope sampling interval
fmin	    minimum frequency of interest
traces	  2-D array of input traces in tau-p domain

Output:
out_traces	2-D array of output traces in t-x domain
*******************************************************************************
Credits:
	Gabriel Alvarez (1994).  Based on subroutine ..... in CWP program
	migbzo.c by Dave Hale.
*******************************************************************************
inv_tx_sstack:
Input:
dt		time sampling interval
nt		number of time samples
nx		number of horizontal samples
np		number of slopes
pmin	    minimum slope for inverse tau-p transform
dp		slope sampling interval
fmin	    minimum frequency of interest
traces	  2-D array of input traces in tau-p domain

Output:
out_traces	2-D array of output traces in t-x domain
*******************************************************************************
Credits:
	Gabriel Alvarez (1994).
*******************************************************************************
rho_filter:
Input:
npoints	 number of point for the rho filter
nt		number of time samples
dt		time sampling interval

Output:
rho		1-D array of filter points
*******************************************************************************
Credits:
	Gabriel Alvarez (1994).
*******************************************************************************
forward_p_transform:
Input:
nx		number of input traces
nt		number of intput time samples
dt		sample rate in seconds
dx		offset sampling interval (distance between traces) (m).
fx		first offset (meters)
igopt	   =1 parabolic transform g(x)=offset**2
		=2 Foster/Mosher pseudo hyperbolic transform
			g(x)=sqrt(depth**2+offset**2)
		=3 linear tau-p g(x)=offset
		=4 abs linear taup g(x)=abs(offset)
offref	  reference maximum offset to which maximum and minimum moveout
		times are associated
interoff	intercept offset to which tau-p times are associated
		(usually zero)
pmax	    maximum moveout in ms on reference offset
pmin	    minimum moveout in ms on reference offset
dp		moveout sampling interval (ms/m)
depthref	reference depth for Foster/Mosher hyperbolic transform
f1		high-end  frequency before taper off
f2		high-end frequency
prewhite	prewhitening factor in percent (usually between 0.01 and 0.1)
nwin	    number of windows to use through the mute zone

Parameters with good suggested values:
freq1	   low-end frequency for picking (usually 3 Hz)
freq1	   high-end frequency for picking (usually 20 Hz)
lagc	    length of AGC operator for picking (usually 400 ms)
lent	    length of time smoother in samples for picking (usually 5)
lenx	    length of space smoother in samples for picking (usually 1)
xopt	    =1 use differences for spatial derivatives (works with
		irregular spacing)
		=0 use FFT derivative for spatial derivatives (more accurate
		but requires regular spacing and at least 16 input traces),
		will switch to differences automatically is this is not met
in_traces	2-D array of input t-x traces

Output:
out_traces	2-D array[np][nt] of output tau-p traces

Notes:
offsets are computed internally as offset[ix]=fx+ix*dx
************************************************************************
Credits:
	Adapted by Gabriel Alvarez (1995) from suradon.c written by John
	Anderson (1993)
************************************************************************
inverse_p_transform:
Input:
nx		number of output traces
nt		number of output time samples
dt		time sampling interval (seconds)
dx		spatial sampling interval (meters)
fx		first offset (meters)
igopt	   =1 parabolic trransform g(x)=offset**2
		=2 Foster/Mosher pseudo hyperbolic transform
			g(x)=sqrt(depth**2+offset**2)
		=3 linear tau-p g(x)=offset
		=4 abs linear taup g(x)=abs(offset)
		=5 new pseudo-hyperbolic ransform
			g(x)=1/ref_vel*sqrt((ref_time*ref_vel)**2+offset**2)
offref	  reference maximum offset to which maximum and minimum moveout
		times are associated
interoff	intercept offset to which tau-p times are associated
		(usually zero)
pmax	    maximum moveout in ms on reference offset
pmin	    minimum moveout in ms on reference offset
dp		moveout sampling interval (ms/m)
depthref	reference depth for Foster/Mosher hyperbolic transform
f1		high-end  frequency before taper off (hz)
f2		high-end frequency (hz)
in_traces	2-D array[np][nt] of input taup traces

Output:
out_traces	2-D array[nx][nt] of output t-x traces
**************************************************************************
Credits:
	Adapted by Gabriel Alvarez (1995) from suradon.c written by John
	Anderson (1993)
**************************************************************************
jea_xinterpolate
Input:
int ninterp		number of traces to interpolate between each input trace
int nt		  number of time samples
int nx		  number of input traces
float freq1		low-end frequency for picking (good default: 3 Hz)
float freq2		high-end frequency for picking (good default: 20 Hz)
int lagc		length of AGC operator for picking(good default: 400 ms)
int lent		length of time smoother in samples for picker
			(good default: 5 samples)
int lenx		length of space smoother in samples for picker
			(good default: 1 sample)
int xopt		1 = use differences for spatial derivative
			    (works with irregular spacing)
			0 = use FFT derivative for spatial derivatives
			    (more accurate but requires regular spacing and
			    at least 16 input tracs--will switch to differences
			    automatically if have less than 16 input traces)
float dt		sample rate in sec
int iopt		0 = interpolate: output 1+(nx-1)*(1+ninterp) traces
			   with ninterp traces between each pair of input traces
			1 = compute low-pass model: output nx traces
			    on original trace locations -- This is typically
			    used for Quality Control if the interpolator
			    is failing for any reason
			2 = compute dip picks in units of samples/trace: 
			    output nx traces on original trace locations
in_traces		2-D array of input traces

Output:
out_traces		2-D array of interpolated tau-p traces


Notes:
This routine outputs 'ninterp' interpolated traces between each pair of
input traces.  The values for lagc, freq1, and freq2 are only used for
event tracking. The output data will be full bandwidth with no agc.  The
suggested default parameters typically will do a satisfactory job of
interpolation for dips up to about 12 ms/trace.  Using a larger value for
freq2 causes the algorithm to do a better job on the shallow dips, but to
fail on the steep dips.  Only one dip is assumed at each time sample between
each pair of input traces.  The original input traces are passed through
this routine without modification.

The key assumption used here is that the low frequency data are unaliased
and can be used for event tracking.  Those dip picks are used to interpolate
the original full-bandwidth data, giving some measure of interpolation
at higher frequencies which otherwise would be aliased.  Using iopt equal
to 1 allows you to visually check whether the low-pass picking model is aliased.
If you can't visually pick dips correctly on the low-pass picking
model, this computer routine will fail.

The place this code is most likely to fail is on the first breaks.
************************************************************************
Credits:
	Adapted by Gabriel Alvarez (1995) from suradon.c written by John
	Anderson (1993)
************************************************************************
Notes:
Other subroutines, used internally, might be of interest:
gofx		computes offsets for linear, parabolic or hyperbolic transforms
freqweight	computes frequency dependent weigths
compute_r	computes top row of a Hermitian Toeplitz matrix
compute_rhs	computes hermitian matrix times data vector 
ctoep		complex hermitian Toeplitz solver
ctoephcg	Hestenes and Stiefel conjugate gradient algorithm especialized
		for solving Hermitian Toeplitz systems
rcdot		computes real part of a complex dot product where the first
		vector is the one complex conjugated
runav		computes a boxcar running average filter 


More documentation about these subroutines on their headings, below.
******************************************************************************/
/*****************************End of Self Documentation***********************/





/******************************************************************************

	Compute global forward slant stack (tau-p transform) via
				FK  transform

******************************************************************************/
void fwd_FK_sstack (float dt, int nt, int nx, float xmin, float dx, int np,
	float pmin, float dp, float fmin, float **traces, float **out_traces)
/******************************************************************************
Input:
dt		time sampling interval
nt		number of time samples
nx		number of horizontal samples (traces)
np		number of slopes
pmin	    minimum slope for tau-p transform
dp		slope sampling interval
fmin	    minimum frequency of interest
traces	  2-D array of input traces in t-x domain

Output:
traces	  2-D array of output traces in tau-p domain
******************************************************************************/
{
	int it,itau,ix,iw,ik,ip;/* loop counters */
	int id,fit,lit;	 /* first and last time samples */
	float fx,fw;		/* first frequency */
	float fp,ft;	    /* first slope and time sample */
	float dw,dk;	    /* frequency and wavenumber sampling interval */
	int nw,nk;		/* number of frequencies and wavenumbers */
	int ntpad;		/* number of time samples to pad */
	int ntfft;		/* number of padded time samples */
	int xtfft;		/* number of padded horizontl samples */
	int ntau;		/*  */
	int lk;			/* last wavenumber */
	int nxfft;		/* number of x samples to pad */
	float x;		/* */
	float fftscl;		/* scale factor for FFT */
	float wmin;		/* minimum angular frequency */
	float w,p,k;	    /* frequency, slope and wavenumber */
	float phase;	    /* phase angle */
	float xshift;	   /* shift to account for non-centered x-axis */
	float c,s;		/* auxiliary variables */
	float xmax;		/* maximum horizontal value */
	float fk;	  	/* first wavenumber */
	float pmax;		/* maximum slope */
	int lwrap;		/* samples required to make k periodic */
	float fka;		/* first wavenumber with k periodic */
	float temp;		/* auxiliary variable */
	int nka;		/* number of wavenumbers with k perioic */
	float *tr_fft;	  /* padded trace for FFT */
	complex **ctr;	  /* F-K transformed trace */
	complex **ctr_p;	/*  */
	complex *tr_k;	  /* K-transformed trace  */
	complex *tr_ka;	 /*  */
	complex *tr_x;	  /* W-transformed input tracescaled  by dx */
	complex *hp;	    /* slant stacked single trace */
	float *kp;		/* K-transformed slant stacked single trace */
	complex czero;		/* complex number zero */

	/* compute slope sampling interval */
	pmax = pmin+(np-1)*dp;
	czero = cmplx(0.0,0.0);

	/* determine lengths and scale factors for FFT's */
	fx=ft=0.0;
	fp=pmin+0.5*(pmax-pmin-(np-1)*dp);
	pmax = (dp<0.0)?fp:fp+(np-1)*dp;
	xmax = (dx<0.0)?fx:fx+(nx-1)*dx;
	ntau = nt;
	ntpad = ABS(pmax*xmax)/dt;
	ntfft = npfar(MAX(nt+ntpad,ntau));
	fftscl = 1.0/ntfft;
	lwrap = 8;	/* samples required to make k periodic */
	nxfft = npfa(2*(nx+lwrap));

	/* determine frequency and wavenumber sampling */
	wmin = 2.0*PI*fmin;
	nw = ntfft/2+1;
	dw = 2.0*PI/(ntfft*dt);
	fw = 0.0;
	nk = nxfft;
	dk = 2.0*PI/(nxfft*dx);
	fk = -PI/dx;
	lk = PI/dx;
	fka = fk-lwrap*dk;
	nka = lwrap+nk+lwrap;

	/* allocate working space for FFT's */
	tr_fft = alloc1float(ntfft);
	ctr = alloc2complex(nw,nk);
	ctr_p = alloc2complex(nw,np);
	tr_ka = alloc1complex(nka);
	tr_x = tr_k=tr_ka+lwrap;	/* pointers to tr_ka[lwrap] */
	hp = alloc1complex(np);
	kp = alloc1float(np);

	/* loop over traces */
	for (ix=0; ix<nx; ix++) {

		/* pad time axis with zeros */
		for (it=0; it<nt; it++)
		tr_fft[it]=traces[ix][it];
		for (it=nt; it<ntfft; it++)
		tr_fft[it]=0.0;

		/* Fourier transform time to frequency */
		pfarc(1,ntfft,tr_fft,ctr[ix]);
	}

	/* loop over w */
	for (iw=0, w=fw; iw<nw; ++iw, w+=dw) {

	/* scale tr_x by x sampling interval */
	for (ix=0; ix<nx; ix++) {
		tr_x[ix].r = ctr[ix][iw].r*dx*fftscl;
		tr_x[ix].i = ctr[ix][iw].i*dx*fftscl;
	}

	/* pad tr_x with zeros */
	for (ix=nx; ix<nxfft; ix++)
		tr_x[ix].r = tr_x[ix].i = 0.0;

		/* negate every other sample for k-axis centered */
		for (ix=1; ix<nx; ix+=2) {
			tr_x[ix].r = -tr_x[ix].r;
			tr_x[ix].i = -tr_x[ix].i;
		}

		/* Fourier transform tr_x to tr_k */
		pfacc (-1, nxfft, tr_x);
				
		/* wrap-around tr_k to avoid interpol end effects */
		for (ik=0; ik<lwrap; ik++)
			tr_ka[ik] = tr_k[ik+nk-lwrap];
		for (ik=lwrap+nk; ik<lwrap+nk+lwrap; ik++)
			tr_ka[ik] = tr_k[ik-lwrap-nk];

		/* phase shift to account for non-centered x-axis */
		xshift = 0.5*(nx-1)*dx;
		for (ik=0, k=fka; ik<nka; ik++, k+=dk) {
			phase = k*xshift;
			c = cos(phase);
			s = sin(phase);
			temp = tr_ka[ik].r*c-tr_ka[ik].i*s;
			tr_ka[ik].i = tr_ka[ik].r*s+tr_ka[ik].i*c;
			tr_ka[ik].r=temp;
		}

		/* compute k values at which to interpolate tr_k */
		for (ip=0, p=fp; ip<np; ip++, p+=dp) {
			kp[ip] = w*p;

			/* if outside Nyq bounds do not interpolate 
			if (kp[ip]<fk && kp[ip]<lk)
				kp[ip] = fk-1000.0*dk;
			else if (kp[ip]>fk && kp[ip]>lk)
				kp[ip] = lk+1000.0*dk; */
		}

		/* 8-point sinc interpolation of tr_k to obtain h(p) */
		ints8c (nka, dk, fka, tr_ka, czero, czero, np, kp, hp);

		/* phase shift to account for non-centered x-axis */
		xshift = -fx - 0.5*(nx-1)*dx;
		for (ip=0; ip<np; ip++) {
			phase = kp[ip]*xshift;
			c = cos(phase);
			s = sin(phase);
			ctr_p[ip][iw].r = hp[ip].r*c-hp[ip].i*s;
			ctr_p[ip][iw].i = hp[ip].r*s+hp[ip].i*c;
		}
	}

	/* loop over p */
	for (ip=0; ip<np; ip++) {

		/* Fourier transform frequency to time */
		pfacr(-1, ntfft, ctr_p[ip], tr_fft);

		/* copy to output array */
		for (itau=0; itau<ntau; itau++)
		out_traces[ip][itau] = tr_fft[itau];
	}

	/* clean up */
	free1float(tr_fft);
	free2complex(ctr);
	free2complex(ctr_p);
	free1complex(tr_ka);
	free1complex(hp);
	free1float(kp);
}

/******************************************************************************

	Subroutine to compute a forward slant stack (taup transform)
				in t-x domain

******************************************************************************/
void fwd_tx_sstack (float dt, int nt, int nx, float xmin, float dx, int np,
	float pmin, float dp, float fmin, float **traces, float **out_traces)
/******************************************************************************
Input:
dt		time sampling interval
nt		number of time samples
nx		number of horizontal samples (traces)
np		number of slopes
pmin	    minimum slope for tau-p transform
dp		slope sampling interval
fmin	    minimum frequency of interest
traces	  2-D array of input traces in t-x domain

Output:
traces	  2-D array of output traces in tau-p domain
******************************************************************************/
{
	int ip,itau,ix,it;	/* loop counters */
	float x,p;		/* auxilairy variables */
	int fit,lit;		/* first and last time samples */
	int id, ii;		/* auxiliary variables */
	int ntau=nt;
	float dfrac,delay;	/* more auxiliary variables */

	/* initialize output array */
	for (ip=0; ip<np; ip++)
		for (itau=0; itau<ntau; itau++)
			out_traces[ip][itau]=0.0;

	/* loops over traces and slopes */
	for (ix=0, x=xmin; ix<nx; ix++, x+=dx) {
		for (ip=0, p=pmin; ip<np; ip++, p+=dp) {

			/* compute two point interpolator */
			delay=p*x/dt;
			if (delay>=0) {
				id = delay;
				fit = id+1;
				lit = nt-1;
			} else {
				id = (int)delay-1;
				fit = 1;
				lit = nt+id;
			}	
			dfrac = delay-id;

			/* compute the actual slant stack */
			for (it=fit; it<lit; it++) {
				ii = it-id;
				out_traces[ip][ii]+=fabs(dx)*(traces[ix][it]+
					dfrac*(traces[ix][it+1]-traces[ix][it]));
			}
		}
	}
}

/******************************************************************************

	Compute inverse global slant stack in FK domain

******************************************************************************/
void inv_FK_sstack (float dt, int nt, int nx, float xmin, float dx, int np,
	float pmin, float dp, float fmin, float **traces, float **out_traces) 
/******************************************************************************
Input Parameters:
dt		time sampling interval
nt		number of time samples
nx		number of horizontal samples
np		number of slopes
pmin	    minimum slope for inverse tau-p transform
dp		slope sampling interval
fmin	    minimum frequency of interest
traces	  2-D array of input traces in tau-p domain

Output Parameters:
out_traces	2-D array of output traces in t-x domain
******************************************************************************/

{
	int ix,ip,itau,iw,ik,it;/* loop counters */
	float fx;		/* first horizontal sample */
	float fw;		/* first frequency */
	float dw,dk;	    /* frequency and wavenumber sampling interval */
	float wmin;		/* minimum angukar frequency */
	int nw,nk;		/* number of frequencies and wavenumbers */
	int ntaupad;	    /* number of time samples to pad */
	int ntaufft;	    /* number of padded time samples */
	int npfft;		/* number of padded slope samples */
	int nkfft;		/* number of padded wavenumber samples */
	int xtfft;		/* number of padded horizontl samples */
	int nkmax;
	int ntau=nt;
	float pmax;
	float dtau=dt;		/* time intercept sampling ingerval */
	float xmax;		/* maximum horizontal value */
	float fp,fk;	    /* first slope and wavenumber */
	float w,k,p;		/* angular frequency, slope and wavenumber */
	float fftscl;  		/* scale factor for FFT */
	float *pk;		/* k-interpolated w trace */
	float *tr_fft;	  /* padded trace for FFT */
	float *rho;		/* array of rho filter sampoles */
	float **rho_traces;	/* array of rho-filtered traces */	
	complex *tr_p;
	complex **ctr;	  /* */
	complex **ctr_x;	/* */
	complex *hk;	    /* slant stacked single trace */
	complex czero;		/* complex zero number */
	float *test1;
	float **test2;
	FILE *out1;

	/* compute slope sampling interval */
	czero = cmplx(0.0,0.0);
	pmax=pmin+(np-1)*dp;

	/* determine lengths and scale factors for FFT's */
	fp=pmin+0.5*(pmax-pmin-(np-1)*dp);
	pmax=fp+(np-1)*dp;	
	xmax = fx+(nx-1)*dx;
	ntaupad = ABS(pmax*xmax)/dt;
	ntaufft = npfar(2*ntau); 
	fftscl = 1.0/ntaufft;
	nkfft = npfa(4*np);

	/* determine frequency and wavenumber sampling */
	wmin = 2.0*PI*fmin;
	nw = ntaufft/2+1;
	dw = 2.0*PI/(ntaufft*dtau);
	fw = fk = 0.0;
	dk = 2.0*PI/(nkfft*dx);
	nkmax = PI*pmax/(dt*dk) + 1;

	/* allocate working space for FFT's */
	tr_fft = alloc1float(ntaufft);
	ctr = alloc2complex(nw,np);
	ctr_x = alloc2complex(nw,nx);
	tr_p = alloc1complex(np); 
	hk = alloc1complex(nkmax);

	/* loop over traces in tau-p domain */
	for (ip=0; ip<np; ip++) {

		/* pad tau axis with zeros */
		for (itau=0; itau<ntau; itau++)
		tr_fft[itau]=traces[ip][itau];
		for (itau=ntau; itau<ntaufft; itau++)
			tr_fft[itau]=0.0;

		/* Fourier transform tau to frequency */
		pfarc(1,ntaufft,tr_fft,ctr[ip]);
	}

	/* loop over w */
	for (iw=0, w=fw; iw<nw; ++iw, w+=dw) {

	/* scale ctr by p sampling interval */
	for (ip=0; ip<np; ip++)
		tr_p[ip] = crmul(ctr[ip][iw],dp*fftscl);

		/* compute number of k's for interpolation */
		nk = pmax*w/dk + 1;
			pk = alloc1float(nk);

		/* compute p values at which to interpolate tr_p */
		for (ik=0, k=fk; ik<nk; ik++, k+=dk) {
			if (w==0.0) pk[ik]=0.0;  
			else pk[ik] = k/w;
		}
	
		/* interpolate tr_pa to obtain tr_k */ 
		ints8c (np, dp, fp, tr_p, czero, czero, nk, pk, hk); 
	
		/* free temporary space */
		free1float(pk);	

		/*pad hk with zeros  */
		for (ik=nk; ik<nkfft; ik++) 
			hk[ik]=czero;

		/* inverse Fourier transform from k to x */
		pfacc (1, nkfft, hk);

		/* copy 1-D interpolated array to 2-D array */
		for (ix=0; ix<nx; ix++)
			ctr_x[ix][iw]=hk[ix];
	}

	/* inverse Fourier transform from frequency to time */
	for (ix=0; ix<nx; ix++) {
		pfacr(-1,ntaufft,ctr_x[ix],tr_fft);
		for (it=0; it<nt; it++)
			out_traces[ix][it]=tr_fft[it];	
	} 	

	/* clean up */
	free1float(tr_fft);
	free1float(test1);
	free1complex(hk); 
	free1float(test1);
	free2float(test2);
	free1complex(tr_p);
	free2complex(ctr);
	free2complex(ctr_x);
}

/******************************************************************************

	Subroutine to compute an inverse slant stack (taup transform)
				in t-x domain

******************************************************************************/
void inv_tx_sstack (float dt, int nt, int nx, int npoints, float xmin, 
	float dx, int np, float pmin, float dp, float fmin, float **traces,
	float **out_traces) 
/******************************************************************************
Input Parameters:
dt		time sampling interval
nt		number of time samples
nx		number of horizontal samples
np		number of slopes
pmin	    minimum slope for inverse tau-p transform
dp		slope sampling interval
fmin	    minimum frequency of interest
traces	  2-D array of input traces in tau-p domain

Output Parameters:
out_traces	2-D array of output traces in t-x domain
******************************************************************************/
{
	int ip;			/* loop counter */
	int np2=npoints/2;	/* half number of points in rho filter */
	float *rho;		/* auxiliary array for rho filter */
	float **rho_traces;	/* aux array for traces convolved with rho */

	/* allocate space */
	rho_traces = alloc2float(nt,np);
	rho = alloc1float(npoints);

	/* compute rho filter */
	rho_filter (npoints, nt, dt, rho);

		/* convolve input traces with rho filter */
	for (ip=0; ip<np; ip++)
			conv(nt,-np2,traces[ip],npoints,0,rho,nt,0,rho_traces[ip]);

	/* inverse transform, call the forward transform with negative slopes */
	fwd_tx_sstack (dt, nt, np, -pmin, -dp, nx, xmin, dx, fmin, rho_traces,
		out_traces);

	/* clean up */
	free2float(rho_traces);
	free1float(rho);
}

/******************************************************************************

	Subroutine to compute the rho filter in frequenccy
	 domain for the time domain inverse slant stack

******************************************************************************/
void rho_filter (int npoints, int nt, float dt, float *rho)
/******************************************************************************
Input Parameters:
npoints	 number of point for the rho filter
nt		number of time samples
dt		time sampling interval

Output Parameters:
rho		1-D array of filter points
******************************************************************************/
{
	int it,iff; 		/* loop counters */
	int nfh,nfhp;  		/* auxiliary constants */
	int ntfft;		/* time samples to pad */
	int nph=npoints/2;
	float f,df;		/* frequency and frequency sampling interval */
	float R;		/* normalization factor */
	float Nyq;		/* Nyquist frequency */
	float t;		/* time */
	float s;
	complex *cx;	    /* scratch array */
	FILE *out1;
	float *junk;

	/* compute padding factor */
	ntfft = npfa(nt);

	/* allocate working space */
	cx = alloc1complex(ntfft);

	/* define constants */
	Nyq = 0.5/dt;
	nfh = ntfft/2;
	nfhp = nfh+1;
	df = Nyq/nfh;

	/* compute filter coefficients for positive frequencies */
	for (iff=0, f=0.0; iff<nfhp; iff++, f+=df) 
		cx[iff]=cmplx(f,0.0);

	/* compute filter coefficients for negative frequencies */
	for (iff=1; iff<nfh; iff++) {
		cx[ntfft-iff]=cx[iff];
	}

	/* inverse Fourier transform from f to t */
	pfacc(-1,ntfft,cx);

	/* compute normalization factor */
	R = 1.0/cx[0].r;

	/* initialize rho array */
	for (it=0; it<npoints; it++) rho[it]=0.0;

	/* output filter coefficients */
	rho[nph]=1.0;
	for (it=0; it<nph; it++) {
		s=cx[it+1].r*R;
		rho[nph-it-1]=s;
		rho[nph+it+1]=s;
	}

	/* clean up */
	free1complex(cx);
}

/******************************************************************************
	Compute global forward slant stack in F-X domain
			via radon transform

******************************************************************************/
void forward_p_transform(int nx, int nt, float dt, float pmax, float pmin,
	float dp, float depthref, float f1, float f2, float freq1, float freq2,
	int lagc, int lent, int lenx, int xopt, int ninterp, int nwin,
	float prewhite, float interoff, float offref, int igopt, float dx,
	float fx, float pmula, float pmulb, float **in_traces,
	float **out_traces)
/******************************************************************************
Input:
nx		number of input traces
nt		number of intput time samples
dt		sample rate in seconds
dx		offset sampling interval (distance between traces)
fx		first offset 
igopt	   =1 parabolic trransform g(x)=offset**2
		=2 Foster/Mosher pseudo hyperbolic transform
			g(x)=sqrt(depth**2+offset**2)
		=3 linear tau-p g(x)=offset
		=4 abs linear taup g(x)=abs(offset)
offref	  reference maximum offset to which maximum and minimum moveout
		times are associated
interoff	intercept offset to which tau-p times are associated
		(usually zero)
pmax	    maximum moveout in ms on reference offset
pmin	    minimum moveout in ms on reference offset
dp		moveout sampling interval (ms/m)
depthref	reference depth for Foster/Mosher hyperbolic transform
f1		high-end  frequency before taper off
f2		high-end frequency
prewhite	prewhitening factor in percent (usually between 0.01 and 0.1)
nwin	    number of windows to use through the mute zone


nwin	    number of windows to use through the mute zone

Parameters with good suggested values:
freq1	   low-end frequency for picking (usually 3 Hz)
freq1	   high-end frequency for picking (usually 20 Hz)
lagc	    length of AGC operator for picking (usually 400 ms)
lent	    length of time smoother in samples for picking (usually 5)
lenx	    length of space smoother in samples for picking (usually 1)
xopt	    =1 use differences for spatial derivatives (works with
		irregular spacing)
		=0 use FFT derivative for spatial derivatives (more accurate
		but requires regular spacing and at least 16 input traces
		will switch to differences automatically is this is not met)
in_traces	2-D array[ntfft] of input t-x traces

Output:
out_traces	2-D array of output tau-p traces

offsets are not read from the headers but computed as offset[ix]=fx+ix*dx
*******************************************************************************
Credits:
	Adapted by Gabriel Alvarez (1995) from suradon.c written by
	John Anderson (1993)
******************************************************************************/
{
	int ix,ip,it,iw,ik;		/* loop counters */
	int dummy; 			/* dummy variable */
	int ntfft;			/* length of time fft  */
	int nw;			 /* number of frequencies */
	int nxinterp;		   /* number of traces with interpol */
	int nmax;			/* maximum number of traces */
	int np;			 /* number of sopes for taup transform*/
	int ipa,ipb;
	int ltaper;
	float w;			/* frequency */
	float dw,df;		    /* frequency sampling intervals */
	float wa,wb;		    /* some sort of frequencies ??? */
	float fac;			/* scaling factor */
	float d,rsum;			/* auxiliary variables */
	float *rtr,*rrt;		/* more auxiliary vectors */
	float *rt;			/* vector to hold trace */
	float *g,*offset; 		/* arrays of offsets */
	float *xin;  			/* auxiliaty arrays */
	complex czero;		  /* complex zero number */
	complex *crt,*ccrt,*r,*rhs;	/* auxiliaty complex arrays */
	complex *wrk1,*wrk2,*wrk3,*wrk4;/* more complex arrays */
	float **interpolated_tr;	/* array of interpolated traces */
	char *fname;		    /* character pointer to file name */
	VND *vndresult;		 /* 2-D array of output (result) data */
	VND *vndinterp;		 /* 2-D array of input (interpol) data */

	/* define variables */
	ntfft=npfar(nt);
	fac = 1000.*gofx(igopt,offref,interoff,depthref);
	pmin /=fac;
	pmax /=fac;
	dp /=fac;
	pmula /=fac;
	pmulb /=fac;
	ipa = (pmula-pmin)/dp;
	ipb = (pmulb-pmin)/dp;
	if (ipa<0) ipa=0;
	ltaper=7;
	np =1+(pmax-pmin)/dp;
	nxinterp = (1+ninterp)*(nx-1)+1;
	nmax = MAX(nxinterp, np);
	nmax = MAX(nmax, ntfft+4);

	fprintf(stderr,"computing forward radon transform: pmin=%g pmax=%g"
		" dp=%g np=%d\n",pmin,pmax,dp,np);

	/* allocate 1-D VND arrays */
	offset =(float *)VNDemalloc(nx*sizeof(float),"fwdslant_taup:offset");
	rtr = (float *)VNDemalloc(nmax*sizeof(float),"fwdslant_taup:rtr");
	xin = (float *)VNDemalloc(nx*sizeof(float),"fwdslant_taup:trace");
	g = (float *)VNDemalloc(nxinterp*sizeof(float),"fwdslant_taup:gg");

	/* allocate 2-D VND arrays */
	fname = VNDtempname("radontem");
	vndinterp = V2Dop(2,2000000,sizeof(float),fname,nt,nxinterp);
	VNDfree(fname,"fwdslant_taup:fname 1");	
	fname = VNDtempname("radontmp");
	nmax = MAX(nxinterp,np);		/* max number of horiz samples*/
	vndresult = V2Dop(2,1000000,sizeof(float),fname,ntfft+2,nmax);
	VNDfree(fname,"fwdslant_taup:fname 2");

	/* compute offsets and offset function g(x) */
	for (ix=0; ix<nx; ix++) {

		/* compute offsets */
		offset[ix] = fx+ix*dx;	
	}

	/* interpolate traces */
	interpolated_tr=alloc2float(nt, nxinterp);
	jea_xinterpolate (in_traces, interpolated_tr, ninterp, nt, nx, freq1,
		freq2, lagc, lent, lenx, xopt, dt, 0);
	d = 1.0/(1+ninterp);

	/* copy interpolated traces to a VND array */
	for (ix=0; ix<nxinterp; ix++) {
		rtr[ix] = ix*d;	
		V2Dw0(vndinterp,ix,(char *)interpolated_tr[ix],1010);
	}
	free2float(interpolated_tr);
	
	/* interpolate offsets */
	for (ix=0; ix<nx; ix++)
		xin[ix] = ix;
	intlin (nx, xin, offset, offset[0], offset[nx-1], nxinterp, rtr, g);

	/* compute offset function depending on the type of transform */
	for (ix=0; ix<nxinterp; ix++) {
		g[ix] = gofx (igopt, g[ix], interoff, depthref);
	}
	
	/* define some variables */
	fac=1./ntfft;
	nw=1+ntfft/2;
	df=1./(ntfft*dt);
	dw=2.*PI*df;
	nmax=MAX(vndresult->N[0],vndresult->N[1]);
	czero.r=czero.i=0.;

	/* allocate working 1D complex space */
	crt=(complex *)VNDemalloc(nmax*sizeof(complex),
		"forward_transform:crt");
	ccrt=(complex *)VNDemalloc(MAX(2*np,vndresult->N[1])*
		sizeof(complex),"forward_transform:ccrt");
	r=(complex *)VNDemalloc(np*sizeof(complex),
		"forward_p_transform:r");
	rhs=(complex *)VNDemalloc(np*sizeof(complex),
		"forward_p_transform:rhs");
	wrk1=(complex *)VNDemalloc(np*sizeof(complex),
		"forward_p_transform:wrk1");
	wrk2=(complex *)VNDemalloc(np*sizeof(complex),
		"forward_p_transform:wrk2");
	wrk3=(complex *)VNDemalloc(np*sizeof(complex),
		"forward_p_transform:wrk3");
	wrk4=(complex *)VNDemalloc(np*sizeof(complex),
		"forward_p_transform:wrk4");

	/* pointers to complex arrays */
	rt=(float *)crt;
	rrt=(float *)ccrt;

	/* do forward time to frequency fft */
	for(ix=0;ix<nxinterp;ix++) {
		V2Dr0(vndinterp,ix,(char *)rt,201);	/* read input data */
		for(it=0;it<nt;it++) rt[it]*=fac;	/* apply fft scale */
		for(it=nt;it<ntfft;it++) rt[it]=0.;	/* zero padding */
		pfarc(1,ntfft,rt,crt);
		V2Dw0(vndresult,ix,(char *)crt,202);
	}

	VNDr2c(vndresult); 		/* real to complex conversion */

	/* do radon transform, frequency by frequency, 
	for multiple spatial windows */

	for(iw=0;iw<nw;iw++) {
		wa=freqweight(iw,df,f1,f2);	/* compute frequency weights */
		if(wa>0.) {
		    	w=iw*dw;
		    	V2Dr1(vndresult,iw,(char *)crt,203);
		    	if(wa<1.)
	 			   for(ix=0;ix<nxinterp;ix++) crt[ix]=crmul(crt[ix],wa);

			/* compute right hand side vector B+ and top row of
				Toeplitz matrix */
			compute_rhs(w,nxinterp,g,crt,np,pmin,dp,rhs);
			compute_r(w,nxinterp,g,np,dp,r);
			r[0].r *= (1.+prewhite);	/* apply prewhitening */
			for(rsum=0.,ip=1;ip<np;ip++) 
				rsum +=sqrt(r[ip].r*r[ip].r + r[ip].i*r[ip].i);
			rsum=rsum/r[0].r;  

			if (rsum>1.+np/5) { 

				/* conjugate gradient solution of Toeplitz eqn*/
				dummy=ctoephcg(np/7,np,r,&ccrt[0],rhs,
					wrk1,wrk2,wrk3,wrk4);
			} else {

				/* complex Hermitian solver of Toeplitz eqns */
				dummy=ctoep(np,r,&ccrt[0],rhs,wrk1,wrk2);
			}
		} else {
		    for(ip=0;ip<np;ip++) ccrt[ip]=czero;		
		}
		V2Dw1(vndresult,iw,(char *)ccrt,204);
	}

	/* do fourier transform from frequency to tau */
	for(ip=0; ip<np; ip++) {
		V2Dr0(vndresult,ip,(char *)crt,205);
		pfacr(-1,ntfft,crt,rt);

		/* do tau-p mute */	
		taupmute (ip,ipa,ipb,ntfft,ltaper,rt);	
	
		/* copy output data */
		for (it=0; it<nt; it++)
			out_traces[ip][it]=rt[it];
	}

	/* free allocated space */
	VNDcl(vndresult,1);
	VNDcl(vndinterp,1);
	VNDfree(crt,"forward_p_transform: crt");
	VNDfree(ccrt,"forward_p_transform: ccrt");
	VNDfree(r,"forward_p_transform: r");
	VNDfree(rhs,"forward_p_transform: rhs");
	VNDfree(wrk1,"forward_p_transform: wrk1");
	VNDfree(wrk2,"forward_p_transform: wrk2");
	VNDfree(wrk3,"forward_p_transform: wrk3");
	VNDfree(wrk4,"forward_p_transform: wrk4");	
	VNDfree(offset,"fwdslant_taup: offset");
	VNDfree(rtr,"fwdslant_taup: rtr");
	VNDfree(xin,"fwdslant_taup: xin");
	VNDfree(g,"fwdslant_taup: g");
	return;
}

/******************************************************************************

	Compute global inverse slant stack in frequency domain

******************************************************************************/
void inverse_p_transform(int nx, int nt, float dt, float pmax, float pmin,
	float dp, float depthref, float f1, float f2, float interoff,
	float offref, int igopt, float dx, float fx, float **in_traces,
	float **out_traces)
/******************************************************************************
Input:
nx		number of input traces
nt		number of intput time samples
dt		time sampling interval (seconds)
dx		spatial sampling interval (meters)
fx		first offset (meters)
igopt	   =1 parabolic trransform g(x)=offset**2
		=2 Foster/Mosher pseudo hyperbolic transform
			g(x)=sqrt(depth**2+offset**2)
		=3 linear tau-p g(x)=offset
		=4 abs linear taup g(x)=abs(offset)
offref	  reference maximum offset to which maximum and minimum moveout
		times are associated
interoff	intercept offset to which tau-p times are associated
		(usually zero)
pmax	    maximum moveout in ms on reference offset
pmin	    minimum moveout in ms on reference offset
dp		moveout sampling interval (ms/m)
depthref	reference depth for Foster/Mosher hyperbolic transform
f1		high-end  frequency before taper off (hz)
f2		high-end frequency (hz)
in_traces	2-D array[np][ntfft]  of input taup traces

Output:
out_traces	2-D array[nx][nt] of output t-x traces

*******************************************************************************
Credits:
	Adapted by Gabriel Alvarez (1995) from suradon.c written by John
	Anderson (1993)
******************************************************************************/
{
	int ix,ip,it,iw;		/* loop counters */
	int ntfft;			/* length of time fft  */
	int nw;				/* number of frequencies */
	int np;				/* number of sopes for taup transform*/
	int nmax;			/* maximum space to allocate */
	float rsum,isum;		/* real and imaginary part of a sum */
	float w;			/* frequency */
	float p;			/* slope */
	float dw,df;			/* frequency sampling intervals */
	float wa;			/* frequency weight */
	float fac;			/* fft scaling factor */
	float dr,di,tr,ti;		/* r and im parts of aux complex num*/
	float *rt;			/* auxiliary vector to store a trace */
	float *g;			/* originally input arrays */
	float *offset;			/* array of offsets */
	complex czero;			/* complex zero number */
	complex *crt;			/*complex array for FFT's */
	complex *ctemp;			/* auxiliary complex array */
	char *fname;			/* character pointer to file name */
	VND *vnda;			/* 2-D VND scratch array */

	/* define variables */
	ntfft = npfar(nt);
	fac = 1000.*gofx(igopt,offref,interoff,depthref);
	pmin /= fac;
	pmax /= fac;
	dp /= fac;
	np = 1+(pmax-pmin)/dp;
	nmax = MAX(nx,np);
	nmax = MAX(nmax,ntfft+4);

	fprintf(stderr, "computing inverse radon transform: pmin=%g pmax=%g"
		" dp=%g np=%d\n",pmin,pmax,dp,np);

	/* allocate 1-D arrays */
	offset  = (float *)VNDemalloc(nx*sizeof(float),"invslant:offset");
	g 	= (float *)VNDemalloc(nx*sizeof(float),"invslant:g");

	/* allocate VND 2-D space */
	fname = VNDtempname("radontemp");
	vnda = V2Dop(2,1000000,sizeof(float),fname,ntfft+2,nmax); 
	VNDfree(fname,"invslant:fname 1");

	/* compute offsets */
	for (ix=0; ix<nx; ix++) {

		/* compute offsets */
		offset[ix] = fx+ix*dx;	

		/* get g(x) (offset values) depending on type of transform */
		g[ix] = gofx (igopt, offset[ix], interoff, depthref);
	}
	/* copy input traces to ntfft VND array */
	for (ip=0; ip<np; ip++) {
		V2Dw0(vnda,ip,(char *)in_traces[ip],1002);
	} 
		
	nw=1+ntfft/2;
	df=1./(ntfft*dt);
	dw=2.*PI*df;
	czero.r=czero.i=0.;
	nmax=MAX(vnda->N[0],2*vnda->N[1])*vnda->NumBytesPerNode;
	nmax=MAX(nmax,nx*sizeof(complex));

	/* allocate additional VND space */
	crt=(complex *)VNDemalloc(nmax,
		"inverse_p_transform:crt");
	rt=(float *)crt;
	ctemp=(complex *)VNDemalloc(np*sizeof(complex),
		"inverse_p_transform:ctemp");

	fac=1./ntfft;
	/* compute forward time (tau) to frequency Fourier transform */
	for(ip=0;ip<np;ip++) {

		V2Dr0(vnda,ip,(char *)rt,301);
		for (it=nt; it<ntfft; it++) rt[it]=0.0;
		for(it=0;it<ntfft;it++) rt[it]*=fac;
		pfarc(1,ntfft,rt,crt);
		V2Dw0(vnda,ip,(char *)crt,302);
	}
	VNDr2c(vnda);

	fac=1./np;
	for(iw=0;iw<nw;iw++) {
		wa=freqweight(iw,df,f1,f2);
		if(wa>0.) {
			w=iw*dw;
			V2Dr1(vnda,iw,(char *)crt,303);
			if(wa<1.) {
				for(ip=0;ip<np;ip++) crt[ip]=crmul(crt[ip],wa);
			}
			for(ip=0;ip<np;ip++) ctemp[ip]=crt[ip];
			for(ix=0;ix<nx;ix++) {
			    rsum = isum = 0.;
			    for(ip=0;ip<np;ip++) {
				p = pmin + ip*dp;
				tr = cos(w*p*g[ix]);
				ti = sin(w*p*g[ix]);
				dr = ctemp[ip].r;
				di = ctemp[ip].i;
				rsum += tr*dr - ti*di;
				isum += tr*di + ti*dr;
			    }
			    crt[ix].r   = fac*rsum;
			    crt[ix].i   = fac*isum;
			}
		}else{
			for(ix=0;ix<nx;ix++) crt[ix]=czero;
		}
		V2Dw1(vnda,iw,(char *)crt,304);
	}
	for(ix=0;ix<nx;ix++) {
		V2Dr0(vnda,ix,(char *)crt,305);
		pfacr(-1,ntfft,crt,rt);

		/* copy output data */
		for (it=0; it<nt; it++)
			out_traces[ix][it]=rt[it];
	}

	/* free allocated space */
	VNDcl(vnda,1);
	VNDfree(crt,"inverse_p_transform: crt");
	VNDfree(ctemp,"inverse_p_transform: ctemp");
	VNDfree(offset,"inverse_p_tarnsform: offset");
	VNDfree(g,"inverse_p_transform: g");
	return;
}

float gofx(int igopt, float offset, float intercept_off, float refdepth)
/******************************************************************************
return g(x) for various options
*******************************************************************************
Function parameters:

int igopt		1 = parabolic transform
			2 = modified Foster/Mosher pseudo hyperbolic option
			3 = linear tau-p
			4 = linear tau-p using absolute value of 
				offset
			5 = original Foster/Mosher pseudo hyperbolic option
float offset		offset in m
float intercept_off	offset corresponding to intercept time
float refdepth		reference depth in m for igopt=2
*******************************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
******************************************************************************/
{
	offset=offset-intercept_off;
	if(igopt==1) {
		return(offset*offset);
	}
	if(igopt==2) {
		return(sqrt(refdepth*refdepth+offset*offset));
	}
	if(igopt==3) {
		return(offset);
	}
	if(igopt==4) {
		return(fabs(offset));
	}
	if(igopt==5) {
		return(sqrt(refdepth*refdepth+offset*offset)-refdepth);
	}
}


float freqweight(int j, float df, float f1, float f2)
/******************************************************************************
return weight for each frequency
*******************************************************************************
Function parameters:

int j		freq index
float df	freq increment
float f1	taper off freq
float f2	freq beyond which all components are zero
*******************************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
*****************************************************************************/
{
	float w;
	float f=j*df;
	if(f<=f1) return (1.);
	if(f>=f2) return (0.);
	w = (f2-f)/(f2-f1);
	return (w);
}

void compute_r( float w, int nx, float *g, int np, float dp, complex *r)
/******************************************************************************
Compute the top row of the Hermitian Toeplitz Matrix
			+
		  R = B B

		  i w p g(x)
where B = (1/np) e	    for equal increments in p as

	+	   -i w p g(x)
and B = (1/nx) e 

as used for the Discrete Radon Transform computation for
linear or parabolic tau-p.


		 nx-1	i w j dp g(x )
r[j] = 1/(nx*np) Sum	e	    k
		 k=0
						  2
g(x ) is initialized to  x  for linear tau-p or x   for the parabolic transform
   k			  k			 k
prior to calling this routine.  The use of g is intended to emphasize that the
spatial locations do not have to be equally spaced for either method.
In general, this routine can be called for g specified as any function
of spatial position only.  For a more general function of x, dp will
not correspond to an increment in slowness or slowness squared but
rather to a more general parameter.

*******************************************************************************
Function parameters:

float w	input as angular frequency component of interest
int   nx	number of spatial positions stored in g
float g[]	spatial function for this Radon Transform
int   np	number of slowness (or slowness squared) components
float dp	increment in slownes (or slowness squared)
float r[]	output vector of { real r0, imaginary r0, real r1, 
		imaginary r1, ...}
*******************************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
******************************************************************************/
{
	int j,k;
	float rsum, isum, fac;
	fac= 1./(nx*np);
	for(j=0;j<np;j++) {
		rsum=0.;
		isum=0.;
		for(k=0;k<nx;k++) {
			rsum = rsum+cos( w*j*dp*g[k] );
			isum = isum+sin( w*j*dp*g[k] );	
		}
		r[j].r    = fac*rsum;
		r[j].i    = fac*isum;
	}
}

void compute_rhs( float w, int nx, float *g, complex *data, int np, 
		float pmin, float dp, complex *rhs)
/******************************************************************************
					+
Compute the right-hand-side vector  B  data(x)

	+	    -i w p g(x)
where B   = (1/nx) e		for equal increments in p as
used for the Discrete Radon Transform computation for
linear or parabolic tau-p.

Function parameters:

float w	input angular frequency of interest
int   nx	number of spatial positions ( defines length of g and data )
float g[]	spatial function corresponding to spatial locations of data
complex data[] data as a function of spatial position for a single
		angular frequency w as complex values 
int   np	number of output slownesses p (may be slowness squared
		or a more general function)
float pmin	starting value of output p
float dp	increment in output p
complex rhs[]  np complex values for the result 
*******************************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
******************************************************************************/
{
	int ip, ix;
	float p, rsum, isum, dr, di, tr, ti, fac;
	fac=1./nx;
	for(ip=0;ip<np;ip++) {
		p = pmin + ip*dp;
		rsum = isum = 0.;
		for(ix=0;ix<nx;ix++) {
			tr = cos(w*p*g[ix]);
			ti = -sin(w*p*g[ix]);
			dr = data[ix].r;
			di = data[ix].i;
			rsum += tr*dr - ti*di;
			isum += tr*di + ti*dr;
		}
		rhs[ip].r   = fac*rsum;
		rhs[ip].i   = fac*isum;
	}
}

int ctoep( int n, complex *r, complex *a, complex *b, complex *f, complex *g )
/*****************************************************************************	
Complex Hermitian Toeplitz Solver for

N-1
Sum  R		A  = B	for i=0,1,2,...,N-1
j=0   (i-j)   j    i

where R is Hermitian Toeplitz and A and B are complex.  For
an example 4 x 4 system,  A returns as the solution of


   R0  R1  R2  R3	A0		B0

	*
   R1  R0  R1  R2	A1		B1
				=    
	*   *
   R2  R1  R0  R1	A2		B2

	*   *   *
   R3  R2  R1  R0	A3		B3

and


   R0  R1  R2  R3	F0		1

	*
   R1  R0  R1  R2	F1		0
				=    
	*   *
   R2  R1  R0  R1	F2		0

	*   *   *
   R3  R2  R1  R0	F3		0


*******************************************************************************	
where the function parameters are defined by

n	dimension of system
*r    provides the top row of the Hermitian Toeplitz matrix R 
*a    returns the complex solution vector A
*b    input as complex vector B (not changed during call)
*f    returns the complex spiking filter F
	(may be needed later for Simpson's sideways recursion
	if do search for optimum filter lag)
*g    work space of length n complex values

The function value returns as the number of successfully
computed complex filter coefficients (up to n) if successful or
0 if no coefficients could be computed.
*******************************************************************************	
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
******************************************************************************/

{
	float er, ei, vr, vi, cr, ci, vsq;
	int j;	  	/*  for the jth iteration, j=0,n-1 	*/
	int k;			/*  for the kth component, k=0,j-1 	*/
	int jmk;		/*  j-k 				*/
	if (r[0].r==0.) return 0;

	f[0].r = 1.0/r[0].r;
	f[0].i = 0.;
	a[0].r = b[0].r/r[0].r;
	a[0].i = b[0].i/r[0].r;
	vr=1.;
	vi=0.;
	vsq=1.;

	for(j=1;j<n;j++) {		/* iteration loop for iteration j	*/
	/*  	Compute spiking filter that outputs {v,0,0,...} 
		for this iteration step j			*/
		f[j].r=0.;
		f[j].i=0.;
		er=ei=0.;
		for(k=0;k<j;k++) {
			jmk=j-k;
			er+=r[jmk].r*f[k].r+r[jmk].i*f[k].i;
			ei+=r[jmk].r*f[k].i-r[jmk].i*f[k].r;
		}
		cr  = (er*vr - ei*vi)/vsq;
		ci  = (er*vi + ei*vr)/vsq;
		vr  = vr - (cr*er+ci*ei);
		vi  = vi + (cr*ei-ci*er);
		vsq =  vr*vr + vi*vi;
		if (vsq <= 0.) break;
		for(k=0;k<=j;k++) {
			jmk=j-k;
			g[k].r = f[k].r - cr*f[jmk].r - ci*f[jmk].i;
			g[k].i = f[k].i + cr*f[jmk].i - ci*f[jmk].r;		
		}
		for(k=0;k<=j;k++) {
			f[k]=g[k];
		}

		/*  Compute shaping filter for this iteration */
		a[j].r=0.;
		a[j].i=0.;
		er=ei=0.;
		for(k=0;k<j;k++) {
			jmk=j-k;
			er+=r[jmk].r*a[k].r+r[jmk].i*a[k].i;
			ei+=r[jmk].r*a[k].i-r[jmk].i*a[k].r;
		}
		er  = er-b[j].r;
		ei  = ei-b[j].i;
		cr  = (er*vr - ei*vi)/vsq;
		ci  = (er*vi + ei*vr)/vsq;
		for(k=0;k<=j;k++) {
			jmk=j-k;
			a[k].r += - cr*f[jmk].r - ci*f[jmk].i;
			a[k].i += + cr*f[jmk].i - ci*f[jmk].r;		
		}	
	}

	/* Properly normalize the spiking filter so that R F = {1,0,0,...} */
	/* instead of {v,0,0,...}.  To be accurate, recompute vr,vi,vsq */ 
	vr=vi=0.;
	for(k=0;k<j;k++) {
		vr+=r[k].r*f[k].r-r[k].i*f[k].i;
		vi+=r[k].r*f[k].i+r[k].i*f[k].r;
	}

	vsq = vr*vr + vi*vi;

	/*  Compute (er,ei) = 1./(vr,vi)   */
	er = vr/vsq;
	ei = -vi/vsq;
	for(k=0;k<j;k++) {
		f[k].r = er*f[k].r - ei*f[k].i;
		f[k].i = er*f[k].i + ei*f[k].r;	
	}
	return (j);
}

int ctoephcg( int niter, int n, complex *a, complex *x, complex *y, 
	complex *s, complex *ss, complex *g, complex *rr)

/******************************************************************************

Hestenes and Stiefel conjugate gradient algorithm 
specialized for solving Hermitian Toeplitz
system.  a[] is input as a vector defining the only the
top row of A.  x[] is the solution vector returned.
y[] is input.  niter is the maximum number of conjugate 
gradient steps to compute.  The function returns as
the number of steps actually computed.  The other 
vectors provide workspace.

Complex Hermitian Toeplitz Solver for

N-1
Sum  A		x  = y	for i=0,1,2,...,N-1
j=0   (i-j)   j    i

where A is Hermitian Toeplitz and x and y are complex.  For
an example 4 x 4 system,  x returns as the solution of


   A0  A1  A2  A3	x0		y0

	*
   A1  A0  A1  A2	x1		y1
				=    
	*   *
   A2  A1  A0  A1	x2		y2

	*   *   *
   A3  A2  A1  A0	x3		y3

*******************************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
******************************************************************************/
{
	int j, iter;
	complex czero;
	float alpha, beta, gamma, gammam, rsq, rp, test;
	float eps=1.0e-6;
	float rcdot(int n, complex *a, complex *b);
	rp   = rcdot(n,y,y);
	test = n*eps*eps*rp;
	czero.r=czero.i=0.;

	for(j=0;j<n;j++) {
		x[j]=czero;
		rr[j]=y[j];
	}
	htmul(n,a,rr,g);	   /*  adjoint matrix multiply */

	for(j=0;j<n;j++) s[j]=g[j];
	gammam=rcdot(n,g,g);

	for(iter=0;iter<niter;iter++) { /* forward matrix multiply  */
		htmul(n,a,s,ss);  
		alpha  = gammam/rcdot(n,ss,ss);
		for(j=0;j<n;j++) {
			x[j] =cadd(x[j],crmul(s[j],alpha));
			rr[j]=csub(rr[j],crmul(ss[j],alpha));
		}
		rsq = rcdot(n,rr,rr);
		if ( iter>0 && ( rsq==rp || rsq<test ) ) return(iter-1);
		rp = rsq;

		htmul(n,a,rr,g);   /*  adjoint matrix multiply  */
		gamma  = rcdot(n,g,g);
		if (gamma<eps) break;
		beta   = gamma/gammam;
		gammam = gamma;			

		for(j=0;j<n;j++) {
			s[j] =cadd(g[j],crmul(s[j],beta));
		}	
	}
return(iter);
}

void jea_xinterpolate(float **in_traces, float **out_traces, int ninterp, 
		int nt, int nx, float freq1, float freq2, int lagc, 
		int lent, int lenx, int xopt, float dt, int iopt)
/******************************************************************************
interpolate input data in space placing "ninterp" synthetic traces 
between each pair of original input traces
*******************************************************************************
Function parameters:
Input:
int ninterp		number of traces to interpolate between each input trace
int nt			number of time samples
int nx			number of input traces
float freq1		low-end frequency for picking (good default: 3 Hz)
float freq2		high-end frequency for picking (good default: 20 Hz)
int lagc		length of AGC operator for picking (good default:400 ms)
int lent		length of time smoother in samples for picker
			(good default: 5 samples)
int lenx		length of space smoother in samples for picker
			(good default: 1 sample)
int xopt		1 = use differences for spatial derivative
			    (works with irregular spacing)
			0 = use FFT derivative for spatial derivatives
			    (more accurate but requires regular spacing and
			    at least 16 input tracs--will switch to differences
			    automatically if have less than 16 input traces)
float dt		sample rate in sec
int iopt		0 = interpolate: output 1+(nx-1)*(1+ninterp) traces
			   with ninterp traces between each pair of input traces
			1 = compute low-pass model: output nx traces
			    on original trace locations -- This is typically
			    used for Quality Control if the interpolator
			    is failing for any reason
			2 = compute dip picks in units of samples/trace: 
			    output nx traces on original trace locations
in_traces		2-D array of input data

Output:
out_traces		2-D array of interpolated traces


Notes:
This routine outputs 'ninterp' interpolated traces between each pair of 
input traces.  The values for lagc, freq1, and freq2 are only used for
event tracking. The output data will be full bandwidth with no agc.  The 
suggested default parameters typically will do a satisfactory job of 
interpolation for dips up to about 12 ms/trace.  Using a larger value for 
freq2 causes the algorithm to do a better job on the shallow dips, but to 
fail on the steep dips.  Only one dip is assumed at each time sample between 
each pair of input traces.  The original input traces are passed through
this routine without modification.

The key assumption used here is that the low frequency data are unaliased
and can be used for event tracking.  Those dip picks are used to interpolate
the original full-bandwidth data, giving some measure of interpolation
at higher frequencies which otherwise would be aliased.  Using iopt equal
to 1 allows you to visually check whether the low-pass picking model is aliased.
If you can't visually pick dips correctly on the low-pass picking 
model, this computer routine will fail.

The place this code is most likely to fail is on the first breaks.
*******************************************************************************
Credits:
Adapted by Gabriel Alvarez (1995) from suradon.c written by John 
	Anderson (1993)
******************************************************************************/
{
	int	ntfft,ntfftny,nxfft,nxfftny,jlow,jhigh,j,k,ix,it,ixm;
	float	df,dff,wa,wb,dxx,eps=1.0e-30,f,fcl,fch;
	float 	*rt,*rrt,*a,*b,*p,*time,*aa,*bb,*save;
	complex	*crt,*ccrt,czero;
	VND	*vnda,*vndb;
	char 	*fname;

	/* defensive programming */
	if(nx<2 || (iopt==0 && ninterp==0) ) {
		for (ix=0;ix<nx;ix++)
			for (it=0;it<nt;it++)
				out_traces[ix][it]=in_traces[ix][it];	
		return;
	}

	/* define useful variables */
	lent=1+2*(lent/2);
	lenx=1+2*(lenx/2);
	lagc=1 + lagc*0.001/dt;

	ntfft=npfar(nt);
	ntfftny=1+ntfft/2;
	nxfft=npfar(nx);
	nxfftny=1+nxfft/2;

	df=1./(ntfft*dt);
	jlow = freq1/df;
	jhigh = freq2/df;	
	czero.r=czero.i=0.;

	/* allocate working VND space */
	crt = (complex *)VNDemalloc( MAX(ntfftny,nxfftny)*sizeof(complex),
		"jea_xinterpolate:allocating crt" );
	rt = (float *)crt;
	ccrt = (complex *)VNDemalloc( ntfftny*sizeof(complex),
		"jea_xinterpolate:allocating ccrt" );
	rrt = (float *)ccrt;
	a =  (float *)VNDemalloc( MAX(nx,nt)*sizeof(float),
		"jea_xinterpolate:allocating a" );
	b =  (float *)VNDemalloc( MAX(nx,nt)*sizeof(float),
		"jea_xinterpolate:allocating b" );
	p =  (float *)VNDemalloc( nt*sizeof(float),
		"jea_xinterpolate:allocating p" );
	time =  (float *)VNDemalloc( nt*sizeof(float),
		"jea_xinterpolate:allocating time" );
	aa =  (float *)VNDemalloc( MAX(nx,nt)*sizeof(float),
		"jea_xinterpolate:allocating aa" );
	bb =  (float *)VNDemalloc( MAX(nx,nt)*sizeof(float),
		"jea_xinterpolate:allocating bb" );

	fname = VNDtempname("jea_xinterpolate");
	vnda  = V2Dop(2,500000,sizeof(float),fname,nt,nx);
	VNDfree(fname,"jea_xinterpolate: fname");
	fname = VNDtempname("jea_xinterpolate");
	vndb  = V2Dop(2,500000,sizeof(float),fname,nt,nx);
	VNDfree(fname,"jea_xinterpolate: fname");

	/* loop computing filtered data for picking purposes in vnda */
	/* compute time derivative of filtered data in vndb */
	dff=2.*PI/ntfft;
	for(ix=0;ix<nx;ix++) {
		for(it=0;it<nt;it++) {
			rt[it]=in_traces[ix][it];
			a[it]=fabs(rt[it]);
		}
		runav(nt,lagc,a,b);
		runav(nt,lagc,b,a);
		for(it=0;it<nt;it++) rt[it]=rt[it]/(a[it]+eps);	
		for(it=nt;it<ntfft;it++) rt[it]=0.;
		pfarc(1,ntfft,rt,crt);
		for(it=0;it<ntfftny;it++){
			f=it*df;
			fcl=(f/freq1);
			fcl=fcl*fcl*fcl*fcl;
			fch=(f/freq2);
			fch=fch*fch*fch*fch;
			f=fcl/( (1.+fcl)*(1.+fch) );
			crt[it]=crmul(crt[it],f);
			ccrt[it]=cmul(crt[it],cmplx(0.,-it*dff));
		}
		pfacr(-1,ntfft,crt,rt); 
		V2Dw0(vnda,ix,(char *)rt,104);
		pfacr(-1,ntfft,ccrt,rrt); 
		V2Dw0(vndb,ix,(char *)rrt,105);
	} 

	if(iopt==1){
		for(ix=0;ix<nx;ix++){
			V2Dr0(vnda,ix,(char *)rt,104);
			for (it=0;it<nt;it++)
				out_traces[ix][it]=rt[it];
		}
		VNDcl(vnda,1);
		VNDcl(vndb,1);
		VNDfree(crt,"jea_xinterpolate: crt");
		VNDfree(ccrt,"jea_xinterpolate: ccrt");
		VNDfree(a,"jea_xinterpolate: a");
		VNDfree(b,"jea_xinterpolate: b");
		VNDfree(p,"jea_xinterpolate: p");
		VNDfree(time,"jea_xinterpolate: time");
		VNDfree(aa,"jea_xinterpolate: aa");
		VNDfree(bb,"jea_xinterpolate: bb");
		return;
	}

	/* loop computing spatial derivative of data for picking purposes*/
	nxfft=npfar(nx);
	nxfftny=1+nxfft/2;
	dxx=2.*PI/(nxfft*nxfft);
	if(nx<16) xopt=1;
	for(it=0;it<nt;it++) {
		V2Dr1(vnda,it,(char *)rt,106);
		if(xopt) {
			for(j=0;j<nx-1;j++) rt[j]=rt[j+1]-rt[j];
			rt[nx-1]=rt[nx-2];
		}else{
			for(j=nx;j<nxfft;j++) rt[j]=0.;
			pfarc(1,nxfft,rt,crt);
			for(j=0;j<nxfftny;j++){
				crt[j]=cmul(crt[j],cmplx(0.,-j*dxx));
			}
			pfacr(-1,nxfft,crt,rt); 
		}
		V2Dw1(vnda,it,(char *)rt,107);
	} 

	/* compute dot products and smooth over time */
	for(ix=0;ix<nx;ix++) {
		V2Dr0(vnda,ix,(char *)a,108);
		V2Dr0(vndb,ix,(char *)b,109);
		for(it=0;it<nt;it++) {
			aa[it]=a[it]*b[it];
			bb[it]=b[it]*b[it];
		}
		runav(nt,lent,aa,a);
		runav(nt,lent,a,aa);
		runav(nt,lent,bb,b);
		runav(nt,lent,b,bb);
		V2Dw0(vnda,ix,(char *)aa,110);
		V2Dw0(vndb,ix,(char *)bb,111);
	}

	/* smooth dot products in x */
	if(lenx>1){
	    for(it=0;it<nt;it++) {
		V2Dr1(vnda,it,(char *)a,112);
		V2Dr1(vndb,it,(char *)b,113);
		runav(nx,lenx,a,aa);
		runav(nx,lenx,aa,a);
		runav(nx,lenx,b,bb);
		runav(nx,lenx,bb,b);
		V2Dw1(vnda,it,(char *)a,114);
		V2Dw1(vndb,it,(char *)b,115);
	    }
	}

	/* loop computing p, interpolating, and outputting results */
	/* get first trace from input data */
	for (it=0; it<nt; it++)
		a[it]=in_traces[0][it];
	for(ix=1;ix<nx;ix++) {
		ixm=ix-1;
		V2Dr0(vnda,ixm,(char *)aa,117);
		V2Dr0(vndb,ixm,(char *)bb,118);
		for(it=0;it<nt;it++) {
			p[it] = - aa[it]/( bb[it] + eps );
		}
		
		/* get input traces one by one */
		for (it=0; it<nt; it++)
			b[it]=in_traces[ix][it];	
		if(iopt==2) {
	
			/* write to output array */
			for (it=0; it<nt; it++)
				out_traces[ixm][it]=p[it];
			/* don't output dip picks except on original traces */
		}else{
			/* write to output array */
			for (it=0; it<nt; it++)
				out_traces[ixm*(ninterp+1)][it]=a[it];
			for(k=0;k<ninterp;k++){
				wa=(1.+k)/(1+ninterp);
				wb=1.-wa;
				for(it=0;it<nt;it++) time[it] = it - p[it]*wa;		
				ints8r(nt,1.0,0.,a,0.0,0.0,nt,time,aa);
				for(it=0;it<nt;it++) time[it] = it + p[it]*wb;		
				ints8r(nt,1.0,0.,b,0.0,0.0,nt,time,bb);
				for(it=0;it<nt;it++) aa[it]=wb*aa[it]+wa*bb[it];

				/* write to output array */
				for (it=0; it<nt; it++)
					out_traces[k+1+ixm*(ninterp+1)][it]=
						aa[it];
			}
		}
		save=a;
		a=b;
		b=save;  
	} 
	if(iopt==2) {
		
		/* write to output array */
		for (it=0; it<nt; it++)
			out_traces[nx-1][it]=p[it];
	}else{
		/* write to output array */
		for (it=0; it<nt; it++)
			out_traces[(nx-1)*(ninterp+1)][it]=a[it];
	}


	/* close files, free temporary memory */
	VNDcl(vnda,1);
	VNDcl(vndb,1);
	VNDfree(crt,"jea_xinterpolate: crt");
	VNDfree(ccrt,"jea_xinterpolate: ccrt");
	VNDfree(a,"jea_xinterpolate: a");
	VNDfree(b,"jea_xinterpolate: b");
	VNDfree(p,"jea_xinterpolate: p");
	VNDfree(time,"jea_xinterpolate: time");
	VNDfree(aa,"jea_xinterpolate: aa");
	VNDfree(bb,"jea_xinterpolate: bb");

	return;
}

float rcdot(int n, complex *a, complex *b)
/****************************************************************************** 
return the real part of a complex dot product where
    the first vector is the one complex conjugated
*******************************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
*****************************************************************************/
{
	int j;
	float sum=0.;
	for(j=0;j<n;j++) sum += a[j].r * b[j].r + a[j].i * b[j].i;
	return(sum);
}

void htmul(int n, complex *a, complex *x, complex *y)

/******************************************************************************
   Hermitian Toeplitz matrix multiply

	solve for y = A x   where A is Hermitian Toeplitz

	and defined by the vector a giving the top row of A.
	x is input.  y is output. 
*******************************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
******************************************************************************/
{
	int j,irow;
	complex czero;
	czero.r=czero.i=0.;

	for(irow=0;irow<n;irow++) {
		y[irow]=czero;
		for(j=0;j<irow;j++)
			y[irow] = cadd(cmul(conjg(a[irow-j]),x[j]),y[irow]);
		for(j=irow;j<n;j++)
			y[irow] = cadd(cmul(a[j-irow],x[j]),y[irow]);
	}
}

void runav(int n,int len,float *a,float *b)
/******************************************************************************
compute a boxcar running average filter
*******************************************************************************
int n   	number of samples in a[] and b[]
int len 	length of running average in samples
float a[n]	input array
float b[n]	output array
*******************************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
******************************************************************************/
{
	float sum=0.;
	int j,lenh=len/2;
	if(len<=1) {
		for(j=0;j<n;j++) b[j]=a[j];
		return;
	}
	for(j=0;j<MIN(len,n);j++) sum+=a[j];
	for(j=0;j<MIN(lenh,n);j++) b[j]=sum;
	for(j=lenh;j<n-lenh;j++) {
		sum=sum+a[j+lenh]-a[j-lenh];
		b[j]=sum;
	}
	for(j=MAX(0,n-lenh);j<n;j++) b[j]=sum;
	for(j=0;j<n;j++) b[j]/=len;
	return;
}

static void taupmute(int ip,int ipa,int ipb,int nt, int ltap, float *rt)
/******************************************************************************
do simple tau-p mute to elliminate multiples
*******************************************************************************
Function parameters:

int ip		current ray parameter index
int ipa		max ray parameter primary  pick at maximum time
int ipb		max ray parmater primary pick at minimum time
int nt		number of time samples
int ltap	length of mute taper in samples
float rt[nt]	tau-p data for all tau values

*******************************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
******************************************************************************/

{
	int j,k;
	float w;
	if(ip<=ipa) return;
	if(ip>=ipb) {
		for(k=0;k<nt;k++) rt[k]=0;
		return;
	}
	w=MAX(ipb-ipa,1);
	w=(ipb-ip)/w;
	j=w*nt;
	for(k=0;k<j;k++) rt[k]=0.;
	for(k=j;k<MIN(nt,j+ltap);k++) rt[k]*=(k-j)/ltap;
}

/****************************Self Documentation**********************/
/*********************************************************************
SMOOTH - Functions to compute smoothing of 1-D or 2-D input data

dlsq_smoothing		perform 1 or 2-D smoothing of a 2_D dataset
			via damped least squares. The user specifies
			the degree of smoothing required and the program
			outputs an rms error function to help decide if the
			degree of smoothing was right 

SG_smoothing_filter	computes a 1-D smmothing filter via Savitzky-Golay
			least squares. This filter is then convolved with 
			the data to effect the smoothing. A 2-D array can be
			smoothed in both directions with two passes through
			this function 

rwa_smoothing_filter	computes 1-D smoothing filter via running window average
			The window can be rectangular or triangular (weighted).
			This filter will then be convolved with the data.
			A 2-D array can be smoothed first in one direction and 
			then n the other with two passes through the function.

**************************************************************************
Function Prototypes:
void dlsq_smoothing (int nt, int nx, int ift, int ilt, int ifx, int ilx, 
	float r1, float r2, float rw, float **traces);

void SG_smoothing_filter(int np, int nl, int nr, int ld, int m, float *filter);

void rwa_smoothing_filter (int flag, int nl, int nr, float *filter);

void gaussian2d_smoothing (int nx, int nt, int nsx, int nst, float **data);

void gaussian1d_smoothing (int ns, int nsr, float *data);

void smooth_histogram (int nintlh, float *pdf);

**************************************************************************
dlsq_smoothing:
Input:
nt		number of samples in vertical (time) axis
nx		number of samples in horizontal axis (traces)
ift		index of upper left corner of data window to smooth
ilt		index of lower left corner of data window to smooth
ifx		index of upper right corner of data window to smooth
ilx		index of lower right corner of data window to smooth
r1		smoothing parameter in first dimension, usually between 1&20
r2		smoothing parameter in second dimension, usually between 1&20
rw		smoothing parameter of window function. If zero, the window
		will have sharp edges
traces		2-D array of data to smooth

Output:
traces		2-D array of smoothed data

Notes:
Larger r1 and r2 result in smoother data. Recommended ranges are from 1 to 20.

The program outputs a file called err which gives the rms error between the
input and the smoothed data as a function of the first dimension (time or
depth). For most applications, if this error is between 0.1 and 0.01 the 
smoothing parameters are O.K, otherwise, try changing them.

The smoothing can be done in a window of data rather than in the whole data
by specifying the index coordinates of the window. If smoothing of the whole
data is desired, ifx=0, ilx=nx, ift=0, ilt=nt.

If smoothing of only one trace is desired, ifx=0, ilx=1, ift=0, ilt=nt.

Smoothing of the window boundaries (blurring the edges of the window) can be 
done with a rw different than zero, otherwise the edges will be sharp.	

Credits:
Adapted by Gabriel Alvarez (1995) from the program smooth2.c of the CWP library 
	written by Zhenyue Liu (1992)

***************************************************************************

SG_smoothing_filter:
Input:
np		number of points in output filter (np>=nl+nr+1)
nl		number of left (past) data points used
nr		number of right (future) data points used
ld		order of desired derivative (=0 for smoothed function)
m		order of smoothing polynomial (normally 2 or 4)

Output parameters:
filter		vector of m-points filter coefficients to be convolved 
		with the data to be smoothed

Notes:
This filter is based on the assumption that the underlying function can be
well-fitted by a polynomial. When this is the case, the results are pretty
good. 
 
The filter is particularly good to smooth data that contains narrow peaks,
since it tends to honor them. If the peaks are too narrow with respect to the
filter width, however, some attenuation of the peaks occurs. Higher order 
(higher m) filters tend to perform better with narrower peaks at the expense of
the degree of smoothing of broader features. In general, the best results are
obtained when the full width (nl+nr+1) of the 4-degree filter is between 1 and
2 times the FWHM (full width at half of maximum) of the features that we
desire to smooth in the data.

Wider filters produce greater smoothing effect than narrower ones for filters
of a given order.

To within the roundoff error, the filter coefficients should add to one so that
the area under the curve is preserved after the smoothing. The sign of the 
samples is not preserved in general.

In order to compute filtered numerical derivatives (and not just to smooth 
the data), the parameter ld should be given the value of the desired
derivative (everything else is the same). 
	
A typical call to the convolution subroutine to apply the filter will be:
conv (nl+nr+1,-nl,filter,nd,0,data,nd,0,result);  where data[nd] is the input
data to smooth and result[nd] is the smoothed data

References:
Press, Teukolsky, Vettering, Flannery, Numerical Recipes in C:
		the art of scientific programming. Cambridge University
		Press. Second Edition (1992).
Ziegler, Applied Spectroscopy, Vol. 35, pp. 88-92.
Bromba and Ziegler, Analytical Chemistry, Vol. 53, pp 1582-1586.
***************************************************************************
Credits:
Adapted from Numerical Recipes in C by Gabriel Alvarez (1995)

**************************************************************************** 
rwa_smoothing_filter:
Input:
flag		=1 for rectangular window. =2 for triangular (weighted) window
nl		number of left (past) data points used
nr		number of right (future) data points used

Output:
filter		array[nl+nr+1] of filter points to be convolved with the data

Notes:
The rectangular window should only be used when the data to be smoothed is
fairly smooth already.  larger windows are not recommended unless real
smoothing is desired.

The triangular window will give more weight to the points that are closer
to the one to smooth. Although this is normally desirable, the degree of
smoothing for a given filter length is much less than with the rectangular
windom.

Both of this windows preserve the are under the curve and the sign of the 
samples to be smoothed.

A typical call to the convolution subroutine to apply the filter will be:
conv (nl+nr+1,-nl,filter,nd,0,data,nd,0,result);  where data[nd] is the input
data to smooth and result[nd] is the smoothed data
************************************************************************
Credits:
Gabriel Alvarez (1995).
************************************************************************/
/*********************End of Selfdocumentation**************************/




/**********************************************************************

	Subroutine to smooth a 2-D array in both dimensions
		based on a damped least squares technique

**********************************************************************/
void dlsq_smoothing (int nt, int nx, int ift, int ilt, int ifx, int ilx, 
	float r1, float r2, float rw, float **traces)
/**********************************************************************
Input:
nt		number of samples in vertical (time) axis
nx		number of samples in horizontal axis (traces)
ift		index of upper left corner of data window to smooth
ilt		index of lower left corner of data window to smooth
ifx		index of upper right corner of data window to smooth
ilx		index of lower right corner of data window to smooth
r1		smoothing parameter in first dimension, usually between 1&20
r2		smoothing parameter in second dimension, usually between 1&20
rw		smoothing parameter of window function. If zero, the window
		will have sharp edges
traces		2-D array of data to smooth

Output:
traces		2-D array of smoothed data

Notes:
Larger r1 and r2 result in smoother data. Recommended ranges are from 1 to 20.
***************************************************************************
Credits:
Adapted by Gabriel Alvarez (1995) from the program smooth2.c written by
	Zhenyue Liu (1992)
**************************************************************************/
 
{
	int nmax;	/* maxumum between nt and nx */
	int ix, it;	/* loop counters */
	int *win;	/* 1d array defining the corners of smoothing window */
	float **input;	/* array of input data */
	float **w;	/* intermediate array */
	float *err;	/* array of error estimates as a function of x1 */
	float *d, *e;	/* input arrays for subroutine tripd */
	float *f;	/* intermediate array */
	float err0=0.0;	/* error variable */
	float rms=0.0;	/* rms value */
	float amp1,amp2;
	FILE *out1;
	
	/* scale the smoothing parameter */
	r1 = r1*r1*0.25;
	r2 = r2*r2*0.25;
	rw = rw*rw*0.25;
 
	/* allocate space */
	nmax = (nt<nx)?nx:nt;
	win = alloc1int(4);
	input = alloc2float(nt,nx);
	w = alloc2float(nt,nx);
	err = alloc1float(nmax);
	d = alloc1float(nmax);
	e = alloc1float(nmax);
	f = alloc1float(nmax);
 
	/* save the original data */
	for(ix=0; ix<nx; ++ix)
	 	for(it=0; it<nt; ++it) 
			input[ix][it]=traces[ix][it];

	/* define window to smooth */
	win[0] = ift;
	win[1] = ilt;
	win[2] = ifx;
	win[3] = ilx;

	/* define the window function */
	for(ix=0; ix<nx; ++ix)
	 	for(it=0; it<nt; ++it)
			w[ix][it] = 0;	
	for(ix=win[2]; ix<win[3]; ++ix)
	 	for(it=win[0]; it<win[1]; ++it) 
			w[ix][it] = 1;	

	/* do the smoothing making sure that the window makes sense */
	if(win[0]>0 || win[1]<nt || win[2]>0 || win[3]<nx){

		/* smooth the window function */
	 	for(it=0; it<nt; ++it){
	 		for(ix=0; ix<nx; ++ix){
				d[ix] = 1.0+2.0*rw;
				e[ix] = -rw;
				f[ix] = w[ix][it];
			}
			d[0] -= rw;
	 		d[nx-1] -= rw;
	 		tripd(d,e,f,nx);
	 		for(ix=0; ix<nx; ++ix)
				w[ix][it] = f[ix];
		}
	 	for(ix=0; ix<nx; ++ix){
	 		for(it=0; it<nt; ++it){
				d[it] = 1.0+2.0*rw;
				e[it] = -rw;
				f[it] = w[ix][it];
		}
			d[0] -= rw;
	 		d[nt-1] -= rw;
	 		tripd(d,e,f,nt);
	 		for(it=0; it<nt; ++it)
				w[ix][it] = f[it];
		}
	}

	/* solving for the smoothing data */
	for(it=0; it<nt; ++it){
	 	for(ix=0; ix<nx-1; ++ix){
			d[ix] = 1.0+r2*(w[ix][it]+w[ix+1][it]);
			e[ix] = -r2*w[ix+1][it];
			f[ix] = traces[ix][it];
		}
		d[0] -= r2*w[0][it];
		d[nx-1] = 1.0+r2*w[nx-1][it];
		f[nx-1] = traces[nx-1][it];
	 	tripd(d,e,f,nx);
	 	for(ix=0; ix<nx; ++ix) 
			traces[ix][it] = f[ix];
	}
	for(ix=0; ix<nx; ++ix){
	 	for(it=0; it<nt-2; ++it){
			d[it] = 1.0+r1*(w[ix][it+1]+w[ix][it+2]);
			e[it] = -r1*w[ix][it+2];
			f[it] = traces[ix][it+1];
		}
		f[0] += r1*w[ix][1]*traces[ix][0];
	 	d[nt-2] = 1.0+r1*w[ix][nt-1];
		f[nt-2] = traces[ix][nt-1];
	 	tripd(d,e,f,nt-1);
	 	for(it=0; it<nt-1; ++it) 
			traces[ix][it+1] = f[it];
	}

	/*calculate the RMS error of smoothed data */
		for(it=0; it<nt; ++it){
		for(ix=0; ix<nx; ++ix){
			amp1=input[ix][it];
			amp2=traces[ix][it];
			err0 += (amp1-amp2)*(amp1-amp2);
			rms += amp1*amp1;
		}
		if (rms<0.001) err[it] = 1.0;
		else err[it] = sqrt(err0/rms);
	}

	/* output error data */
	out1=fopen("error","w");
	fwrite(err,sizeof(float),nt,out1);
	fclose(out1);

	/* free allocated space */
	free2float(input);
	free2float(w);
	free1float(err);
	free1float(d);
	free1float(e);
	free1float(f);
}

/**********************************************************************

	Subroutine to compute smoothing filter coefficients via 
		Savitzky-Golay least squares fitting

***********************************************************************/
void SG_smoothing_filter (int np, int nl, int nr, int ld, int m, float *filter)
/***********************************************************************
Input Parameters:
np		number of points in output filter
nl		number of left (past) data points used
nr		number of right (future) data points used
ld		order of desired derivative (=0 for smoothed function)
m		order of smoothing polynomial (normally 2 or 4)

Output parameters:
filter		vector of m-points filter coefficients to be convolved 
		with the data to be smoothed

Notes:
This filter is based on the assumption that the underlying function can be
well-fitted by a polynomial. When this is the case, the results are pretty
good. 
 
The filter is particularly good to smooth data that contains narrow peaks,
since it tends to honor them. If the peaks are too narrow with respect to the
filter width, however, some attenuation of the peaks occurs. Higher order 
(higher m) filters tend to perform better with narrower peaks at the expense of
the degree of smoothing of broader features. In general, the best results are
obtained when the full width (nl+nr+1) of the 4-degree filter is between 1 and
2 times the FWHM (full width at half of maximum) of the features that we
desire to smooth in the data.

Wider filters produce greater smoothing effect than narrower ones for filters
of a given order.

To within the roundoff error, the filter coefficients should add to one so that
the area under the curve is preserved after the smoothing. The sign of the 
samples is not preserved in general.

In order to compute filtered numerical derivatives (and not just to smooth 
the data), the parameter ld should be given the value of the desired
derivative (everything else is the same). 
	
A typical call to the convolution subroutine to apply the filter will be:
conv (nl+nr+1,-nl,filter,nd,0,data,nd,0,result);  where data[nd] is the input
data to smooth and result[nd] is the smoothed data

References:
Press, Teukolsky, Vettering, Flannery, Numerical Recipes in C:
		the art of scientific programming. Cambridge University
		Press. Second Edition (1992).
Ziegler, Applied Spectroscopy, Vol. 35, pp. 88-92.
Bromba and Ziegler, Analytical Chemistry, Vol. 53, pp 1582-1586.
***************************************************************************
Credits:
**************************************************************************
Credits
slightly modified from Numerical Recipes in C by Gabriel Alvarez (1995)
*************************************************************************/

{
	int imj,ipj,j,k,kk,mm;
	int *index;			/* vector of indices */
	float d,fac,sum;		/* auxiliary variables */
	float **a;			/* matrix of .. */
	float *b;			/* vector of ... */

	/* defensive programming, check input */
	if (np < nl+nr+1 || nl < 0 || nr < 0 || ld > m || nl+nr < m)
		err (" error in smoothing function, check input parameters");

	/* allocate working space */
	index = alloc1int(m+1);
	a = alloc2float(m+1,m+1);
	b = alloc1float(m+1);

	/* set up normal equations of the desired least-squares fit */
	for (ipj=0; ipj<=(m << 1); ipj++) {
		sum = (ipj ? 0.0 : 1.0);
		for (k=1; k<=nr; k++)
			sum +=pow((double)k,(double)ipj);
		for (k=1; k<=nl; k++)
			sum +=pow((double)-k,(double)ipj);
		mm = MIN(ipj,2*m-ipj);
		for (imj=-mm; imj<=mm; imj+=2)
			a[(ipj+imj)/2][(ipj-imj)/2]=sum;
	}

	/* solve normal equation via LU decomposition */
	LU_decomposition(m+1, a, index, &d);

	/* initialize vector */
	for (j=0; j<=m; j++)
		b[j]=0.0;
	b[ld]=1.0;		/* right-hand-side vector is unit depending
					on what derivative we want */

	/* get one row of the inverse matrix */
	backward_substitution(m+1, a, index, b);

	/* initialize output vector */
	for (kk=0; kk<np; kk++)
		filter[kk]=0.0;

	/* compute Savitzky-Golay coefficients */
	for (k=-nl; k<=nr; k++) {
		sum = b[0];
		fac=1.0;

		/* each coefficient is the dot product of powers of an 
		integer	with the inverse matrix row */
		for (mm=0; mm<m; mm++)
			sum +=b[mm+1]*(fac *=k);	
		/*kk=((np-k) % np);  store coefficients in wrap around order*/
		kk=k+nl;		 /*store coefficients in normal order */
		filter[kk]=sum;	
	}

	/* free working space */
	free2float(a);
	free1float(b);
	free1int(index);
}
/************************************************************************
	Subroutine to compute one-dimensional smoothing filter
		via running window average. 

************************************************************************/
void rwa_smoothing_filter (int flag, int nl, int nr, float *filter)
/************************************************************************
Input:
flag		=1 for rectangular window. =2 for triangular (weighted) window
nl		number of left (past) data points used
nr		number of right (future) data points used

Output:
filter		vector[nl+nr+1] of filter points to be convolved with the data

Notes:
The rectangular window should only be used when the data to be smoothed is
fairly smooth already; larger windows are not recommended unless extreme
smoothing is desired.

The triangular window will give more weight to the points that are closer
to the one to smooth. Although this is normally desirable, the degree of
smoothing for a given filter length is much less than with the rectangular
windom.

Both of these windows preserve the are under the curve and the sign of the 
samples to be smoothed.

A typical call to the convolution subroutine to apply the filter will be:
conv (nl+nr+1,-nl,filter,nd,0,data,nd,0,result);  where data[nd] is the input
data to smooth and result[nd] is the smoothed data
************************************************************************
Credits:
Gabriel Alvarez (1995).
************************************************************************/
{
	int i;				/* loop counter */
	int np=nl+nr+1;			/* number of filter points */

	if (flag==1) {
		float scale=1.0/np;	/* scale for rectangular window */

		for (i=0; i<np; i++) filter[i]=scale;

	} else if (flag==2) {
		float scale=0.0;	/* scale for triangular window */
		
		for (i=-nl; i<0; i++) filter[i+nl]=1+(float)i/nl;
		for (i=1; i<nr; i++) filter[i+nl]=1-(float)i/nr;
		filter[nl]=1.0;
	
		/* normalize */
		for (i=0;i<np;i++) scale+=filter[i];
		for (i=0;i<np;i++) filter[i] /=scale;
	} else err("error in rwa_smoothing filter, flag should 1 or 2\n");
}

/******************************************************************************

		Subroutine to apply 2-D gaussian smoothing
	
******************************************************************************/	
void gaussian2d_smoothing (int nx, int nt, int nsx, int nst, float **data)
/******************************************************************************
Input:
nx		number of horizontal samples (traces)
nt		number of vertical (time) samples 
nsx		number of samples for horizontal smoothing (0 for no smoothing)
nst		number of samples for vertical smoothing (0 for no smoothing)
data		2-D array[nx][nt] of data to be smoothed

Output:
data		2-D array[nx][nt] of smoothed data
******************************************************************************/
{
	int ix,it;			/* loop counters */	
	float **temp;			/* temporary (scratch) array */
	FILE *out1;	
	
	/* allocate temporary space */
	temp=alloc2float(nx,nt);

	/* smooth over time */
	if (nst>0 && nt>1) {
		
		/* apply 1-D gaussian smoothing over time */
		for (ix=0; ix<nx; ix++)
			 gaussian1d_smoothing (nt, nst, data[ix]);
	}

	/*out1=fopen ("data/Stoz49","w");
	fwrite (data[49],sizeof(float),nt,out1);
	fclose(out1);*/

	/* if parameters are not reasonable, return */
	if (nsx<=0 || nx<=1) return;
	
	/* smooth over traces */
	for (it=0; it<nt; it++) {

		/* copy time smoothed data to temporary array */
		for (ix=0; ix<nx; ix++) temp[it][ix]=data[ix][it];

		/*if (it==300) {
			out1=fopen ("data/xoz300","w");
			fwrite(temp[300],sizeof(float),nx,out1);
			fclose(out1);
		}*/
	
		/* apply 1-D gaussian smoothing over traces */
		gaussian1d_smoothing (nx, nsx, temp[it]);

		/*if (it==300) {
			out1=fopen ("data/Sxoz300","w");
			fwrite(temp[300],sizeof(float),nx,out1);
			fclose(out1);
		}*/

		/* copy smoothed data back to output array */
		for (ix=0; ix<nx; ix++) data[ix][it]=temp[it][ix];
	}
	
	/* free allocated space */
	free2float(temp);
}

/******************************************************************************

	Subroutine to apply a one-dimensional gaussian smoothing 

******************************************************************************/
void gaussian1d_smoothing (int ns, int nsr, float *data)
/******************************************************************************
Input:
ns		number of samples in the input data 
nsr		width (in samples) of the gaussian for which 
		amplitude > 0.5*max amplitude
data		1-D array[ns] of data to smooth

Output:
data		1-D array[ns] of smoothed data
******************************************************************************/
{
	int is;				/* loop counter */
	float sum=0.0;
	float fcut;
	float r;
	float fcutr=1.0/nsr;
	static int n;
	static int mean;
	static float fcutl;
	static float s[401];		/* smoothing filter array */
	float *temp;			/* temporary array */

	/* allocate space */
	temp=alloc1float(ns);

	/* save input fcut */
	fcut=fcutr;

	/* don't smooth if nsr equal to zero */
	if (nsr==0 || ns<=1) return;

	/* if halfwidth more than 100 samples, truncate */
	if (nsr>100) fcut=1.0/100;

	/* initialize smoothing function if not the same as the last one used */
	if (fcut !=fcutl) {
		fcutl=fcut;

		/* set span of 3, at width of 1.5*exp(-PI*1.5**2)=1/1174 */
		n=3.0/fcut+0.5;
		n=2*n/2+1;		/* make it odd for symmetry */

		/* mean is the index of the zero in the smoothing wavelet */
		mean=n/2;

		/* s(n) is the smoothing gaussian */
		for (is=1; is<=n; is++) {
			r=is-mean-1;
			r=-r*r*fcut*fcut*PI;
			s[is-1]=exp(r);
		}
			
		/* normalize to unit area, will preserve DC frequency at full 
		amplitude. Frequency at fcut will be half amplitude */
		for (is=0; is<n; is++) sum +=s[is];
		for (is=0; is<n; is++) s[is] /=sum;
	}

	/* convolve by gaussian into buffer */
	if (1.01/fcutr>(float)ns) {

		/* replace drastic smoothing by averaging */
		sum=0.0;
		for (is=0; is<ns; is++) sum +=data[is];
		sum /=ns;
		for (is=0; is<ns; is++) data[is]=sum;	

	} else {

		/* convolve with gaussian */
		conv (n, -mean, s, ns, -mean, data, ns, -mean, temp);

		/* copy filtered data back to output array */
		for (is=0; is<ns; is++) data[is]=temp[is];
	}

	/* free allocated space */
	free1float(temp);
}

/******************************************************************************

	Subroutine to apply gaussian smoothing to a histogram

******************************************************************************/
void smooth_histogram (int nintlh, float *pdf)
/******************************************************************************
Input:
nintlh		number of histogram bins
pdf		1-D array[nintlh] of input histogram to be smoothed

Output:
pdf		1-D array[nintlh] of smoothed histogram
******************************************************************************/
{
	int i;			/* loop counter */
	int ng=11;		/* number of samples in smoothing filter */
	int mg=6;		/* index of sample with zero lag */
	float rv=1.0;		/* ?? */
	float r;		/* auxiliary variable */
	float sum=0.0;		/* auxiliary variable */
	float *filter;		/* gaussian filter */
	float *spdf;		/* smoothed histogram */

	/* allocate working space */
	filter=alloc1float(ng);
	spdf=alloc1float(nintlh);

	/* compute gaussian filter */	
	for (i=1; i<=ng; i++) {
	
		r=i-mg;
		r=-r*r/rv/rv*PI;
		filter[i-1]=exp(r);	
	}

	/* apply filter */
	conv (ng, -mg+1, filter, nintlh, 0, pdf, nintlh, 0, spdf);

	/* normalize output histogram */
	for (i=0; i<nintlh; i++) sum +=spdf[i]; 
	for (i=0; i<nintlh; i++) pdf[i]=spdf[i]/sum; 

	/* free allocated space */
	free1float(filter);
	free1float(spdf);
@
