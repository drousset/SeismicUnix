head	1.21;
access;
symbols;
locks
	john:1.21; strict;
comment	@ * @;


1.21
date	2011.11.17.22.40.28;	author john;	state Exp;
branches;
next	1.20;

1.20
date	2011.11.12.00.40.42;	author john;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.07.22.58.42;	author john;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.22.19.29.27;	author john;	state Exp;
branches;
next	1.16;

1.16
date	96.09.13.21.49.05;	author john;	state Exp;
branches;
next	1.15;

1.15
date	96.02.21.23.39.07;	author jkc;	state Exp;
branches;
next	1.14;

1.14
date	96.02.21.22.15.52;	author jkc;	state Exp;
branches;
next	1.13;

1.13
date	96.02.20.23.04.59;	author jkc;	state Exp;
branches;
next	1.12;

1.12
date	96.02.07.15.27.47;	author jkc;	state Exp;
branches;
next	1.11;

1.11
date	95.09.27.20.24.24;	author john;	state Exp;
branches;
next	1.10;

1.10
date	95.07.11.18.36.56;	author jkc;	state Exp;
branches;
next	1.9;

1.9
date	95.03.17.10.22.48;	author john;	state Exp;
branches;
next	1.8;

1.8
date	94.09.06.10.21.33;	author jkc;	state Exp;
branches;
next	1.7;

1.7
date	94.08.25.15.01.20;	author jkc;	state Exp;
branches;
next	1.6;

1.6
date	94.03.25.09.56.16;	author john;	state Exp;
branches;
next	1.5;

1.5
date	94.03.01.12.34.04;	author jkc;	state Exp;
branches;
next	1.4;

1.4
date	94.02.08.10.51.12;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	93.11.24.16.22.15;	author john;	state Exp;
branches;
next	1.2;

1.2
date	93.06.16.15.35.57;	author john;	state Exp;
branches;
next	1.1;

1.1
date	93.06.07.14.35.01;	author john;	state Exp;
branches;
next	;


desc
@Susynvxz---- Zhenuye Liu's upwind finite difference based Kirch-WKBJ
@


1.21
log
@added checkpars();
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SUSYNVXZ: $Revision: 1.19 $ ; $Date: 2006/11/07 22:58:42 $	*/

#include "su.h" 
#include "segy.h" 

/*********************** self documentation **********************/
char *sdoc[] = {
" 									",
" SUSYNVXZ - SYNthetic seismograms of common offset V(X,Z) media via	",
" 		Kirchhoff-style modeling				",
" 									",
" susynvxz >outfile [optional parameters]				",
" 									",
" Required Parameters:							",
" <vfile		file containing velocities v[nx][nz]		",
" nx=			number of x samples (2nd dimension)		",
" nz=			number of z samples (1st dimension)		",
" Optional Parameters:							",
" nxb=nx		band centered at midpoint			",
" nxd=1			skipped number of midponits			",
" dx=100		x sampling interval (m)				",
" fx=0.0		first x sample					",
" dz=100		z sampling interval (m)				",
" nt=101		number of time samples				",
" dt=0.04		time sampling interval (sec)			",
" ft=0.0		first time (sec)				",
" nxo=1		 	number of offsets				",
" dxo=50		offset sampling interval (m)			",
" fxo=0.0		first offset (m)				",
" nxm=101		number of midpoints				",
" dxm=50		midpoint sampling interval (m)			",
" fxm=0.0		first midpoint (m)				",
" fpeak=0.2/dt		peak frequency of symmetric Ricker wavelet (Hz)	",
" ref=\"1:1,2;4,2\"	reflector(s):  \"amplitude:x1,z1;x2,z2;x3,z3;...\"",
" smooth=0		=1 for smooth (piecewise cubic spline) reflectors",
" ls=0			=1 for line source; default is point source	",
" tmin=10.0*dt		minimum time of interest (sec)			",
" ndpfz=5		number of diffractors per Fresnel zone		",
" verbose=0		=1 to print some useful information		",
" 									",
" Notes:								",
" This algorithm is based on formula (58) in Geo. Pros. 34, 686-703,	",
" by N. Bleistein.							",
" 									",
" Offsets are signed - may be positive or negative.			", 
" Traveltime and amplitude are calculated by finite differences which	",
" is done only in part of midpoints; in the skiped midpoint, interpolation",
" is used to calculate traveltime and amplitude.			", 
"									",
" More than one ref (reflector) may be specified.			",
" Note that reflectors are encoded as quoted strings, with an optional	",
" reflector amplitude: preceding the x,z coordinates of each reflector.	",
" Default amplitude is 1.0 if amplitude: part of the string is omitted.	",
"									",
NULL};

/*
 *   CWP:  Zhenyue Liu, 07/20/92
 *	Many subroutines borrowed from Dave Hale's program: SUSYNLV
 *
 * Trace header fields set: trid, counit, ns, dt, delrt,
 *				tracl. tracr,
 *				cdp, cdpt, d2, f2, offset, sx, gx
 */
/**************** end self doc ***********************************/

/* these structures are defined in par.h -- this is documentation only
 *
 * typedef struct ReflectorSegmentStruct {
 *	float x;	( x coordinate of segment midpoint )
 *	float z;	( z coordinate of segment midpoint )
 *	float s;	( x component of unit-normal-vector )
 *	float c;	( z component of unit-normal-vector )
 * } ReflectorSegment;
 * typedef struct ReflectorStruct {
 *	int ns;			( number of reflector segments )
 *	float ds;		( segment length )
 *	float a;		( amplitude of reflector )
 *	ReflectorSegment *rs;	( array[ns] of reflector segments )
 * } Reflector;
 * typedef struct WaveletStruct {
 *	int lw;			( length of wavelet )
 *	int iw;			( index of first wavelet sample )
 *	float *wv;		( wavelet sample values )
 * } Wavelet;
 *
 */

/* parameters for half-derivative filter */
#define LHD 20
#define NHD 1+2*LHD

/* prototypes */
static void makeone (float **ts, float **as, float **sgs, float **tg, 
	float **ag, float **sgg, float ex, float ez, float dx,  
	float dz, float fx, float vs0, float vg0, int ls, Wavelet *w,
	int nr, Reflector *r, int nt, float dt, float ft, float *trace);

/* segy trace */
segy tr;

int
main (int argc, char **argv)
{
	int 	nr,ir,ls,smooth,ndpfz,ns,ixo,ixm,nxo,nxm,nt,
		nx,nz,nxb,nxd,ixd,i,ix,iz,nx1,nx0,nxd1,
		verbose,tracl,
		*nxz;
	float   tmin,temp,temp1,
		dsmax,fpeak,dx,dz,fx,ex,fx1,ex1,
		dxm,dxo,dt,fxm,fxo,ft,xo,xm,vs0,vg0,
		xs,xg,ez,
		*ar,**xr,**zr,
		**vold,**ts,**as,**sgs,**tg,**ag,**sgg,**bas,**bag,
		**v,**ts1=NULL,**as1=NULL,**sgs1=NULL,
		**tg1=NULL,**ag1=NULL,**sgg1=NULL;
	FILE *vfp=stdin;
	Reflector *r;
	Wavelet *w;

	/* hook up getpar to handle the parameters */
	initargs(argc,argv);
	requestdoc(0);

	/* get required parameters */
	if (!getparint("nx",&nx)) err("must specify nx!\n");
	if (!getparint("nz",&nz)) err("must specify nz!\n");
	
	/* get optional parameters */
	if (!getparint("nxb",&nxb)) nxb = nx;
	if (!getparint("nxd",&nxd)) nxd = 1;
	if (!getparfloat("dx",&dx)) dx = 100;
	if (!getparfloat("fx",&fx)) fx = 0.0;
	if (!getparfloat("dz",&dz)) dz = 100;
	if (!getparint("nt",&nt)) nt = 101; CHECK_NT("nt",nt);
	if (!getparfloat("dt",&dt)) dt = 0.04;
	if (!getparfloat("ft",&ft)) ft = 0.0;
	if (!getparint("nxo",&nxo)) nxo = 1;
	if (!getparfloat("dxo",&dxo)) dxo = 50;
	if (!getparfloat("fxo",&fxo)) fxo = 0.0;
	if (!getparint("nxm",&nxm)) nxm = 101;
	if (!getparfloat("dxm",&dxm)) dxm = 50;
	if (!getparfloat("fxm",&fxm)) fxm = 0.0;
	if (!getparfloat("fpeak",&fpeak)) fpeak = 0.2/dt;
	if (!getparint("ls",&ls)) ls = 0;
	if (!getparfloat("tmin",&tmin)) tmin = 10.0*dt;
	if (!getparint("ndpfz",&ndpfz)) ndpfz = 5;
	if (!getparint("smooth",&smooth)) smooth = 0;
	if (!getparint("verbose",&verbose)) verbose = 0;
	
	/* check the ranges of shots and receivers */
	ex = fx+(nx-1)*dx;
	ez = (nz-1)*dz;
 	for (ixm=0; ixm<nxm; ++ixm) 
		for (ixo=0; ixo<nxo; ++ixo) {
			/* compute source and receiver coordinates */
			xs = fxm+ixm*dxm-0.5*(fxo+ixo*dxo);
			xg = xs+fxo+ixo*dxo;
			if (fx>xs || ex<xs || fx>xg || ex<xg) 
		err("shot or receiver lie outside of specified (x,z) grid\n");
	} 
		
	
	decodeReflectors(&nr,&ar,&nxz,&xr,&zr);
        checkpars();

	if (!smooth) breakReflectors(&nr,&ar,&nxz,&xr,&zr);

	/* allocate space */
	vold = ealloc2float(nz,nx);
	/* read velocities */
	if(fread(vold[0],sizeof(float),nx*nz,vfp)!=nx*nz)
		err("cannot read %d velocities from file %s",nx*nz,vfp);
	/* determine maximum reflector segment length */
	tmin = MAX(tmin,MAX(ft,dt));
	dsmax = vold[0][0]/(2*ndpfz)*sqrt(tmin/fpeak);
 	
	/* make reflectors */
	makeref(dsmax,nr,ar,nxz,xr,zr,&r);

	/* count reflector segments */
	for (ir=0,ns=0; ir<nr; ++ir)
		ns += r[ir].ns;

	/* make wavelet */
	makericker(fpeak,dt,&w);
	
	/* if requested, print information */
	if (verbose) {
		warn("\nSUSYNVXZ:");
		warn("Total number of small reflecting segments is %d.\n",ns);
	}
	
	/* set constant segy trace header parameters */
	memset( (void *) &tr, 0, sizeof(segy));
	tr.trid = 1;
	tr.counit = 1;
	tr.ns = nt;
	tr.dt = 1.0e6*dt;
	tr.delrt = 1.0e3*ft;
	
	/* allocate space */
	nx1 = 1+2*nxb;
	ts = ealloc2float(nz,nx1);
	as = ealloc2float(nz,nx1);
	sgs = ealloc2float(nz,nx1);
	tg = ealloc2float(nz,nx1);
	ag = ealloc2float(nz,nx1);
	sgg = ealloc2float(nz,nx1);
	v = ealloc2float(nz,nx1);
	bas = ealloc2float(nz,nx1);
	bag = ealloc2float(nz,nx1);
	if(nxd>1) {
		/* allocate space for interpolation */
		ts1 = ealloc2float(nz,nx1);
		as1 = ealloc2float(nz,nx1);
		sgs1 = ealloc2float(nz,nx1);
		tg1 = ealloc2float(nz,nx1);
		ag1 = ealloc2float(nz,nx1);
		sgg1 = ealloc2float(nz,nx1);
  	}
		

	/* loop over offsets and midpoints */
	for (ixo=0, tracl=0; ixo<nxo; ++ixo){
	    xo = fxo+ixo*dxo;
	    if(ABS(xo)>nxb*dx) err("\t band NXB is too small!\n");
	    nxd1 = nxd;
	    for (ixm=0; ixm<nxm; ixm +=nxd1){
		xm = fxm+ixm*dxm;
   		xs = xm-0.5*xo;
		xg = xs+xo;
		/* set range for traveltimes' calculation */
		fx1 = xm-nxb*dx;
		ex1 = MIN(ex+(nxd1-1)*dxm,xm+nxb*dx);
		nx1 = 1+(ex1-fx1)/dx;	
		nx0 = (fx1-fx)/dx;
		temp = (fx1-fx)/dx-nx0;
		/* transpose velocity such that the first row is at fx1 */
		for(ix=0;ix<nx1;++ix)
		    for(iz=0;iz<nz;++iz){
		    	if(ix<-nx0) 
			   	v[ix][iz] = vold[0][iz];
		    	else if(ix+nx0>nx-2) 
				v[ix][iz]=vold[nx-1][iz];
			else
				v[ix][iz] = vold[ix+nx0][iz]*(1.0-temp)
					+temp*vold[ix+nx0+1][iz];
		    }
			
		if(ixm==0 || nxd1==1){
		/* No interpolation */
	
			/* compute traveltimes, propagation angles, sigmas 
	  		 from shot and receiver respectively	*/
			eiktam(xs,0.,nz,dz,0.,nx1,dx,fx1,v,ts,as,sgs,bas);
			eiktam(xg,0.,nz,dz,0.,nx1,dx,fx1,v,tg,ag,sgg,bag);
			ixd = NINT((xs-fx)/dx);
			vs0 = vold[ixd][0];
			ixd = NINT((xg-fx)/dx);
			vg0 = vold[ixd][0];
				
			/* make one trace */
			ex1 = MIN(ex,xm+nxb*dx);
			makeone(ts,as,sgs,tg,ag,sgg,ex1,ez,dx,dz,fx1,vs0,vg0,
				ls,w,nr,r,nt,dt,ft,tr.data);
			/* set segy trace header parameters */
			tr.tracl = tr.tracr = ++tracl;
			tr.cdp = 1+ixm;
			tr.cdpt = 1+ixo;
			tr.offset = NINT(xo);
			tr.sx = NINT(xs);
			tr.gx = NINT(xg);
			/* write trace */
			puttr(&tr);
		}
		else {
			/* Linear interpolation */
			
			eiktam(xs,0,nz,dz,0,nx1,dx,fx1,v,ts1,as1,sgs1,bas);
			eiktam(xg,0,nz,dz,0,nx1,dx,fx1,v,tg1,ag1,sgg1,bag);
			ixd = NINT((xs-fx)/dx);
			vs0 = vold[ixd][0];
			ixd = NINT((xg-fx)/dx);
			vg0 = vold[ixd][0];
			
		    	xm -= nxd1*dxm;
		    for(i=1; i<=nxd1; ++i) {
		    	xm += dxm;
			xs = xm-0.5*xo;
			xg = xs+xo;
			fx1 = xm-nxb*dx;	
			ex1 = MIN(ex+(nxd1-1)*dxm,xm+nxb*dx);
			nx1 = 1+(ex1-fx1)/dx;	
			temp = nxd1-i;
			temp1 = 1.0/(nxd1-i+1);
			for(ix=0;ix<nx1;++ix)
			    for(iz=0;iz<nz;++iz){
			    if(i==nxd1){
			   	ts[ix][iz] = ts1[ix][iz];
			   	tg[ix][iz] = tg1[ix][iz];
			   	sgs[ix][iz] = sgs1[ix][iz];
			   	ag[ix][iz] = ag1[ix][iz];
			   	sgg[ix][iz] = sgg1[ix][iz];
			   	as[ix][iz] = as1[ix][iz];
				}
			    else{
			   	ts[ix][iz] = (temp*ts[ix][iz]
					+ts1[ix][iz])*temp1;
			   	tg[ix][iz] = (temp*tg[ix][iz]
					+tg1[ix][iz])*temp1;
			    	as[ix][iz] = (temp*as[ix][iz]
					+as1[ix][iz])*temp1;
			   	sgs[ix][iz] = (temp*sgs[ix][iz]
					+sgs1[ix][iz])*temp1;
			   	ag[ix][iz] = (temp*ag[ix][iz]
					+ag1[ix][iz])*temp1;
			   	sgg[ix][iz] = (temp*sgg[ix][iz]
					+sgg1[ix][iz])*temp1;
				}
			}
				
			/* make one trace */
			ex1 = MIN(ex,xm+nxb*dx);
			makeone(ts,as,sgs,tg,ag,sgg,ex1,ez,dx,dz,fx1,vs0,vg0,
				ls,w,nr,r,nt,dt,ft,tr.data);
			/* set segy trace header parameters */
			tr.tracl = tr.tracr = ++tracl;
			tr.cdp = 1+ixm-nxd1+i;
			tr.cdpt = 1+ixo;
			tr.offset = NINT(xo);
			tr.d2=dxm;
			tr.f2=fxm;
			tr.sx = NINT(xs);
			tr.gx = NINT(xg);
			/* write trace */
			puttr(&tr);
		    }
		}
		    /* set skip parameter */
		    if(ixm<nxm-1 && ixm>nxm-1-nxd1) nxd1 = nxm-1-ixm;

	    }
	    warn("\t finish offset %f\n",xo);
	}

	free2float(vold);
	free2float(ts);
	free2float(bas);
	free2float(sgs);
	free2float(as);
	free2float(v);
	free2float(tg);
	free2float(bag);
	free2float(sgg);
	free2float(ag);
	if(nxd>1) {
		free2float(ts1);
		free2float(as1);
		free2float(sgs1);
		free2float(tg1);
		free2float(ag1);
		free2float(sgg1);
  	}
	return(CWP_Exit());
}

static void makeone (float **ts, float **as, float **sgs, 
	float **tg, float **ag, float **sgg, float ex, float ez, float dx, 
	float dz, float fx, float vs0, float vg0, int ls, Wavelet *w,
	int nr, Reflector *r, int nt, float dt, float ft, float *trace)
/*****************************************************************************
Make one synthetic seismogram 
******************************************************************************
Input:
**v		array[nx][nz] containing velocities 
nz		number of z samples
dz		z sampling interval
nx		number of x samples
dx		x sampling interval
fx		first x sample
ls		=1 for line source amplitudes; =0 for point source
w		wavelet to convolve with trace
xs		x coordinate of source
xg		x coordinate of receiver group
nr		number of reflectors
r		array[nr] of reflectors
nt		number of time samples
dt		time sampling interval
ft		first time sample

Output:
trace		array[nt] containing synthetic seismogram
*****************************************************************************/
{
	int it,ir,is,ns,ix,iz;
	float ar,ds,xd,zd,cd,sd,xi,zi,ci,cr,time,amp,sx,sz,
		tsd,asd,sgsd,tgd,agd,sggd,
		*temp;
	ReflectorSegment *rs;
	int lhd=LHD,nhd=NHD;
	static float hd[NHD];
	static int madehd=0;

	/* if half-derivative filter not yet made, make it */
	if (!madehd) {
		mkhdiff(dt,lhd,hd);
		madehd = 1;
	}
 
	/* zero trace */
	for (it=0; it<nt; ++it)
		trace[it] = 0.0;
	
	/* loop over reflectors */
	for (ir=0; ir<nr; ++ir) {

		/* amplitude, number of segments, segment length */
		ar = r[ir].a;
		ns = r[ir].ns;
		ds = r[ir].ds;
		rs = r[ir].rs;
	
		/* loop over diffracting segments */
		for (is=0; is<ns; ++is) {
		
			/* diffractor midpoint, unit-normal, and length */
			xd = rs[is].x;
			zd = rs[is].z;
			cd = rs[is].c;
			sd = rs[is].s;
			
			/* check range of reflector */
			if(xd<fx || xd>=ex || zd>=ez)
				continue;
			/* determine sample indices */
			xi = (xd-fx)/dx;
			ix = xi;
			zi = zd/dz;
			iz = zi;
			/* bilinear interpolation */
			sx = xi-ix;
			sz = zi-iz;
			tsd = (1.0-sz)*((1.0-sx)*ts[ix][iz] + 
						sx*ts[ix+1][iz]) +
					sz*((1.0-sx)*ts[ix][iz+1] +
						sx*ts[ix+1][iz+1]);
			asd = (1.0-sz)*((1.0-sx)*as[ix][iz] + 
						sx*as[ix+1][iz]) +
					sz*((1.0-sx)*as[ix][iz+1] +
						sx*as[ix+1][iz+1]);
			sgsd = (1.0-sz)*((1.0-sx)*sgs[ix][iz] + 
						sx*sgs[ix+1][iz]) +
					sz*((1.0-sx)*sgs[ix][iz+1] +
						sx*sgs[ix+1][iz+1]);
			tgd = (1.0-sz)*((1.0-sx)*tg[ix][iz] + 
						sx*tg[ix+1][iz]) +
					sz*((1.0-sx)*tg[ix][iz+1] +
						sx*tg[ix+1][iz+1]);
			agd = (1.0-sz)*((1.0-sx)*ag[ix][iz] + 
						sx*ag[ix+1][iz]) +
					sz*((1.0-sx)*ag[ix][iz+1] +
						sx*ag[ix+1][iz+1]);
			sggd = (1.0-sz)*((1.0-sx)*sgg[ix][iz] + 
						sx*sgg[ix+1][iz]) +
					sz*((1.0-sx)*sgg[ix][iz+1] +
						sx*sgg[ix+1][iz+1]);
			
			/* cosines of incidence and reflection angles */
			ci = cd*cos(asd)+sd*sin(asd);
			cr = cd*cos(agd)+sd*sin(agd);

			/* two-way time and amplitude */
			time = tsd+tgd;

			if (ls)
			     amp = sqrt(vs0*vg0/(sgsd*sggd));
			else
			     amp = sqrt(vs0*vg0/(sgsd*sggd*(sgsd+sggd)));
					   
			amp *= ABS(ci+cr)*ar*ds;
		
			/* add sinc wavelet to trace */
			addsinc(time,amp,nt,dt,ft,trace);
		}
	}
	
	/* allocate workspace */
	temp = ealloc1float(nt);
	
	/* apply half-derivative filter to trace */
	conv(nhd,-lhd,hd,nt,0,trace,nt,0,temp);

	/* convolve wavelet with trace */
	conv(w->lw,w->iw,w->wv,nt,0,temp,nt,0,trace);
	
	/* free workspace */
	free1float(temp);
}
@


1.20
log
@copyright
@
text
@d168 2
@


1.19
log
@changed    memset( .., (int) '\0',...) to memset( .., 0,..) as per suggestion of Marion Zhu and Reg Beardsley
@
text
@d1 4
a4 1
/* SUSYNVXZ: $Revision: 1.18 $ ; $Date: 2003/06/09 16:17:07 $	*/
@


1.18
log
@9 June 2003
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.17 $ ; $Date: 2000/09/22 19:29:27 $	*/
d193 1
a193 1
	memset( (void *) &tr, (int) '\0', sizeof(tr));
@


1.17
log
@cleaned up
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.16 $ ; $Date: 1996/09/13 21:49:05 $	*/
d363 1
a363 1
	return EXIT_SUCCESS;
@


1.16
log
@silenced -Wall messages
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.15 $ ; $Date: 1996/02/21 23:39:07 $	*/
a97 14
static void eikpex (int na, float da, float r, float dr, 
	float sc[], float uc[], float wc[], float tc[],
	float sn[], float un[], float wn[], float tn[]);
static void sigma (int na, float da, float r, float dr, 
	float uc[], float wc[], float sc[],
	float un[], float wn[], float sn[]);
static void beta (int na, float da, float r, float dr, 
	float uc[], float wc[], float bc[],
	float un[], float wn[], float bn[]);
static void tripp (int n, float *d, float *e, float *c, float *b);
static void eiktam (float xs, float zs, 
	int nz, float dz, float fz, int nx, float dx, float fx, float **vel,
	float **time, float **angle, float **sig, float **beta);

a497 502


#define TINY 1.0e-3	/* avoid divide by zero */
#define CFL 0.98	/* Courant/Friedrichs/Lewy stability factor */

static void eikpex (int na, float da, float r, float dr, 
	float sc[], float uc[], float wc[], float tc[],
	float sn[], float un[], float wn[], float tn[])
/*****************************************************************************
Eikonal equation extrapolation of times and derivatives in polar coordinates
******************************************************************************
Input:
na		number of a samples
da		a sampling interval
r		current radial distance r
dr		radial distance to extrapolate
sc		array[na] of slownesses at current r
uc		array[na] of dt/dr at current r
wc		array[na] of dt/da at current r
tc		array[na] of times t at current r
sn		array[na] of slownesses at next r

Output:
un		array[na] of dt/dr at next r (may be equivalenced to uc)
wn		array[na] of dt/da at next r (may be equivalenced to wc)
tn		array[na] of times t at next r (may be equivalenced to tc)
******************************************************************************
Notes:
If na*da==2*PI, then the angular coordinate is wrapped around (periodic). 

This function implements the finite-difference method described by Bill
Symes (Rice University) and Jos van Trier (Stanford University) in a
(1990) preprint of a paper submitted to Geophysics.
******************************************************************************
Author:  Dave Hale, Colorado School of Mines, 07/16/90
******************************************************************************/
{
	int i,wrap;
	float drleft,drorig,frac,cmax,umaxl,uminr,uminm,umaxm,
		uu,unew,uold,ueol,ueor,wor,or,*wtemp,*s;
	
	/* allocate workspace */
	wtemp = alloc1float(na);
	s = alloc1float(na);
	
	/* remember the step size */
	drleft = drorig = dr;
	
	/* initialize slownesses to values at current r */
	for (i=0; i<na; ++i)
		s[i] = sc[i];
	
	/* copy inputs to output */
	for (i=0; i<na; ++i) {
		un[i] = uc[i];
		wn[i] = wc[i];
		tn[i] = tc[i];
	}
	
	/* determine if angular coordinate wraps around */
	wrap = ABS(na*da-2.0*PI)<0.01*ABS(da);
	
	/* loop over intermediate steps with adaptive stepsize */
	while (drleft>0.0) {
		
		/* determine adaptive step size according to CFL condition */
		for (i=0,cmax=TINY; i<na; ++i) {
			if (r*ABS(un[i])<TINY*ABS(wn[i]))
				cmax = 1.0/TINY;
			else
				cmax = MAX(cmax,ABS(wn[i]/(r*un[i])));
		}
		dr = MIN(drleft,CFL/cmax*r*da);
		
		/* if angles wrap around */
		if (wrap) {
			umaxl = (wn[na-1]>0.0 ? un[na-1] : s[0]);
			if (wn[0]>0.0) {
				uminm = s[0];
				umaxm = un[0];
			} else {
				uminm = un[0];
				umaxm = s[0];
			}
			uminr = (wn[1]>0.0 ? s[0] : un[1]);
			ueol = uminm+umaxl;
			ueor = uminr+umaxm;
			wtemp[0] = wn[0]+dr*(ueor-ueol)/da;
			umaxl = (wn[na-2]>0.0 ? un[na-2] : s[na-1]);
			if (wn[na-1]>0.0) {
				uminm = s[na-1];
				umaxm = un[na-1];
			} else {
				uminm = un[na-1];
				umaxm = s[na-1];
			}
			uminr = (wn[0]>0.0 ? s[na-1] : un[0]);
			ueol = uminm+umaxl;
			ueor = uminr+umaxm;
			wtemp[na-1] = wn[na-1]+dr*(ueor-ueol)/da;
		
		/* else, if angles do not wrap around */
		} else {
			if (wn[0]<=0.0)
				wtemp[0] = wn[0] + 
					dr*(un[1]-un[0])/da; 
			else
				wtemp[0] = 0.0;
			if (wn[na-1]>=0.0) 
				wtemp[na-1] = wn[na-1] +
					dr*(un[na-1]-un[na-2])/da;
			else
				wtemp[na-1] = 0.0;
		}
		
		/* update interior w values via Enquist/Osher scheme */
		for (i=1; i<na-1; ++i) {
			umaxl = (wn[i-1]>0.0 ? un[i-1] : s[i]);
			if (wn[i]>0.0) {
				uminm = s[i];
				umaxm = un[i];
			} else {
				uminm = un[i];
				umaxm = s[i];
			}
			uminr = (wn[i+1]>0.0 ? s[i] : un[i+1]);
			ueol = uminm+umaxl;
			ueor = uminr+umaxm;
			wtemp[i] = wn[i]+dr*(ueor-ueol)/da;
		}
		
		/* decrement the size of step left to do */
		drleft -= dr;
		
		/* update radial coordinate and its inverse */
		r += dr;
		or = 1.0/r;
		
		/* linearly interpolate slowness for new r */
		frac = drleft/drorig;
		for (i=0; i<na; ++i)
			s[i] = frac*sc[i]+(1.0-frac)*sn[i];
		
		/* update w and u; integrate u to get t */
		for (i=0; i<na; i++) {
			wn[i] = wtemp[i];
			wor = wn[i]*or;
			uu = (s[i]-wor)*(s[i]+wor);
			if(uu<=0)
				err("\tRaypath has too large a curvature!\n\t"
				    "A smoother velocity is required. \n");
 			unew = sqrt(uu); 
			uold = un[i];
			un[i] = unew;
			tn[i] += 0.5*dr*(unew+uold);
		}
	}
	
	/* free workspace */
	free1float(wtemp);
	free1float(s);
}

static void sigma (int na, float da, float r, float dr, 
	float uc[], float wc[], float sc[],
	float un[], float wn[], float sn[])
/*****************************************************************************
difference equation extrapolation of "sigma" in polar coordinates
******************************************************************************
Input:
na		number of a samples
da		a sampling interval
r		current radial distance r
dr		radial distance to extrapolate
uc		array[na] of dt/dr at current r
wc		array[na] of dt/da at current r
sc		array[na] of sigma  at current r
un		array[na] of dt/dr at next r
wn		array[na] of dt/da at next r

Output:
sn		array[na] of sigma at next r 
******************************************************************************

This function implements the Crank-Nicolson finite-difference method with
boundary conditions dsigma/da=0. 

Author:  Zhenyue Liu, Center for Wave Phenomena, 07/8/92
******************************************************************************/
{
	int i;
	float r1,*d,*b,*c,*e;
	
	/* allocate workspace */
	d = alloc1float(na-2);
	b = alloc1float(na-2);
	c = alloc1float(na-2);
	e = alloc1float(na-2);
	
	r1 = r+dr;
 	
	/* Crank-Nicolson */
 	for (i=0; i<na-2; ++i) {
		d[i] = (uc[i+1]+un[i+1])/(2.0*dr);
		e[i] = (wn[i+1]/(r1*r1)+wc[i+1]/(r*r))/(8.0*da);
		b[i] = 1.0-(sc[i+2]-sc[i])*e[i]
			+d[i]*sc[i+1];
		c[i] = -e[i];
	} 
	d[0] += c[0];
	d[na-3] += e[na-3]; 
	
	tripp(na-2,d,e,c,b);
	for(i=0;i<na-2; ++i) sn[i+1]=b[i];
	sn[0] = sn[1];
	sn[na-1] = sn[na-2];
	
	
	/* free workspace */
	free1float(d);
	free1float(c);
	free1float(e);
	free1float(b);
}

static void beta (int na, float da, float r, float dr, 
	float uc[], float wc[], float bc[],
	float un[], float wn[], float bn[])
/*****************************************************************************
difference equation extrapolation of "beta" in polar coordinates
******************************************************************************
Input:
na		number of a samples
da		a sampling interval
r		current radial distance r
dr		radial distance to extrapolate
uc		array[na] of dt/dr at current r
wc		array[na] of dt/da at current r
bc		array[na] of beta  at current r
un		array[na] of dt/dr at next r
wn		array[na] of dt/da at next r

Output:
bn		array[na] of beta at next r 
******************************************************************************

This function implements the Crank-Nicolson finite-difference method, with 
boundary conditions dbeta/da=1. 

author:  Zhenyue Liu, Center for Wave Phenomena, 07/8/92
******************************************************************************/
{
	int i;
	float r1,*d,*b,*c,*e;
	
	/* allocate workspace */
	d = alloc1float(na-2);
	b = alloc1float(na-2);
	c = alloc1float(na-2);
	e = alloc1float(na-2);
	
	r1 = r+dr;
	/* Crank-Nicolson */
   	for (i=0; i<na-2; ++i) {
		d[i] = uc[i+1]*r*r+un[i+1]*r1*r1;
		e[i] = (wn[i+1]+wc[i+1])*dr/(4.0*da);
		b[i] = -(bc[i+2]-bc[i])*e[i]
			+d[i]*bc[i+1];
		c[i] = -e[i];
	}   
	d[0] += c[0];
	d[na-3] += e[na-3]; 
	b[0] += da*c[0];
	b[na-3] -= da*e[na-3];
	
	tripp(na-2,d,e,c,b);
	for(i=0;i<na-2; ++i) bn[i+1]=b[i];
	bn[0] = bn[1]-da;
	bn[na-1] = bn[na-2]+da;
	
	
	/* free workspace */
	free1float(d);
	free1float(c);
	free1float(e);
	free1float(b);
}

static void exch(float x, float y);
static void exch(float x, float y)
{    
	float t;
	t=x; x=y; y=t;
}

static void tripp(int n, float *d, float *e, float *c, float *b)
/*******************************************************************
Solve an unsymmetric tridiagonal system that uses Gaussian elimination 
with partial pivoting
********************************************************************
Input:
d	diagonal vector of matrix
e       upper-diagonal vector of matrix
c       lower-diagonal vector of matrix
b       right-hand vector
n       dimension of matrix

Output:
b       solution vector
*******************************************************************
Author: Zhenyue Liu, Colorado School of Mines, 7/06/92
*********************************************************************/
{
	int k;
	float temp;

	
/*      elimination   */
	for(k=0; k<n-1; ++k){
	    c[k] = 0;
 	    if(ABS(d[k])<ABS(c[k+1])){
	        exch(d[k],c[k+1]);
		exch(e[k],d[k+1]);
		exch(c[k],e[k+1]);
		exch(b[k],b[k+1]);
		} 
		
	    if(d[k]==0 ) err("coefficient matrix is singular!\n");
	    temp = c[k+1]/d[k];  
	    d[k+1] -= temp*e[k];
	    e[k+1] -= temp*c[k];
	    b[k+1] -= temp*b[k];
        } 
	 
/*      substitution      */
	if(d[n-1]==0 ) err("coefficient matrix is singular!\n");
	b[n-1] = b[n-1]/d[n-1];
	b[n-2] = (b[n-2] - b[n-1]*e[n-2])/d[n-2];		
	for(k=n-3; k>=0; --k)
	    b[k] = (b[k] - b[k+1]*e[k] - b[k+2]*c[k])/d[k];
	    
}	

/* functions defined and used internally */
static void eiktam (float xs, float zs, 
	int nz, float dz, float fz, int nx, float dx, float fx, float **vel,
	float **time, float **angle, float **sig, float **bet)
/*****************************************************************************
Compute traveltimes t(x,z) and  propagation angle a(x,z) via eikonal equation,
 and sigma sig(x,z), incident angle bet(x,z) via Crank-Nicolson Method
******************************************************************************
Input:
xs		x coordinate of source (must be within x samples)
zs		z coordinate of source (must be within z samples)
nz		number of z samples
dz		z sampling interval
fz		first z sample
nx		number of x samples
dx		x sampling interval
fx		first x sample
vel		array[nx][nz] containing velocities

Output:
time		array[nx][nz] containing first-arrival times
angle		array[nx][nz] containing propagation angles
sig  		array[nx][nz] containing sigmas
bet		array[nx][nz] containing betas
******************************************************************************
Notes:
The actual computation of times and sigmas is done in polar coordinates,
with bilinear interpolation used to map to/from rectangular coordinates.
******************************************************************************
Revisor:  Zhenyue Liu, Colorado School of Mines, 7/8/92
******************************************************************************/
{
	int ix,iz,ia,ir,na,nr;
	float ss,a,r,da,dr,fa,fr,ex,ez,ea,rmax,rmaxs,
		**s,**sp,**tp,**up,**wp,**ap;

	/* shift coordinates so source is at (x=0,z=0) */
	fx -= xs;
	fz -= zs;
	ex = fx+(nx-1)*dx;
	ez = fz+(nz-1)*dz;
	
	/* determine polar coordinate sampling */
	rmaxs = fx*fx+fz*fz;
	rmaxs = MAX(rmaxs,fx*fx+ez*ez);
	rmaxs = MAX(rmaxs,ex*ex+ez*ez);
	rmaxs = MAX(rmaxs,ex*ex+fz*fz);
	rmax = sqrt(rmaxs);
	dr = MIN(ABS(dx),ABS(dz));
	nr = 1+NINT(rmax/dr);
	dr = rmax/(nr-1);
	fr = 0.0;
	if (fx==0.0 && fz==0.0) {
		fa = 0.0;  ea = PI/2.0;
	} else if (fx<0.0 && fz==0.0) {
		fa = -PI/2.0;  ea = PI/2.0;
	} else if (fx==0.0 && fz<0.0) {
		fa = 0.0;  ea = PI;
	} else {
		fa = -PI;  ea = PI;
	}
	da = dr/rmax;
	na = 1+NINT((ea-fa)/da);
	da = (ea-fa)/(na-1);
	if (fa==-PI && ea==PI)
		na = na-1;
	
	/* allocate space */
	s = alloc2float(nz,nx);
	sp = alloc2float(na,nr);
	tp = alloc2float(na,nr);
	up = alloc2float(na,nr);
	wp = alloc2float(na,nr);
	ap = alloc2float(na,nr);
	
	/* compute slownesses */
	for (ix=0; ix<nx; ++ix)
		for (iz=0; iz<nz; ++iz)
			s[ix][iz] = 1.0/vel[ix][iz];
	
	/* convert from rectangular to polar coordinates */
	recttopolar(nz,dz,fz,nx,dx,fx,s,na,da,fa,nr,dr,fr,sp);
	
	/* average the slownesses in source region */
	for (ir=0,ss=0.0; ir<2; ++ir)
		for (ia=0; ia<na; ++ia)
			ss += sp[ir][ia];
	ss /= 2*na;

	/* compute traveltimes and derivatives in source region */
	for (ir=0,r=0; ir<2; ++ir,r+=dr) {
		for (ia=0; ia<na; ++ia) {
			up[ir][ia] = ss;
			wp[ir][ia] = 0.0;
			tp[ir][ia] = r*ss;
		}
	}

/* 	tt=cpusec();   */
	/* solve eikonal equation for remaining times and derivatives */
	for (ir=1,r=dr; ir<nr-1; ++ir,r+=dr) {
		eikpex(na,da,r,dr,
			sp[ir],up[ir],wp[ir],tp[ir],
			sp[ir+1],up[ir+1],wp[ir+1],tp[ir+1]);
	}
	
	/* convert times from polar to rectangular coordinates */
	polartorect(na,da,fa,nr,dr,fr,tp,nz,dz,fz,nx,dx,fx,time);

/*  	fprintf(stderr,"\t CPU time for traveltimes= %f \n",cpusec()-tt); 
 	tt=cpusec();   */
	
	/* compute propagation angles in polar and convert */
	for (ia=0,a=fa; ia<na; ++ia,a+=da)
		ap[0][ia] = a;
	for (ir=1,r=fr+dr; ir<nr; ++ir,r+=dr)
		for (ia=0,a=fa; ia<na; ++ia,a+=da){
		    ap[ir][ia] = a+asin(wp[ir][ia]/(sp[ir][ia]*r));
		}
	polartorect(na,da,fa,nr,dr,fr,ap,nz,dz,fz,nx,dx,fx,angle);
/*  	fprintf(stderr,"\t CPU time for propagation angles= %f\n", 	
		cpusec()-tt); 
	tt=cpusec();   */
	
	/* compute sigmas  for initial values */
	for (ir=0,r=0; ir<2; ++ir,r+=dr) 
		for (ia=0; ia<na; ++ia) tp[ir][ia] = r/ss;

	/* solve diffrence equation for remaining sigmas */
	for (ir=1,r=dr; ir<nr-1; ++ir,r+=dr) 
 		sigma(na,da,r,dr,up[ir],wp[ir],tp[ir],
			up[ir+1],wp[ir+1],tp[ir+1]);  
	polartorect(na,da,fa,nr,dr,fr,tp,nz,dz,fz,nx,dx,fx,sig);

/* 	fprintf(stderr,"\t CPU time for sigmas= %f \n",cpusec()-tt); 
	tt=cpusec(); */
	
	/* compute betas for initial values */
	for (ir=0; ir<2; ++ir) 
		for (ia=0,a=fa; ia<na; ++ia,a+=da) tp[ir][ia] = a;

	/* solve diffrence equation for remaining betas */
	for (ir=1,r=dr; ir<nr-1; ++ir,r+=dr) 
 		beta(na,da,r,dr,up[ir],wp[ir],tp[ir],
			up[ir+1],wp[ir+1],tp[ir+1]);  
	polartorect(na,da,fa,nr,dr,fr,tp,nz,dz,fz,nx,dx,fx,bet);
	
/* 	fprintf(stderr,"\t CPU time for incident angles= %f \n",
		cpusec()-tt); */
	
	/* free space */
	free2float(s);
	free2float(sp);
	free2float(tp);
	free2float(up);
	free2float(wp);
	free2float(ap);
}

@


1.15
log
@Using two argument CHECK_NT macro to check the relevant time sample
quantity.
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.14 $ ; $Date: 1996/02/21 22:15:52 $	*/
d129 2
a130 1
		**v,**ts1,**as1,**sgs1,**tg1,**ag1,**sgg1;
@


1.14
log
@Using CHECK_NT macro.
Removed numerous unused variables (per -Wall).
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.13 $ ; $Date: 1996/02/20 23:04:59 $	*/
d148 1
a148 1
	if (!getparint("nt",&nt)) nt = 101; CHECK_NT(nt);
@


1.13
log
@Protect against nt >SU_NFLTS.
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.12 $ ; $Date: 1996/02/07 15:27:47 $	*/
a106 3
static void dbeta (int na, float da, float r, float dr, 
	float uc[], float bc[],
	float un[], float bn[]);
d116 1
d119 1
a119 1
	int 	nr,ir,ixz,ls,smooth,ndpfz,ns,ixo,ixm,nxo,nxm,nt,
d124 1
a124 1
		x,z,t,dsmax,fpeak,dx,dz,fx,ex,fx1,ex1,
d127 1
a127 1
		*trace,*ar,**xr,**zr,
d148 1
a148 2
	if (!getparint("nt",&nt)) nt = 101;
	if (nt > SU_NFLTS) err("Cannot have nt=%d > SU_NFLTS=%d",nt,SU_NFLTS);
d408 1
a408 1
	float ar,ds,xd,zd,cd,sd,vd,cg,sg,xi,zi,ci,cr,time,amp,sx,sz,
d550 1
a550 1
		uu,uumin,unew,uold,ueol,ueor,wor,or,*wtemp,*s;
d764 1
a764 1
	float r1,*d,*b,*c,*e,t;
d887 1
a887 1
	float ss,a,r,da,dr,fa,fr,ex,ez,ea,rmax,rmaxs,tt,
@


1.12
log
@Deal with header fields accessed/modified down to sudoc.
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.11 $ ; $Date: 1995/09/27 20:24:24 $	*/
d151 1
@


1.11
log
@added return EXIT_SUCCESS at the end of main
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.10 $ ; $Date: 1995/07/11 18:36:56 $	*/
d60 4
d241 1
a241 1
	    nxd1 = nxd;				    				
d661 3
a663 1
			if(uu<=0) err("\tRaypath has a too large curvature!\n\t A smoother velocity is required. \n");
@


1.10
log
@Changed default to verbose=0.
Changed fprint's to warn's.
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.9 $ ; $Date: 1995/03/17 10:22:48 $	*/
d374 1
@


1.9
log
@adde d tr.d2 tr.df2 to make u output data
have correct values in headers for polottoning
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.8 $ ; $Date: 94/09/06 10:21:33 $	*/
d39 1
a39 1
" verbose=1		=1 to print some useful information		",
d160 1
a160 1
	if (!getparint("verbose",&verbose)) verbose = 1;
d199 2
a200 5
		fprintf(stderr,"\nSUSYNVXZ:\n");
		fprintf(stderr,
			"Total number of small reflecting\n"
			"segments is %d.\n",ns);
		fprintf(stderr,"\n");
d353 1
a353 1
	    fprintf(stderr,"\t finish offset %f\n",xo);
@


1.8
log
@Added include of segy.h
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.7 $ ; $Date: 94/08/25 15:01:20 $	*/
d344 2
@


1.7
log
@Removed copyright statement from codes that had it.
Moved self-doc line for sudoc.
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.6 $ ; $Date: 94/03/25 09:56:16 $	*/
d4 1
@


1.6
log
@removed redundant sub calls. 
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.5 $ ; $Date: 94/03/01 12:34:04 $	*/
a2 6
/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1992.
 * All rights reserved.
 *----------------------------------------------------------------------
 */

a54 1
/**************** end self doc ***********************************/
d57 4
a60 3
	Author:  Zhenyue Liu, 07/20/92, Center for Wave Phenomena
		Many subroutines borrowed from Dave Hale's program: SUSYNLV
*/
@


1.5
log
@Removed common subs in synlv clones to par/lib/modeling.c
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.4 $ ; $Date: 94/02/08 10:51:12 $	*/
a855 7
static void recttopolar (
	int nx, float dx, float fx, int ny, float dy, float fy, float **p,
	int na, float da, float fa, int nr, float dr, float fr, float **q);
static void polartorect (
	int na, float da, float fa, int nr, float dr, float fr, float **q,
	int nx, float dx, float fx, int ny, float dy, float fy, float **p);

a1011 134
}

static void recttopolar (
	int nx, float dx, float fx, int ny, float dy, float fy, float **p,
	int na, float da, float fa, int nr, float dr, float fr, float **q)
/*****************************************************************************
Convert a function of p(x,y) to q(a,r), where x = r*cos(a) and y = r*sin(a)
******************************************************************************
Input:
nx		number of x samples
dx		x sampling interval
fx		first x sample
ny		number of y samples
dy		y sampling interval
fy		first y sample
p		array[ny][nx] containing samples of p(x,y)
na		number of a samples
da		a sampling interval
fa		first a sample
nr		number of r samples
dr		r sampling interval
fr		first r sample

Output:
q		array[nr][na] containing samples of q(a,r)
******************************************************************************
Notes:
The polar angle a is measured in radians.

Linear extrapolation is used to determine the value of p(x,y) for
x and y coordinates not in the range corresponding to nx, dx, ....
******************************************************************************
Author:  Dave Hale, Colorado School of Mines, 06/15/90
******************************************************************************/
{
	int ia,ir,ix,iy;
	float a,r,x,y,xi,yi,sx,sy;
	
	/* for all r */
	for (ir=0,r=fr; ir<nr; ++ir,r+=dr) {
	
		/* for all a */
		for (ia=0,a=fa; ia<na; ++ia,a+=da) {
		
			/* determine x and y */
			x = r*cos(a);
			y = r*sin(a);
			
			/* determine sample indices */
			xi = (x-fx)/dx;
			ix = xi;
			if (ix<0 ) xi = ix = 0; 
			if (ix>nx-2) {ix = nx-2; xi = nx-1;}
			yi = (y-fy)/dy;
			iy = yi;
			if (iy<0) yi = iy = 0;
			if (iy>ny-2) {iy = ny-2; yi = ny-1;}
			
			/* bilinear interpolation */
			sx = xi-ix;
			sy = yi-iy;
			q[ir][ia] = (1.0-sy)*((1.0-sx)*p[iy][ix] + 
						sx*p[iy][ix+1]) +
					sy*((1.0-sx)*p[iy+1][ix] +
						sx*p[iy+1][ix+1]);
		}
	}
}

static void polartorect (
	int na, float da, float fa, int nr, float dr, float fr, float **q,
	int nx, float dx, float fx, int ny, float dy, float fy, float **p)
/*****************************************************************************
Convert a function of q(a,r) to p(x,y), where x = r*cos(a) and y = r*sin(a)
******************************************************************************
Input:
na		number of a samples
da		a sampling interval
fa		first a sample
nr		number of r samples
dr		r sampling interval
fr		first r sample
nx		number of x samples
dx		x sampling interval
fx		first x sample
ny		number of y samples
dy		y sampling interval
fy		first y sample
q		array[nr][na] containing samples of q(a,r)

Output:
p		array[ny][nx] containing samples of p(x,y)
******************************************************************************
Notes:
The polar angle a is measured in radians.

Linear extrapolation is used to determine the value of q(a,r) for
a and r coordinates not in the range corresponding to na, da, ....
******************************************************************************
Author:  Dave Hale, Colorado School of Mines, 06/15/90
******************************************************************************/
{
	int ix,iy,ia,ir;
	float x,y,a,r,ai,ri,sa,sr;
	
	/* for all y */
	for (iy=0,y=fy; iy<ny; ++iy,y+=dy) {
	
		/* for all x */
		for (ix=0,x=fx; ix<nx; ++ix,x+=dx) {
		
			/* determine a and r */
			a = atan2(y,x);
			r = sqrt(x*x+y*y);
			
			/* determine sample indices */
			ai = (a-fa)/da;
			ia = ai;
			if (ia<0) ai = ia = 0;
			if (ia>na-2) {ai = na-1; ia = na-2;}
			ri = (r-fr)/dr;
			ir = ri;
			if (ir<0) ri = ir = 0;
			if (ir>nr-2) {ri = nr-1; ir = nr-2;}
			
			/* bilinear interpolation */
			sa = ai-ia;
			sr = ri-ir;
			p[iy][ix] = (1.0-sr)*((1.0-sa)*q[ir][ia] + 
						sa*q[ir][ia+1]) +
					sr*((1.0-sa)*q[ir+1][ia] +
						sa*q[ir+1][ia+1]);
		}
	}
@


1.4
log
@Fixed array bound in makeref pointed out by Eric Verschuur at Delft.
Code originally read: for (iuu=0,uu=0.0,s[0]=0.0; iuu<nuu; ++iuu,uu+=duu) {
but this causes an out-of-bounds access a few lines later:
s[iuu] = s[iuu-1]+sqrt(dx*dx+dz*dz);
Since s[0] is initialized to zero, it is clear that we want iuu=1.
Since s[0] = 0.0; occurred a few lines earlier in the code, I
dropped the initialization in the for loop.  Also changed to uu=duu:
for (iuu=1,uu=duu; iuu<nuu; ++iuu,uu+=duu) {
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.3 $ ; $Date: 93/11/24 16:22:15 $	*/
d68 21
a88 18
/* define structures */
typedef struct ReflectorSegmentStruct {
	float x;	/* x coordinate of segment midpoint */
	float z;	/* z coordinate of segment midpoint */
	float s;	/* x component of unit-normal-vector */
	float c;	/* z component of unit-normal-vector */
} ReflectorSegment;
typedef struct ReflectorStruct {
	int ns;			/* number of reflector segments */
	float ds;		/* segment length */
	float a;		/* amplitude of reflector */
	ReflectorSegment *rs;	/* array[ns] of reflector segments */
} Reflector;
typedef struct WaveletStruct {
	int lw;			/* length of wavelet */
	int iw;			/* index of first wavelet sample */
	float *wv;		/* wavelet sample values */
} Wavelet;
d94 1
a94 9
/* prototypes for functions defined and used internally */
static void decodeReflectors (int *nrPtr,
	float **aPtr, int **nxzPtr, float ***xPtr, float ***zPtr);
static int decodeReflector (char *string,
	float *aPtr, int *nxzPtr, float **xPtr, float **zPtr);
static void breakReflectors (int *nr, float **ar, 
	int **nu, float ***xu, float ***zu);
static void makeref (float dsmax, int nr, float *ar, 
	int *nu, float **xu, float **zu, Reflector **r);
d99 1
a99 6
static void addsinc (float time, float amp,
	int nt, float dt, float ft, float *trace);
static void makericker (float fpeak, float dt, Wavelet **w);

/* additional prototypes for eikonal equation functions */
void eikpex (int na, float da, float r, float dr, 
d102 1
a102 1
void sigma (int na, float da, float r, float dr, 
d105 1
a105 1
void beta (int na, float da, float r, float dr, 
d108 1
a108 1
void dbeta (int na, float da, float r, float dr, 
d111 2
a112 2
void tripp (int n, float *d, float *e, float *c, float *b);
void eiktam (float xs, float zs, 
d381 1
a514 7
/* parse reflectors parameter string */
static void decodeReflectors (int *nrPtr,
	float **aPtr, int **nxzPtr, float ***xPtr, float ***zPtr)
{
	int nr,*nxz,ir;
	float *a,**x,**z;
	char t[1024],*s;
a515 325
	/* count reflectors */
	nr = countparname("ref");
	if (nr==0) nr = 1;
	
	/* allocate space */
	a = ealloc1(nr,sizeof(float));
	nxz = ealloc1(nr,sizeof(int));
	x = ealloc1(nr,sizeof(float*));
	z = ealloc1(nr,sizeof(float*));

	/* get reflectors */
	for (ir=0; ir<nr; ++ir) {
		if (!getnparstring(ir+1,"ref",&s)) s = "1:1,2;4,2";
		strcpy(t,s);
		if (!decodeReflector(t,&a[ir],&nxz[ir],&x[ir],&z[ir]))
			err("Reflector number %d specified "
				"incorrectly!\n",ir+1);
	}

	/* set output parameters before returning */
	*nrPtr = nr;
	*aPtr = a;
	*nxzPtr = nxz;
	*xPtr = x;
	*zPtr = z;
}

/* parse one reflector specification; return 1 if valid, 0 otherwise */
static int decodeReflector (char *string,
	float *aPtr, int *nxzPtr, float **xPtr, float **zPtr)
{
	int nxz,ixz;
	float a,*x,*z;
	char *s,*t;

	/* if specified, get reflector amplitude; else, use default */
	s = string;
	if (strchr(s,':')==NULL) {
		a = 1.0;
		s = strtok(s,",;\0");
	} else {
		if (strcspn(s,":")>=strcspn(s,",;\0")) return 0;
		a = atof(s=strtok(s,":"));
		s = strtok(NULL,",;\0");
	}

	/* count x and z values, while splitting string into tokens */
	for (t=s,nxz=0; t!=NULL; ++nxz)
		t = strtok(NULL,",;\0");
	
	/* total number of values must be even */
	if (nxz%2) return 0;

	/* number of (x,z) pairs */
	nxz /= 2;

	/* 2 or more (x,z) pairs are required */
	if (nxz<2) return 0;

	/* allocate space */
	x = ealloc1(nxz,sizeof(float));
	z = ealloc1(nxz,sizeof(float));

	/* convert (x,z) values */
	for (ixz=0; ixz<nxz; ++ixz) {
		x[ixz] = atof(s);
		s += strlen(s)+1;
		z[ixz] = atof(s);
		s += strlen(s)+1;
	}

	/* set output parameters before returning */
	*aPtr = a;
	*nxzPtr = nxz;
	*xPtr = x;
	*zPtr = z;
	return 1;
}

/* Break up reflectors by duplicating interior (x,z) points */
static void breakReflectors (int *nr, float **ar, 
	int **nu, float ***xu, float ***zu)
{
	int nri,nro,*nui,*nuo,ir,jr,iu;
	float *ari,*aro,**xui,**zui,**xuo,**zuo;

	/* input reflectors */
	nri = *nr;
	ari = *ar;
	nui = *nu;
	xui = *xu;
	zui = *zu;

	/* number of output reflectors */
	for (ir=0,nro=0; ir<nri; ++ir)
		nro += nui[ir]-1;

	/* make output reflectors and free space for input reflectors */
	aro = ealloc1float(nro);
	nuo = ealloc1int(nro);
	xuo = ealloc1(nro,sizeof(float*));
	zuo = ealloc1(nro,sizeof(float*));
	for (ir=0,jr=0; ir<nri; ++ir) {
		for (iu=0; iu<nui[ir]-1; ++iu,++jr) {
			aro[jr] = ari[ir];
			nuo[jr] = 2;
			xuo[jr] = ealloc1float(2);
			zuo[jr] = ealloc1float(2);
			xuo[jr][0] = xui[ir][iu];
			zuo[jr][0] = zui[ir][iu];
			xuo[jr][1] = xui[ir][iu+1];
			zuo[jr][1] = zui[ir][iu+1];
		}
		free1float(xui[ir]);
		free1float(zui[ir]);
	}
	free1float(ari);
	free1int(nui);
	free1(xui);
	free1(zui);

	/* output reflectors */
	*nr = nro;
	*ar = aro;
	*nu = nuo;
	*xu = xuo;
	*zu = zuo;
}

static void makeref (float dsmax, int nr, float *ar, 
	int *nu, float **xu, float **zu, Reflector **r)
/*****************************************************************************
Make piecewise cubic reflectors
******************************************************************************
Input:
dsmax		maximum length of reflector segment
nr		number of reflectors
ar		array[nr] of reflector amplitudes
nu		array[nr] of numbers of (x,z) pairs; u = 0, 1, ..., nu[ir]
xu		array[nr][nu[ir]] of reflector x coordinates x(u)
zu		array[nr][nu[ir]] of reflector z coordinates z(u)

Output:
r		array[nr] of reflectors
******************************************************************************
Notes:
Space for the ar, nu, xu, and zu arrays is freed by this function, since
they are only used to construct the reflectors.

This function is meant to be called only once, so it need not be very
efficient.  Once made, the reflectors are likely to be used many times, 
so the cost of making them is insignificant.
*****************************************************************************/
{
	int ir,iu,nuu,iuu,ns,is;
	float x,z,xlast,zlast,dx,dz,duu,uu,ds,fs,rsx,rsz,rsxd,rszd,
		*u,*s,(*xud)[4],(*zud)[4],*us;
	ReflectorSegment *rs;
	Reflector *rr;
	
	/* allocate space for reflectors */
	*r = rr = ealloc1(nr,sizeof(Reflector));

	/* loop over reflectors */
	for (ir=0; ir<nr; ++ir) {

		/* compute cubic spline coefficients for uniformly sampled u */
		u = ealloc1float(nu[ir]);
		for (iu=0; iu<nu[ir]; ++iu)
			u[iu] = iu;
		xud = (float(*)[4])ealloc1float(4*nu[ir]);
		csplin(nu[ir],u,xu[ir],xud);
		zud = (float(*)[4])ealloc1float(4*nu[ir]);
		csplin(nu[ir],u,zu[ir],zud);

		/* finely sample x(u) and z(u) and compute length s(u) */
		nuu = 20*nu[ir];
		duu = (u[nu[ir]-1]-u[0])/(nuu-1);
		s = ealloc1float(nuu);
		s[0] = 0.0;
		xlast = xu[ir][0];
		zlast = zu[ir][0];
		for (iuu=1,uu=duu; iuu<nuu; ++iuu,uu+=duu) {
			intcub(0,nu[ir],u,xud,1,&uu,&x);
			intcub(0,nu[ir],u,zud,1,&uu,&z);
			dx = x-xlast;
			dz = z-zlast;
			s[iuu] = s[iuu-1]+sqrt(dx*dx+dz*dz);
			xlast = x;
			zlast = z;
		}

		/* compute u(s) from s(u) */
		ns = 1+s[nuu-1]/dsmax;
		ds = s[nuu-1]/ns;
		fs = 0.5*ds;
		us = ealloc1float(ns);
		yxtoxy(nuu,duu,0.0,s,ns,ds,fs,0.0,(float)(nu[ir]-1),us);

		/* compute reflector segments uniformly sampled in s */
		rs = ealloc1(ns,sizeof(ReflectorSegment));
		for (is=0; is<ns; ++is) {
			intcub(0,nu[ir],u,xud,1,&us[is],&rsx);
			intcub(0,nu[ir],u,zud,1,&us[is],&rsz);
			intcub(1,nu[ir],u,xud,1,&us[is],&rsxd);
			intcub(1,nu[ir],u,zud,1,&us[is],&rszd);
			rs[is].x = rsx;
			rs[is].z = rsz;
			rs[is].c = rsxd/sqrt(rsxd*rsxd+rszd*rszd);
			rs[is].s = -rszd/sqrt(rsxd*rsxd+rszd*rszd);
		}
		
		/* fill in reflector structure */
		rr[ir].ns = ns;
		rr[ir].ds = ds;
		rr[ir].a = ar[ir];
		rr[ir].rs = rs;

		/* free workspace */
		free1float(us);
		free1float(s);
		free1float(u);
		free1float((float*)xud);
		free1float((float*)zud);

		/* free space replaced by reflector segments */
		free1(xu[ir]);
		free1(zu[ir]);
	}

	/* free space replaced by reflector segments */
	free1(nu);
	free1(xu);
	free1(zu);
}


static void addsinc (float time, float amp,
	int nt, float dt, float ft, float *trace)
/*****************************************************************************
Add sinc wavelet to trace at specified time and with specified amplitude
******************************************************************************
Input:
time		time at which to center sinc wavelet
amp		peak amplitude of sinc wavelet
nt		number of time samples
dt		time sampling interval
ft		first time sample
trace		array[nt] containing sample values

Output:
trace		array[nt] with sinc added to sample values
*****************************************************************************/
{
	static float sinc[101][8];
	static int nsinc=101,madesinc=0;
	int jsinc;
	float frac;
	int itlo,ithi,it,jt;
	float tn,*psinc;

	/* if not made sinc coefficients, make them */
	if (!madesinc) {
		for (jsinc=1; jsinc<nsinc-1; ++jsinc) {
			frac = (float)jsinc/(float)(nsinc-1);
			mksinc(frac,8,sinc[jsinc]);
		}
		for (jsinc=0; jsinc<8; ++jsinc)
			sinc[0][jsinc] = sinc[nsinc-1][jsinc] = 0.0;
		sinc[0][3] = 1.0;
		sinc[nsinc-1][4] = 1.0;
		madesinc = 1;
	}
	tn = (time-ft)/dt;
	jt = tn;
	jsinc = (tn-jt)*(nsinc-1);
	itlo = jt-3;
	ithi = jt+4;
	if (itlo>=0 && ithi<nt) {
		psinc = sinc[jsinc];
		trace[itlo] += amp*psinc[0];
		trace[itlo+1] += amp*psinc[1];
		trace[itlo+2] += amp*psinc[2];
		trace[itlo+3] += amp*psinc[3];
		trace[itlo+4] += amp*psinc[4];
		trace[itlo+5] += amp*psinc[5];
		trace[itlo+6] += amp*psinc[6];
		trace[itlo+7] += amp*psinc[7];
	} else if (ithi>=0 && itlo<nt) {
		if (itlo<0) itlo = 0;
		if (ithi>=nt) ithi = nt-1;
		psinc = sinc[jsinc]+itlo-jt+3;
		for (it=itlo; it<=ithi; ++it)
			trace[it] += amp*(*psinc++);
	}
}
static void makericker (float fpeak, float dt, Wavelet **w)
/*****************************************************************************
Make Ricker wavelet
******************************************************************************
Input:
fpeak		peak frequency of wavelet
dt		time sampling interval

Output:
w		Ricker wavelet
*****************************************************************************/
{
	int iw,lw,it,jt;
	float t,x,*wv;
	
	iw = -(1+1.0/(fpeak*dt));
	lw = 1-2*iw;
	wv = ealloc1float(lw);
	for (it=iw,jt=0,t=it*dt; jt<lw; ++it,++jt,t+=dt) {
		x = PI*fpeak*t;
		x = x*x;
		wv[jt] = exp(-x)*(1.0-2.0*x);
	}
	*w = ealloc1(1,sizeof(Wavelet));
	(*w)->lw = lw;
	(*w)->iw = iw;
	(*w)->wv = wv;
}

d519 1
a519 1
void eikpex (int na, float da, float r, float dr, 
d675 1
a675 1
void sigma (int na, float da, float r, float dr, 
d737 1
a737 1
void beta (int na, float da, float r, float dr, 
d806 2
a807 1
void tripp(int n, float *d, float *e, float *c, float *b)
d863 1
a863 1
void eiktam (float xs, float zs, 
@


1.3
log
@changed bzero to memset
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.2 $ ; $Date: 93/06/16 15:35:57 $	*/
d714 1
a714 1
		for (iuu=0,uu=0.0,s[0]=0.0; iuu<nuu; ++iuu,uu+=duu) {
@


1.2
log
@cosmetic change
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.1 $ ; $Date: 93/06/07 14:35:01 $	*/
d222 1
a222 1
	bzero(&tr,sizeof(tr));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SUSYNVXZ: $Revision: 1.2 $ ; $Date: 92/05/07 10:32:56 $	*/
d14 1
a14 1
" SUSYNXZ - SYNthetic seismograms of common offset V(X,Z) media via	",
d17 1
a17 1
" susynxz >outfile [optional parameters]				",
@
