head	1.17;
access;
symbols;
locks
	john:1.17; strict;
comment	@ * @;


1.17
date	2011.11.16.22.14.43;	author john;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.12.00.21.33;	author john;	state Exp;
branches;
next	1.15;

1.15
date	2010.02.03.23.15.20;	author john;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.30.21.42.34;	author john;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.13.16.55.11;	author john;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.07.22.58.42;	author john;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.31.22.01.49;	author john;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.17.18.59.13;	author john;	state Exp;
branches;
next	1.9;

1.9
date	2006.09.28.23.19.24;	author john;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.22.00.54.17;	author john;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.24.00.02.14;	author john;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.19.17.31.42;	author john;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.25.20.38.38;	author john;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.22.19.32.49;	author john;	state Exp;
branches;
next	1.2;

1.2
date	98.05.04.18.16.33;	author john;	state Exp;
branches;
next	1.1;

1.1
date	98.05.04.18.08.16;	author john;	state Exp;
branches;
next	;


desc
@sumigprepspi.c - prestack PSPI migration
@


1.17
log
@added Reg Beardsley checkpar()
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SUMIGPREPSPI: $Vision: 1.00 $ ; $Date: 2010/02/03 23:15:20 $*/

#include "su.h"
#include "segy.h"
#include "header.h"
#include <signal.h>


/*********************** self documentation ******************************/
char *sdoc[] = {
"									",
" SUMIGPREPSPI --- The 2-D PREstack commom-shot Phase-Shift-Plus 	",
"			interpolation depth MIGration.			",
"									",
"   sumigprepspi <indata >outfile [parameters] 				", 
"									",
" Required Parameters:						   	",
"									",
" nxo=	   number of total horizontal output samples			",
" nxshot=	number of shot gathers to be migrated		   	",
" nz=	    number of depth sapmles				 	",
" dx=	    horizontal sampling interval			  	",   
" dz=	    depth sampling interval				 	",
" vfile=	 velocity profile, it must be binary format.		",
" 									",
" Optional Parameters:						   	",
" fmax=25	the peak frequency of Ricker wavelet used as source wavelet",
" f1=5,f2=10,f3=40,f4=50	 frequencies to build a Hamming window  ",
" lpad=9999,rpad=9999	    number of zero traces padded on both	",
" 			    sides of depth section to determine the	",
"			    migration aperature, the default values	",
"			    are using the full aperature.		",
" verbose=0		silent, =1 additional runtime information	",
"									",  
" Notes:								",
" The input velocity file \'vfile\' consists of C-style binary floats.	",  
" The structure of this file is vfile[iz][ix]. Note that this means that",
" the x-direction is the fastest direction instead of z-direction! Such a",
" structure is more convenient for the downward continuation type	",
" migration algorithm than using z as fastest dimension as in other SU  ", 
" programs.						   		",
"									",
" Because most of the tools in the SU package (such as  unif2, unisam2, ", 
" and makevel) produce output with the structure vfile[ix][iz], you will",
" need to transpose the velocity files created by these programs. You may",
" use the SU program \'transp\' in SU to transpose such files into the  ",
" required vfile[iz][ix] structure.					",
"									",
" (In C  v[iz][ix] denotes a v(x,z) array, whereas v[ix][iz]  		",
" denotes a v(z,x) array, the opposite of what Matlab and Fortran	",
" programmers may expect.)						", 
"									",
" Also, sx must be monotonically increasing throughout the dataset, and ",
" and gx must be monotonically increasing within a shot. You may resort ",
" your data with \'susort\', accordingly.				",
"									",
" The scalco header field is honored so this field must be set correctly.",
" See selfdocs of \'susort\', \'suchw\'. Also:   sukeyword scalco	",
"									",
NULL};

/*
 * Credits: CWP, Baoniu Han, bhan@@dix.mines.edu, April 19th, 1998
 *	  Modified: Chris Stolk, 11 Dec 2005, - changed data input
 *		    to remove erroneous time delay.
 *	  Modified: CWP, John Stockwell 26 Sept 2006 - replaced Han's
 *	  "goto-loop" in two places with "do { }while loops".
 *	  Fixed it so that sx, gx, and scalco are honored.
 *
 *
 * Trace header fields accessed: ns, dt, delrt, d2
 * Trace header fields modified: ns, dt, delrt
 */

/**************** end self doc *******************************************/

/* Prototypes for subroutines used internally */
float *ricker(float Freq,float dt,int *Npoint);
void get_sx_gx(float *sx, float *gx);


segy tr;


int
main (int argc, char **argv)
{
	int L=10, Bz=0;	/*BIN number for determination of reference velocity.*/
	float c[101];
	float *V,P[100];
	float Sz=0;
	float Y[101];
	double a,a1,a2,theta,theta1,theta2;


	int nt;			/* number of time samples		*/
	int nz;			/* number of migrated depth samples	*/
	int nx;			/* number of horizontal samples	 */
	
	int nxshot;		/* number of shots to be migrated	*/
	int nxshot_orig;	/* first value of nxshot		*/
	int iz,iw,ix,it,ik;	/* loop counters 			*/
	int igx;		/* integerized gx value			*/
	int ntfft,nxfft;	/* fft size				*/
	int nw,truenw,nk;	/* number of wave number and frequency 	*/	

	int dip=45;		/* dip angle				*/

	float sx,gx;		/* x source and geophone location	*/
	float gxmin=0.0,gxmax=0.0;/* x source and geophone location	*/
        float min_sx_gx;        /* min(sx,gx)                           */

	float oldgx;		/* old gx position			*/
	float oldgxmin;		/* old gx position			*/
	float oldgxmax;		/* old gx position			*/
	float oldsx=0.0;	/* old sx position			*/
	int oldigx=0;		/* old value of integerized gx value	*/
	int oldisx=0;		/* old value of integerized sx value	*/

	int isx=0,nxo;		/* index for source and geophone	*/
	int ix1,ix2,ix3,ixshot,il,ir;/* dummy index			*/
	int lpad,rpad;	/* padding on both sides of the migrated section*/

	float *wl=NULL,*wtmp=NULL;
	float fmax;
	float f1,f2,f3,f4;
	int nf1,nf2,nf3,nf4;
	int ntw;

	float dt=0.004,dz;	/* time and depth sampling intervals 	*/
	float dw,dk;		/* wavenumber and frequency sampling interval */
	float fw,fk;		/* first wavenumber and frequency	*/
	float w,k;		/* wavenumber and frequency		*/
	float dx;		/* spatial sampling interval		*/
	float **p=NULL;
	float **cresult=NULL;	/* input, output data			*/

	float vmin,v1,v2,vmax;
	double kz1;
	double phase1;
	float **v=NULL,**vp=NULL;
	complex cshift1;
	complex *wlsp=NULL;
	complex **cp=NULL;
	complex **cp1=NULL;
	complex **cq=NULL;
	complex **cq1=NULL;
	complex ***cq2=NULL;
	complex ***cq3=NULL;	/* complex input,output			*/

	char *vfile="";		/* name of file containing velocities	*/
	FILE *vfp=NULL;		/* ... its file pointer			*/

	int verbose;		/* verbose flag				*/

	/* hook up getpar to handle the parameters */
	initargs(argc,argv);
	requestdoc(1);

	/* get required parameters */
	MUSTGETPARINT("nz",&nz);
	MUSTGETPARFLOAT("dz",&dz);
	MUSTGETPARSTRING("vfile", &vfile);
	MUSTGETPARINT("nxo",&nxo);
	MUSTGETPARINT("nxshot",&nxshot);

	/* get optional parameters */
	if (!getparfloat("fmax",&fmax)) fmax = 25.0;  
	if (!getparfloat("f1",&f1)) f1 = 10.0;
	if (!getparfloat("f2",&f2)) f2 = 20.0;
	if (!getparfloat("f3",&f3)) f3 = 40.0;
	if (!getparfloat("f4",&f4)) f4 = 50.0;

	if (!getparint("lpad",&lpad)) lpad=9999;
	if (!getparint("rpad",&rpad)) rpad=9999;
	if (!getparint("dip",&dip)) dip=65;

	if (!getparint("verbose",&verbose))     verbose = 0;

	/* allocate space */
	cresult = alloc2float(nz,nxo);
	vp=alloc2float(nxo,nz);

	/* load velocity file */
	vfp=efopen(vfile,"r");
	efread(vp[0],FSIZE,nz*nxo,vfp);
	efclose(vfp);

	/* zero out cresult array */
	memset((void *) cresult[0], 0, nxo*nz*FSIZE);

	/* save value of nxshot */
	nxshot_orig=nxshot;


		/* get info from first trace */
	if (!gettr(&tr))  err("can't get first trace");
	nt = tr.ns;
	get_sx_gx(&sx,&gx);
	min_sx_gx = MIN(sx,gx);
	sx = sx - min_sx_gx;
	gx = gx - min_sx_gx;


	/* let user give dt and/or dx from command line */
	if (!getparfloat("dt", &dt)) {
		if (tr.dt) { /* is dt field set? */
			dt = ((double) tr.dt)/1000000.0;
		} else { /* dt not set, assume 4 ms */
			dt = 0.004;
			warn("tr.dt not set, assuming dt=0.004");
		}
	}
	if (!getparfloat("dx",&dx)) {
		if (tr.d2) { /* is d2 field set? */
			dx = tr.d2;
		} else {
			dx = 1.0;
			warn("tr.d2 not set, assuming d2=1.0");
		}
	}

        checkpars();

	do {    /* begin loop over shots */

 
		/* determine frequency sampling interval */
		ntfft = npfar(nt);
		nw = ntfft/2+1;
		dw = 2.0*PI/(ntfft*dt);

		/* compute the index of the frequency to be migrated */
		fw=2.0*PI*f1;
		nf1=fw/dw+0.5;
		 
		fw=2.0*PI*f2;
		nf2=fw/dw+0.5;

		fw=2.0*PI*f3;
		nf3=fw/dw+0.5;

		fw=2.0*PI*f4;
		nf4=fw/dw+0.5;  

		/* the number of frequency to migrated */
		truenw=nf4-nf1+1;
		fw=0.0+nf1*dw;
		if (verbose)
			warn("nf1=%d nf2=%d nf3=%d nf4=%d nw=%d",nf1,nf2,nf3,nf4,truenw);

		/* allocate space */
		wl=alloc1float(ntfft);
		wlsp=alloc1complex(nw);

		/* generate the Ricker wavelet */
		wtmp=ricker(fmax,dt,&ntw);

		/* zero out wl[] array */
		memset((void *) wl, 0, ntfft*FSIZE);
	
		/* CHANGE BY CHRIS STOLK, Dec. 11, 2005 */
		/* The next two lines are the old code, */
		/* it is erroneous because the peak of  */
		/* the wavelet occurs at positive time  */
		/* instead of time zero. 		*/
		/*
		for(it=0;it<ntw;it++)
	  		wl[it]=wtmp[it];
		*/
		/* New code: we put in the wavelet in a centered fashion */ 
		for(it=0;it<ntw;it++) 
	  		wl[(it-ntw/2+ntfft) % ntfft]=wtmp[it];
		/* End of new code */

		free1float(wtmp);

		/* fourier transform in time */
		pfarc(-1,ntfft,wl,wlsp);

		/* allocate space */
		p = alloc2float(ntfft,nxo);
		cq = alloc2complex(nw,nxo);

		/* zero out p[][] array */
		memset((void *) p[0], 0, ntfft*nxo*FSIZE);

		/* initialize a number of items before looping over traces */
		nx = 0;
		igx=0;
		oldsx=sx;
		oldgx=gx;
		oldgxmax=gxmax;
		oldgxmin=gxmin;
		do { /* begin looping over traces within a shot gather */

			memcpy( (void *) p[igx], (const void *) tr.data,nt*FSIZE);
			/* get sx and gx */
			get_sx_gx(&sx,&gx);
			sx = (sx - min_sx_gx);
			gx = (gx - min_sx_gx);

			igx = gx/dx;
			if (igx==oldigx) 
			   warn("repeated igx!!! check dx or scalco value!!!");
			oldigx = igx;


			if(gxmin>gx)gxmin=gx;
			if(gxmax<gx)gxmax=gx;

			if(verbose)
				warn(" inside loop:  min_sx_gx %f isx %d igx %d gx %f sx %f",min_sx_gx,isx,igx,gx,sx);

			/* sx, gx must increase monotonically */
			if (!(oldsx <= sx) )
			 err("sx field must be monotonically increasing!");
			if (!(oldgx <= gx) )
			 err("gx field must be monotonically increasing!");

			++nx;
		} while(gettr(&tr) && sx==oldsx);
			
		isx=oldsx/dx;
		if (isx==oldisx) 
			warn("repeated isx!!! check dx or scalco value!!!");
		oldisx=isx;
		ixshot=isx;
		if(verbose) {
			warn("sx %f, gx %f , gxmin %f  gxmax %f nx %d",sx,gx,gxmin,gxmax, nx);
			warn("isx %d igx %d ixshot %d" ,isx,igx,ixshot);
		}



		/* transform the shot gather from time to frequency domain */
		pfa2rc(1,1,ntfft,nxo,p[0],cq[0]);


		/* compute the most left and right index for the migrated */
		/* section*/
		ix1=oldsx/dx;
		ix2=gxmin/dx;
		ix3=gxmax/dx;

		if(ix1>=ix3)ix3=ix1;
		if(ix1<=ix2)ix2=ix1;
		il=ix2;
		ir=ix3;

		ix2-=lpad;
		ix3+=rpad;
		if(ix2<0)ix2=0;
		if(ix3>nxo-1)ix3=nxo-1;

		/* the total traces to be migrated */
		nx=ix3-ix2+1;
		nw=truenw;

		/* determine wavenumber sampling (for complex to complex FFT) */
		nxfft = npfa(nx);
		nk = nxfft;
		dk = 2.0*PI/(nxfft*dx);
		fk = -PI/dx;

		/* allocate space for velocity profile within the aperature */
		v=alloc2float(nx,nz);   
	
		for(iz=0;iz<nz;iz++)
			for(ix=0;ix<nx;ix++)
				v[iz][ix]=vp[iz][ix+ix2];

				vmax=v[0][0];vmin=v[0][0];
	
		for(iz=0;iz<nz;++iz) {
			for(ix=0;ix<nx;++ix) {
	 			if(v[iz][ix]>=vmax) vmax=v[iz][ix];
	 			if(v[iz][ix]<=vmin) vmin=v[iz][ix];
			}
		}


		/* allocate space */
		cp = alloc2complex(nx,nw);
		cp1 = alloc2complex(nx,nw);

		/* transpose the frequency domain data from	*/
		/* data[ix][iw] to data[iw][ix] and apply a	*/
		/* Hamming at the same time			*/
		for (ix=0; ix<nx; ix++) {
			for (iw=0; iw<nw; iw++){
				float tmpp=0.0,tmppp=0.0;

				if(iw>=(nf1-nf1)&&iw<=(nf2-nf1)){
					tmpp=PI/(nf2-nf1);
					tmppp=tmpp*(iw-nf1)-PI;
					tmpp=0.54+0.46*cos(tmppp);
					cp[iw][ix]=crmul(cq[ix+ix2][iw+nf1],tmpp);
					} else {
						if(iw>=(nf3-nf1)&&iw<=(nf4-nf1)){ 
						tmpp=PI/(nf4-nf3);
						tmppp=tmpp*(iw-nf3);
						tmpp=0.54+0.46*cos(tmppp);
						cp[iw][ix]=crmul(cq[ix+ix2][iw+nf1],tmpp);
					} else {
						cp[iw][ix]=cq[ix+ix2][iw+nf1];}
					}
					cp1[iw][ix]=cmplx(0.0,0.0);
				}
			}

		for(iw=0;iw<nw;iw++){
			cp1[iw][ixshot-ix2]=wlsp[iw+nf1];
		}

		if(verbose) {
			warn("ixshot %d ix %d ix1 %d ix2 %d ix3 %d",ixshot,ix,ix1,ix2,ix3);
			warn("oldsx %f ",oldsx);
		}

			
		free2float(p);
		free2complex(cq);
		free1float(wl);
		free1complex(wlsp);

		cq=alloc2complex(nxfft,nw);
		cq1=alloc2complex(nxfft,nw);

		/* loops over depth */
		for(iz=0;iz<nz;++iz){

			/* the imaging condition */
			for(ix=0;ix<nx;ix++){
				for(iw=0,w=fw;iw<nw;w+=dw,iw++){   
					complex tmp;
					float ratio=10.0;
		
					if(fabs(ix+ix2-ixshot)*dx<ratio*iz*dz)
						tmp=cmul(cp[iw][ix],cp1[iw][ix]);
					else
						tmp=cmplx(0.0,0.0);  

					cresult[ix+ix2][iz]+=tmp.r/ntfft;
				}
			}

			for (ik=0; ik<nx; ++ik) {
				for (iw=0,w=fw; iw<nw;w+=dw, ++iw){
					cp[iw][ik]=cmul(cp[iw][ik],
							cexp(cmplx(0.0,-w*dz/v[iz][ik])));
					cp1[iw][ik]=cmul(cp1[iw][ik],
							cexp(cmplx(0.0,-w*dz/v[iz][ik])));
					cq[iw][ik] = ik%2 ? cneg(cp[iw][ik]) : cp[iw][ik];
					cq1[iw][ik] = ik%2 ? cneg(cp1[iw][ik]) : cp1[iw][ik];
				}
			}
	
			for (ik=nx; ik<nk; ++ik) {
				for (iw=0; iw<nw; ++iw) {
					cq[iw][ik] = cmplx(0.0,0.0);
					cq1[iw][ik] = cmplx(0.0,0.0);
				}
			}

		
			/* FFT to W-K domain */
			pfa2cc(-1,1,nk,nw,cq[0]);
			pfa2cc(-1,1,nk,nw,cq1[0]);
	
			/* The second time phase shift */
			v1=vmin;
			v2=vmax;
	
			if((v2-v1)/v1<0.01){
		
				for(ik=0,k=fk;ik<nk;++ik,k+=dk) {
					for(iw=0,w=fw;iw<nw;++iw,w+=dw){
			 
						if(w==0.0)
							w=1.0e-10/dt;
						kz1=1.0-pow(v1*k/w,2.0);
	
						if(kz1>=0.0){
							phase1 = -w*sqrt(kz1)*dz/v1+w*dz/v1;
							cshift1 = cmplx(cos(phase1), sin(phase1));
							cq[iw][ik] = cmul(cq[iw][ik],cshift1);
							cq1[iw][ik] = cmul(cq1[iw][ik],cshift1);
						} else {
							phase1 = -w*sqrt(-kz1)*dz/v1;
							cshift1=cexp(cmplx(phase1,w*dz/v1));
							cq[iw][ik] = cmul(cq[iw][ik],cshift1);
							cq1[iw][ik] = cmul(cq1[iw][ik],cshift1);
						}
					}		
				}
				pfa2cc(1,1,nk,nw,cq[0]);
				pfa2cc(1,1,nk,nw,cq1[0]);
	
				for(ix=0;ix<nx;++ix){
					for(iw=0;iw<nw;++iw){
						cq[iw][ix] = crmul( cq[iw][ix], 1.0/nxfft);
						cp[iw][ix] =ix%2 ? cneg(cq[iw][ix]) : cq[iw][ix];
						cq1[iw][ix] = crmul( cq1[iw][ix], 1.0/nxfft);
						cp1[iw][ix] =ix%2 ? cneg(cq1[iw][ix]) : cq1[iw][ix];
		 
					}
				}
			} else {
		
				for(ik=0;ik<=L;ik++)
					c[ik]=vmin+ik*1.0*(vmax-vmin)/((float) L);
			 
					memset((void *) p, 0, L*FSIZE);


		for(ix=0;ix<nx;ix++){
			for(ik=0;ik<L;ik++){
				if(((v[iz][ix]>=c[ik])
					&&(v[iz][ix]<c[ik+1]))
					||((ik==L-1)
					&&(v[iz][ix]==vmax))){
						P[ik]+=1.0/nx; break;
				}
			}
		}
		Sz=0.0;
		for(ik=0;ik<L;ik++) {
			if(P[ik]!=0.00) Sz=Sz-P[ik]*log(P[ik]);
		}

		Bz=exp(Sz)+0.5;
		Y[0]=0.0;
		Y[L]=1.0;
 
		for(ik=1;ik<L;ik++) {
			Y[ik]=0.0;
			for(ix=0;ix<ik;ix++)
				for(ix=0;ix<ik;ix++)
					Y[ik]=Y[ik]+P[ix];
		}
		 
		V=alloc1float(Bz+1);
		V[0]=vmin;
	
		for(ix=1;ix<=Bz;ix++){
			for(ik=0;ik<L;ik++){
				if((ix*1.0/Bz>Y[ik])&&(ix*1.0/Bz<=Y[ik+1])){	
					V[ix]=c[ik]+(ix*1.0/Bz-Y[ik])*(c[ik+1]-c[ik])/(Y[ik+1]-Y[ik]);
				break;
				}
			}
	
		}

	 
		 
		V[Bz]=V[Bz]*1.005;  
		cq2=ealloc3complex(nk,nw,Bz+1);
		cq3=ealloc3complex(nk,nw,Bz+1);

		for(ix=0;ix<Bz+1;ix++){
			for(iw=0,w=fw;iw<nw;++iw,w+=dw)
				for(ik=0,k=fk;ik<nk;++ik,k+=dk){

					if(w==0.0)w=1.0e-10/dt;

					kz1=1.0-pow(V[ix]*k/w,2.0);
					if(kz1>=0.00){
						phase1 =-w*sqrt(kz1)*dz/V[ix]+w*dz/V[ix];
						cshift1 = cexp(cmplx(0.0,phase1));
						cq2[ix][iw][ik] = cmul(cq[iw][ik],cshift1);
						cq3[ix][iw][ik] = cmul(cq1[iw][ik],cshift1);
	 
					} else {
						phase1 =-w*sqrt(-kz1)*dz/V[ix];
						cshift1 =cexp(cmplx(phase1,w*dz/V[ix]));
						cq2[ix][iw][ik] = cmul(cq[iw][ik],cshift1);
						cq3[ix][iw][ik] = cmul(cq1[iw][ik],cshift1);
		
					}

				}

		
				pfa2cc(1,1,nk,nw,cq2[ix][0]);
				pfa2cc(1,1,nk,nw,cq3[ix][0]);
	
				for(ik=0;ik<nx;++ik)
					for(iw=0,w=fw;iw<nw;w+=dw,++iw){
						float a=0.015,g=1.0;
							int I=10;
		
							if(ik<=I)g=exp(-a*(I-ik)*(I-ik));
							if(ik>=nx-I)g=exp(-a*(-nx+I+ik)*(-nx+I+ik));
							g=1.0;

							cq2[ix][iw][ik] = crmul( cq2[ix][iw][ik], g*1.0/nxfft);
							cq2[ix][iw][ik] =ik%2 ? cneg(cq2[ix][iw][ik]) : cq2[ix][iw][ik];
							cq3[ix][iw][ik] = crmul( cq3[ix][iw][ik], g*1.0/nxfft);
							cq3[ix][iw][ik] =ik%2 ? cneg(cq3[ix][iw][ik]) : cq3[ix][iw][ik];
	 
						}
					}

					for(ix=0;ix<nx;++ix) {
						for(ik=0;ik<Bz;++ik){
	
							if(((v[iz][ix]>=V[ik])&&(v[iz][ix]<V[ik+1]))) {


								v1=V[ik];v2=V[ik+1];
		
						for(iw=0,w=fw;iw<nw;w+=dw,++iw){

							a1=cq2[ik][iw][ix].r;
							a2=cq2[ik+1][iw][ix].r;
							theta1=cq2[ik][iw][ix].i ;theta2=cq2[ik+1][iw][ix].i;  
		
							a= a1*(v2-v[iz][ix])/(v2-v1)+a2*(v[iz][ix]-v1)/(v2-v1);
							theta=theta1*(v2-v[iz][ix])/(v2-v1)+theta2*(v[iz][ix]-v1)/(v2-v1);
							cp[iw][ix] =cmplx(a,theta);
	 
		
							a1=cq3[ik][iw][ix].r;a2=cq3[ik+1][iw][ix].r;
							theta1=cq3[ik][iw][ix].i ;
							theta2=cq3[ik+1][iw][ix].i;
	
							a= a1*(v2-v[iz][ix])/(v2-v1)+a2*(v[iz][ix]-v1)/(v2-v1);
							theta=theta1*(v2-v[iz][ix])/(v2-v1)+theta2*(v[iz][ix]-v1)/(v2-v1);
							cp1[iw][ix] =cmplx(a,theta);
		
		
								}

							break;
		
							}	
						}
					}

				free3complex(cq2);
				free3complex(cq3);
				free1float(V);
		
			}
		
				

		}

		free2complex(cp);
		free2complex(cp1);
		free2complex(cq);
		free2complex(cq1);
		free2float(v);

		--nxshot;
	} while(nxshot);

        /* restore header fields and write output */
        for(ix=0; ix<nxo; ix++){
                tr.ns = nz;
                tr.d1 = dz;
                tr.d2 = dx;
                tr.offset = 0;
                tr.cdp = tr.tracl = ix;
                memcpy( (void *) tr.data, (const void *) cresult[ix],nz*FSIZE);
                puttr(&tr);
        }

	return(CWP_Exit());	

}

float * ricker(float Freq,float dt,int *Npoint)
{
	int i;	/* they are the dummy counter*/
	float Bpar,t,u,*Amp;
	int Np1,N;
	
	if(Freq==0.0)Freq=30.0;
	if(dt==0.0)dt=0.004;
	Bpar=sqrt(6.0)/(PI*Freq);
	N=ceil(1.35*Bpar/dt);
	Np1=N;
	*Npoint=2*N+1;
	 
	Amp=alloc1float(*Npoint);
	
	Amp[Np1]=1.0;
  
	for(i=1;i<=N;i++) {
		t=dt*(float)i;
		u=2.0*sqrt(6.0)*t/Bpar;
		Amp[Np1+i]=Amp[Np1-i]=0.5*(2.0-u*u)*exp(-u*u/4.0);
	}

	return Amp;

}

void get_sx_gx(float *sx, float *gx)
{ 
/*****************************************************************************
get_sx_gx - get sx and gx from headrs
*****************************************************************************/

	float sy;		/* source coordinates */
	float gy;		/* geophone coordinates */

		if (tr.scalco) { /* if tr.scalco is set, apply value */
			if (tr.scalco>0) {
				*sx = (float) tr.sx*tr.scalco;
				*gx = (float) tr.gx*tr.scalco;
				sy = (float) tr.sy*tr.scalco;
				gy = (float) tr.gy*tr.scalco;
			} else { /* if tr.scalco is negative divide */
				*sx = (float) tr.sx/ABS(tr.scalco);
				*gx = (float) tr.gx/ABS(tr.scalco);
				sy = (float) tr.sy/ABS(tr.scalco);
				gy = (float) tr.gy/ABS(tr.scalco);
			}

		} else {
				*sx = (float) tr.sx;
				*gx = (float) tr.gx;
				sy = (float) tr.sy;
				gy = (float) tr.gy;
		}

		
		/* use pythagorean theorem to remap radial direction */
		/* to x-direction */
		*sx = SGN(*sx-sy)*sqrt((*sx)*(*sx) + sy*sy);
		*gx = SGN(*gx-gy)*sqrt((*gx)*(*gx) + gy*gy);

	return;
}
@


1.16
log
@copyright
@
text
@d226 2
@


1.15
log
@hermann Jaramillo's input
@
text
@d1 4
a4 1
/* SUMIGPREPSPI: $Vision: 1.00 $ ; $Date: 2008/10/30 21:42:34 $*/
@


1.14
log
@implementd Xiaolin Lu's fixes
which include explicit casts and a slight change in the order
which sx and gx values are read.
@
text
@d1 1
a1 1
/* SUMIGPREPSPI: $Vision: 1.00 $ ; $Date: 2006/12/13 16:55:11 $*/
d341 2
a342 2
		ix2=oldgxmin/dx;
		ix3=oldgxmax/dx;
@


1.13
log
@added comments regarding v(x,z) versus v(z,x) arrays
@
text
@d1 1
a1 1
/* SUMIGPREPSPI: $Vision: 1.00 $ ; $Date: 2006/11/07 22:58:42 $*/
d295 6
a305 1
			memcpy( (void *) p[igx], (const void *) tr.data,nt*FSIZE);
a311 4
			/* get sx and gx */
			get_sx_gx(&sx,&gx);
			sx = (sx - min_sx_gx);
			gx = (gx - min_sx_gx);
d712 4
a715 4
				*sx = tr.sx*tr.scalco;
				*gx = tr.gx*tr.scalco;
				sy = tr.sy*tr.scalco;
				gy = tr.gy*tr.scalco;
d717 4
a720 4
				*sx = tr.sx/ABS(tr.scalco);
				*gx = tr.gx/ABS(tr.scalco);
				sy = tr.sy/ABS(tr.scalco);
				gy = tr.gy/ABS(tr.scalco);
d724 4
a727 4
				*sx = tr.sx;
				*gx = tr.gx;
				sy = tr.sy;
				gy = tr.gy;
@


1.12
log
@changed    memset( .., (int) '\0',...) to memset( .., 0,..) as per suggestion of Marion Zhu and Reg Beardsley
@
text
@d1 1
a1 1
/* SUMIGPREPSPI: $Vision: 1.00 $ ; $Date: 2006/10/31 22:01:49 $*/
d49 4
@


1.11
log
@goto loops removed, IO improved to take into account nonzero sy and or
nonzero gy.
@
text
@d1 1
a1 1
/* SUMIGPREPSPI: $Vision: 1.00 $ ; $Date: 2006/10/17 18:59:13 $*/
d186 1
a186 1
	memset((void *) cresult[0], (int) '0', nxo*nz*FSIZE);
d254 1
a254 1
		memset((void *) wl, (int) '0', ntfft*FSIZE);
d280 1
a280 1
		memset((void *) p[0], (int) '0', ntfft*nxo*FSIZE);
d507 1
a507 1
					memset((void *) p, (int) '0', L*FSIZE);
@


1.10
log
@MUST...
@
text
@d1 1
a1 1
/* SUMIGPREPSPI: $Vision: 1.00 $ ; $Date: 2006/09/28 23:19:24 $*/
d113 2
d291 5
a296 1
			igx = gx/dx;
d318 3
@


1.9
log
@changed goto--loop to do { } while, fixed program to honor sx,gx,scalco
@
text
@d1 1
a1 1
/* SUMIGPREPSPI: $Vision: 1.00 $ ; $Date: 2005/12/22 00:54:17 $*/
a6 1
/* #include <time.h> */
a116 1
	int flag=1;	/* feet or meters				*/
d154 7
a161 7
	if (!getparint("nz",&nz)) err("nz must be specified");
	if (!getparfloat("dz",&dz)) err("dz must be specified");
	if (!getparstring("vfile", &vfile)) err("vfile must be specified");

	if (!getparint("nxo",&nxo)) err("nxo must be specified");
	if (!getparint("nxshot",&nxshot)) err("nshot must be specified");

a169 1
	if (!getparint("flag",&flag)) flag=1;
a413 6
		/* if the horizontal spacing interval is in feet,	*/
		/* convert it to meter					*/
		if(!flag)
			dx*=0.3048;


@


1.8
log
@Chris Stolk's modifications
@
text
@d1 1
a1 1
/* SUMIGPREPSPI: $Vision: 1.00 $ ; $Date: 2003/08/19 17:31:42 $*/
d14 1
a14 1
"			interpolation MIGration.			",
d34 1
d50 7
d61 5
d75 3
a77 1
float * ricker(float Freq,float dt,int *Npoint);
d82 2
a83 4
/* static time_t t1,t2; */

int main (int argc, char **argv)

d85 5
a89 2
	int L=10, Bz=0;	/*BIN number for determination of the reference velocity.*/
	float c[101], *V,P[100],Sz=0,Y[101];
d93 26
a118 14
	int nt;			/* number of time samples */
	int nz;			/* number of migrated depth samples */
	int nx,nxshot,oldsx;	/* number of midpoints 	*/
	int iz,iw,ix,it,ik;	/* loop counters 	*/
	int ntfft,nxfft;	/* fft size		*/
	int nw,truenw,nk;	/* number of wave number and frequency */	
	int dip=45;

	/*prestack goes here*/
	float sx,gxmin,gxmax;
	int isx,nxo,ifx=0;	
	int ix1,ix2,ix3,ixshot,il,ir;
	int lpad,rpad;
	int flag=1;
d120 1
a120 1
	float *wl,*wtmp;
d126 1
a126 1
	float dt=0.004,dz;	/* time sampling interval 	*/
d128 6
a133 4
	float fw,fk;		/* first wavenumber and frequency */
	float w,k;		/* wavenumber and frequency	*/
	float dx;		/* spatial sampling interval	*/
	float **p,**cresult;	/* input, output data		*/
d137 1
a137 1
	float **v,**vp;
d139 12
a150 3
	complex *wlsp,**cp,**cp1,**cq,**cq1,***cq2,***cq3;/*complex input,output*/
	char *vfile="";		/* name of file containing velocities */
	FILE *vfp;
d160 1
d163 1
d169 1
d175 3
d181 1
a181 1
	/*load velicoty file*/
d186 5
a190 4
	for(ix=0;ix<nxo;ix++)
	for(iz=0;iz<nz;iz++)
	cresult[ix][iz]=0.0;
			
a191 3
	/* get info from first trace */
loop:
/*	time(&t1); */
d193 1
d196 5
d220 2
a221 4
	sx=tr.sx;
	isx=sx/dx;
	gxmin=gxmax=tr.gx;
	oldsx=sx;
d223 8
a230 8
	/* determine frequency sampling interval*/
	ntfft = npfar(nt);
	nw = ntfft/2+1;
	dw = 2.0*PI/(ntfft*dt);

	/*compute the index of the frequency to be migrated*/
	fw=2.0*PI*f1;
	nf1=fw/dw+0.5;
d232 2
a233 2
	fw=2.0*PI*f2;
	nf2=fw/dw+0.5;
d235 2
a236 2
	fw=2.0*PI*f3;
	nf3=fw/dw+0.5;
d238 2
a239 2
	fw=2.0*PI*f4;
	nf4=fw/dw+0.5;  
d241 50
a290 4
	/*the number of frequency to migrated*/
	truenw=nf4-nf1+1;
	fw=0.0+nf1*dw;
	warn("nf1=%d nf2=%d nf3=%d nf4=%d nw=%d",nf1,nf2,nf3,nf4,truenw);
d292 2
a293 3
	/* allocate space */
	wl=alloc1float(ntfft);
	wlsp=alloc1complex(nw);
d295 2
a296 2
	/*generate the Ricker wavelet*/
	wtmp=ricker(fmax,dt,&ntw);
d298 12
a309 15
	for(it=0;it<ntfft;it++)
	wl[it]=0.0;  
	
	/* CHANGE BY CHRIS STOLK, Dec. 11, 2005 */
	/* The next two lines are the old code, it is erroneous because the 
	   peak of the wavelet occurs at positive time instead of time zero. */
	/*
	for(it=0;it<ntw;it++)
	  wl[it]=wtmp[it];
	*/
	/* New code: we put in the wavelet in a centered fashion */ 
	for(it=0;it<ntw;it++) 
	  wl[(it-ntw/2+ntfft) % ntfft]=wtmp[it];
	/* End of new code */
	free1float( wtmp);
d311 9
a319 39
	pfarc(-1,ntfft,wl,wlsp);

	/* allocate space */
	p = alloc2float(ntfft,nxo);
	cq = alloc2complex(nw,nxo);
	

	for (ix=0; ix<nxo; ix++)
		for (it=0; it<ntfft; it++)
			p[ix][it] = 0.0;


	/*read in a single shot gather*/
	if (tr.gx < 0 ) {
		ix=tr.gx/dx + nxo;
	} else {
		ix=tr.gx/dx ;
	}

	memcpy( (void *) p[ix], (const void *) tr.data,nt*FSIZE);

	nx = 0;

	while(gettr(&tr)){
			int igx;

			if(tr.sx!=oldsx){ efseeko(stdin,(off_t)(-240-nt*4),SEEK_CUR); break;}
			if (tr.gx < 0 ) {
				igx=tr.gx/dx + nxo;
			} else {
				igx=tr.gx/dx ;
			}
			memcpy( (void *) p[igx], (const void *) tr.data,nt*FSIZE);

			if(gxmin>tr.gx)gxmin=tr.gx;
			if(gxmax<tr.gx)gxmax=tr.gx;
			nx++;
			oldsx=tr.sx;
			}
a320 1
	warn("sx %f , gxmin %f  gxmax %f",sx,gxmin,gxmax);
a321 2
	/*transform the shot gather from time to frequency domain*/
	pfa2rc(1,1,ntfft,nxo,p[0],cq[0]);
d323 2
a325 4
	/*compute the most left and right index for the migrated section*/
	ix1=sx/dx;
	ix2=gxmin/dx;
	ix3=gxmax/dx;
d327 5
a331 4
	if(ix1>=ix3)ix3=ix1;
	if(ix1<=ix2)ix2=ix1;
	il=ix2;
	ir=ix3;
d333 4
a336 4
	ix2-=lpad;
	ix3+=rpad;
	if(ix2<0)ix2=0;
	if(ix3>nxo-1)ix3=nxo-1;
d338 4
a341 3
	/*the total traces to be migrated*/
	nx=ix3-ix2+1;
	nw=truenw;
d343 3
a345 5
	/* determine wavenumber sampling (for complex to complex FFT) */
	nxfft = npfa(nx);
	nk = nxfft;
	dk = 2.0*PI/(nxfft*dx);
	fk = -PI/dx;
d347 5
d353 2
a354 2
	/*allocate space for velocity profile within the aperature*/
	v=alloc2float(nx,nz);   
d356 3
a358 4
	for(iz=0;iz<nz;iz++)
	for(ix=0;ix<nx;ix++){
	v[iz][ix]=vp[iz][ix+ix2];
	}
d360 1
a360 1
	vmax=v[0][0];vmin=v[0][0];
d362 6
a367 6
	for(iz=0;iz<nz;++iz)
	for(ix=0;ix<nx;ix++)
	{
	 if(v[iz][ix]>=vmax) vmax=v[iz][ix];
	 if(v[iz][ix]<=vmin) vmin=v[iz][ix];
	}
d370 28
a397 24
	/*allocate space*/
	cp = alloc2complex(nx,nw);
	cp1 = alloc2complex(nx,nw);

	/*transpose the frequency domain data from data[ix][iw] to data[iw][ix] and
	apply a Hamming at the same time*/

	for (ix=0; ix<nx; ix++)
	for (iw=0; iw<nw; iw++){

	float tmpp=0.0,tmppp=0.0;

	if(iw>=(nf1-nf1)&&iw<=(nf2-nf1)){
	tmpp=PI/(nf2-nf1);tmppp=tmpp*(iw-nf1)-PI;tmpp=0.54+0.46*cos(tmppp);
	cp[iw][ix]=crmul(cq[ix+ix2][iw+nf1],tmpp);}
	else{
	if(iw>=(nf3-nf1)&&iw<=(nf4-nf1)){
	tmpp=PI/(nf4-nf3);tmppp=tmpp*(iw-nf3);tmpp=0.54+0.46*cos(tmppp);
	cp[iw][ix]=crmul(cq[ix+ix2][iw+nf1],tmpp);}
	else{
	cp[iw][ix]=cq[ix+ix2][iw+nf1];}
	}
	cp1[iw][ix]=cmplx(0.0,0.0);
	}
d399 3
a401 3
	ix=sx/dx-ifx;
	ixshot=ix;
	warn("ix %d",ix);
d403 4
a406 3
	for(iw=0;iw<nw;iw++){
	cp1[iw][ix-ix2]=wlsp[iw+nf1];
	}
d409 27
a435 28
	free2float(p);
	free2complex(cq);
	free1float(wl);
	free1complex(wlsp);

	cq=alloc2complex(nxfft,nw);
	cq1=alloc2complex(nxfft,nw);

	/*if the horizontal spacing interval is in feet, convert it to meter*/
	if(!flag)
	dx*=0.3048;


	/* loops over depth */
	for(iz=0;iz<nz;++iz){

	/*the imaging condition*/
	for(ix=0;ix<nx;ix++){
	for(iw=0,w=fw;iw<nw;w+=dw,iw++){   
		complex tmp;
		float ratio=10.0;
		
		if(fabs(ix+ix2-ixshot)*dx<ratio*iz*dz)
		tmp=cmul(cp[iw][ix],cp1[iw][ix]);
		else tmp=cmplx(0.0,0.0);  
		cresult[ix+ix2][iz]+=tmp.r/ntfft;
	}
	}
d437 3
a439 17
/* anothe imaging condition, slightly different from the above one, but quite
slow*/
	
/*
	for(iw=0,w=fw;iw<nw;w+=dw,iw++){
		float kk=0.0;
		complex tmp;
		float ratio=1.5; 
		if(dip<80)ratio=1.5;
		else ratio=1.5;
	
		for(ix=0;ix<nx;ix++){	
		kk+=(pow(cp1[iw][ix].i,2.0)+pow(cp1[iw][ix].r,2.0))/nx;
		}
	 
		for(ix=0;ix<nx;ix++){
		tmp=cmul(cp[iw][ix],cp1[iw][ix]);
d441 10
a450 19
		if(fabs(ix-ixshot)*dx<ratio*iz*dz||ixshot-ix<0 )

		tmp=crmul(tmp,1.0/(kk+1.0e-10));
  
		else tmp=cmplx(0.0,0.0);
		
		cresult[ix+ix2][iz]+=tmp.r/ntfft;
	
		}
		}
*/	

	for (ik=0; ik<nx; ++ik)
	for (iw=0,w=fw; iw<nw;w+=dw, ++iw){
	cp[iw][ik]=cmul(cp[iw][ik],cexp(cmplx(0.0,-w*dz/v[iz][ik])));
	cp1[iw][ik]=cmul(cp1[iw][ik],cexp(cmplx(0.0,-w*dz/v[iz][ik])));
	cq[iw][ik] = ik%2 ? cneg(cp[iw][ik]) : cp[iw][ik];
	cq1[iw][ik] = ik%2 ? cneg(cp1[iw][ik]) : cp1[iw][ik];
		}
d452 5
a456 5
		for (ik=nx; ik<nk; ++ik)
			for (iw=0; iw<nw; ++iw)
			{
			cq[iw][ik] = cmplx(0.0,0.0);
			cq1[iw][ik] = cmplx(0.0,0.0);
d460 1
a460 1
		/* FFT to W-K domain */
d462 1
a462 1
		pfa2cc(-1,1,nk,nw,cq1[0]);
d464 3
a466 3
	/* The second time phase shift */
	v1=vmin;
	v2=vmax;
d468 1
a468 1
	if((v2-v1)/v1<0.01){
d470 2
a471 2
	for(ik=0,k=fk;ik<nk;++ik,k+=dk) 
		for(iw=0,w=fw;iw<nw;++iw,w+=dw){
d473 26
a498 26
		if(w==0.0)w=1.0e-10/dt;

		kz1=1.0-pow(v1*k/w,2.0);
	
		if(kz1>=0.0){
		phase1 = -w*sqrt(kz1)*dz/v1+w*dz/v1;
		cshift1 = cmplx(cos(phase1), sin(phase1));
		cq[iw][ik] = cmul(cq[iw][ik],cshift1);
		cq1[iw][ik] = cmul(cq1[iw][ik],cshift1);
		}
		else{
		phase1 = -w*sqrt(-kz1)*dz/v1;
		cshift1=cexp(cmplx(phase1,w*dz/v1));
		cq[iw][ik] = cmul(cq[iw][ik],cshift1);
		cq1[iw][ik] = cmul(cq1[iw][ik],cshift1);
		}
	}		
	pfa2cc(1,1,nk,nw,cq[0]);
	pfa2cc(1,1,nk,nw,cq1[0]);
	
	for(ix=0;ix<nx;++ix)
		for(iw=0;iw<nw;++iw){
		cq[iw][ix] = crmul( cq[iw][ix], 1.0/nxfft);
		cp[iw][ix] =ix%2 ? cneg(cq[iw][ix]) : cq[iw][ix];
		cq1[iw][ix] = crmul( cq1[iw][ix], 1.0/nxfft);
		cp1[iw][ix] =ix%2 ? cneg(cq1[iw][ix]) : cq1[iw][ix];
d500 3
a502 3
		}
	}
	else{
d504 2
a505 2
	for(ik=0;ik<=L;ik++)
	c[ik]=vmin+ik*1.0*(vmax-vmin)/(L*1.0);
d507 1
a507 5
	for(ik=0;ik<L;ik++)
	{
	P[ik]=0.0;
	}
	 
d511 7
a517 3
		for(ik=0;ik<L;ik++){
			if(((v[iz][ix]>=c[ik])&&(v[iz][ix]<c[ik+1]))||((ik==L-1)&&(v[iz][ix]==vmax))){
			P[ik]+=1.0/nx; break;
d520 3
a523 4
	Sz=0.0;
	for(ik=0;ik<L;ik++)
	{if(P[ik]!=0.00) Sz=Sz-P[ik]*log(P[ik]);
	}
d525 3
a527 2
	Bz=exp(Sz)+0.5;
	Y[0]=0.0; Y[L]=1.0;
d529 6
a534 6
	for(ik=1;ik<L;ik++)
	{Y[ik]=0.0;
	for(ix=0;ix<ik;ix++)
	for(ix=0;ix<ik;ix++)
	Y[ik]=Y[ik]+P[ix];
	}
d536 10
a545 3
	V=alloc1float(Bz+1);
	V[0]=vmin;

a546 5
	for(ix=1;ix<=Bz;ix++){
	for(ik=0;ik<L;ik++){
		if((ix*1.0/Bz>Y[ik])&&(ix*1.0/Bz<=Y[ik+1])){	
		V[ix]=c[ik]+(ix*1.0/Bz-Y[ik])*(c[ik+1]-c[ik])/(Y[ik+1]-Y[ik]);
		break;
a547 3
	}
	
	}
d551 16
a566 16
	V[Bz]=V[Bz]*1.005;  
	cq2=ealloc3complex(nk,nw,Bz+1);
	cq3=ealloc3complex(nk,nw,Bz+1);

	for(ix=0;ix<Bz+1;ix++){
		for(iw=0,w=fw;iw<nw;++iw,w+=dw)
		for(ik=0,k=fk;ik<nk;++ik,k+=dk){

		if(w==0.0)w=1.0e-10/dt;

		kz1=1.0-pow(V[ix]*k/w,2.0);
		if(kz1>=0.00){
			phase1 =-w*sqrt(kz1)*dz/V[ix]+w*dz/V[ix];
			cshift1 = cexp(cmplx(0.0,phase1));
			cq2[ix][iw][ik] = cmul(cq[iw][ik],cshift1);
			cq3[ix][iw][ik] = cmul(cq1[iw][ik],cshift1);
d568 5
a572 6
			}
		else{
		phase1 =-w*sqrt(-kz1)*dz/V[ix];
		cshift1 =cexp(cmplx(phase1,w*dz/V[ix]));
		cq2[ix][iw][ik] = cmul(cq[iw][ik],cshift1);
		cq3[ix][iw][ik] = cmul(cq1[iw][ik],cshift1);
d574 1
a574 1
		}
d576 1
a576 1
	}
d579 2
a580 2
	pfa2cc(1,1,nk,nw,cq2[ix][0]);
	pfa2cc(1,1,nk,nw,cq3[ix][0]);
d582 13
a594 13
	for(ik=0;ik<nx;++ik)
		for(iw=0,w=fw;iw<nw;w+=dw,++iw){
		float a=0.015,g=1.0;
		int I=10;
		
		if(ik<=I)g=exp(-a*(I-ik)*(I-ik));
		if(ik>=nx-I)g=exp(-a*(-nx+I+ik)*(-nx+I+ik));
		g=1.0;

		cq2[ix][iw][ik] = crmul( cq2[ix][iw][ik], g*1.0/nxfft);
		cq2[ix][iw][ik] =ik%2 ? cneg(cq2[ix][iw][ik]) : cq2[ix][iw][ik];
		cq3[ix][iw][ik] = crmul( cq3[ix][iw][ik], g*1.0/nxfft);
		cq3[ix][iw][ik] =ik%2 ? cneg(cq3[ix][iw][ik]) : cq3[ix][iw][ik];
d596 2
a597 2
		}
	}		
d599 2
a600 2
	for(ix=0;ix<nx;++ix)
	for(ik=0;ik<Bz;++ik){
d602 1
a602 1
	if(((v[iz][ix]>=V[ik])&&(v[iz][ix]<V[ik+1]))) {
d605 1
a605 1
		v1=V[ik];v2=V[ik+1];
d607 1
a607 1
		for(iw=0,w=fw;iw<nw;w+=dw,++iw){
d609 3
a611 2
		a1=cq2[ik][iw][ix].r;a2=cq2[ik+1][iw][ix].r;
		theta1=cq2[ik][iw][ix].i ;theta2=cq2[ik+1][iw][ix].i;  
d613 3
a615 3
		a= a1*(v2-v[iz][ix])/(v2-v1)+a2*(v[iz][ix]-v1)/(v2-v1);
		theta=theta1*(v2-v[iz][ix])/(v2-v1)+theta2*(v[iz][ix]-v1)/(v2-v1);
		cp[iw][ix] =cmplx(a,theta);
d618 3
a620 2
		a1=cq3[ik][iw][ix].r;a2=cq3[ik+1][iw][ix].r;
		theta1=cq3[ik][iw][ix].i ;theta2=cq3[ik+1][iw][ix].i;
d622 3
a624 3
		a= a1*(v2-v[iz][ix])/(v2-v1)+a2*(v[iz][ix]-v1)/(v2-v1);
		theta=theta1*(v2-v[iz][ix])/(v2-v1)+theta2*(v[iz][ix]-v1)/(v2-v1);
		cp1[iw][ix] =cmplx(a,theta);
d627 1
a627 1
		}
d629 1
a629 1
	break;
d631 3
a633 2
	}	
	}
d635 3
a637 3
	free3complex(cq2);
	free3complex(cq3);
	free1float(V);
d639 1
a639 1
}
d643 1
a643 7
}

free2complex(cp);
free2complex(cp1);
free2complex(cq);
free2complex(cq1);
free2float(v);
d645 19
a663 21
nxshot--;

/*
time(&t2);
warn("\n %d nxshot has been finished in %f seconds",nxshot,difftime(t2,t1));
*/

	if(nxshot)goto loop;


	/* restore header fields and write output */
	for(ix=0; ix<nxo; ix++){
		tr.ns = nz ;
		tr.dt = dz*1000000.0 ;
		tr.d2 = dx;
		tr.offset = 0; 
		tr.cdp = tr.tracl = ix;
		memcpy( (void *) tr.data, (const void *) cresult[ix],nz*FSIZE);
		puttr(&tr);
	}
	
a668 2


d671 10
a680 10
int i;	/* they are the dummy counter*/
float Bpar,t,u,*Amp;
int Np1,N;
	
if(Freq==0.0)Freq=30.0;
if(dt==0.0)dt=0.004;
Bpar=sqrt(6.0)/(PI*Freq);
N=ceil(1.35*Bpar/dt);
Np1=N;
*Npoint=2*N+1;
d682 1
a682 1
Amp=alloc1float(*Npoint);
d684 1
a684 1
Amp[Np1]=1.0;
d686 8
a693 5
for(i=1;i<=N;i++)
{
t=dt*(float)i;
u=2.0*sqrt(6.0)*t/Bpar;
Amp[Np1+i]=Amp[Np1-i]=0.5*(2.0-u*u)*exp(-u*u/4.0);
d696 28
a723 1
return Amp;
d725 7
a732 1

@


1.7
log
@fix ix and igx  calculation
@
text
@d209 4
d214 6
a219 1
	wl[it]=wtmp[it];
@


1.6
log
@y.
@
text
@d1 1
a1 1
/* SUMIGPREPSPI: $Vision: 1.00 $ ; $Date: 2003/06/09 16:17:07 $*/
d226 6
a231 1
	ix=tr.gx/dx;
d240 5
a244 1
			igx=tr.gx/dx;
@


1.5
log
@9 June 2003
@
text
@d1 1
a1 1
/* SUMIGPREPSPI: $Vision: 1.00 $ ; $Date: 2000/09/25 20:38:38 $*/
d28 1
a28 1
" Fmax=25	the peak frequency of Ricker wavelet used as source wavelet",
d93 1
a93 1
	float Fmax=25;
d123 1
a123 1
	if (!getparfloat("Fmax",&Fmax)) err("Fmax must be specified");  
d204 1
a204 1
	wtmp=ricker(Fmax,dt,&ntw);
@


1.4
log
@updated selfdoc to read a bit clearer
@
text
@d1 1
a1 1
/* SUMIGPREPSPI: $Vision: 1.00 $ ; $Date: 2000/09/22 19:32:49 $*/
d234 1
a234 1
			if(tr.sx!=oldsx){ fseek(stdin,(long)(-240-nt*4),SEEK_CUR); break;}
d615 1
a615 1
	return EXIT_SUCCESS;	
@


1.3
log
@removed timing stuff
@
text
@d1 1
a1 1
/* SUMIGPREPSPI: $Vision: 1.00 $ ; $Date: 1998/05/04 18:16:33 $*/
d12 37
a48 30
"                                                                       ",
"SUMIGPREPSPI --- The 2-D prestack commom-shot phase-shift-plus 	",
"                      interpolation migration.		       		",
"Usage:                                                                 ",
"sumigprepspi <indata >outfile [parameters] 	                        ", 
"                                                                       ",
"Required Parameters:                                                   ",  
"                                                                       ",
"nxo=           number of total horizontal output samples               ",
"nxshot=        number of shot gathers to be migrated                   ",
"nz=            number of depth sapmles                                 ",
"dx=            horizontal sampling interval                            ",   
"dz=            depth sampling interval                                 ",
"vfile=         velocity profile, it must be binary format.             ",
"The structure of such a file is vfile[iz][ix], the x-direction is the  ",   
"fastest direction instead of z-direction, such a structure is quite    ",
"convenient for the downward continuation type migration algorithm.     ",
"Since most of the velocity file is in vfile[ix][iz] structure, you can ",
"use 'transp' in SU to transpose them into vfile[iz][ix] structure.     ",
"                                                                       ",  
"Optional Parameters:                                                   ",
"                                                                       ",
"                                                                       ",
"Fmax=25        the peak frequency of Ricker wavelet used as source wavelet",
"                                                                       ",
"f1=5,f2=10,f3=40,f4=50         frequencies to build a Hamming window   ",
"                                                                       ",
"lpad=9999,rpad=9999            number of zero traces padded on both    ",
"sides of depth section to determine the migration aperature, the default", 
"values are using the full aperature.                                   ",
d72 3
a74 3
        int L=10, Bz=0;	/*BIN number for determination of the reference velocity.*/
        float c[101], *V,P[100],Sz=0,Y[101];
        double a,a1,a2,theta,theta1,theta2;
d93 1
a93 1
        float Fmax=25;
d104 1
a104 1
        float vmin,v1,v2,vmax;
d117 15
a131 15
        /* get optional parameters */
        if (!getparint("nz",&nz)) err("nz must be specified");
        if (!getparfloat("dz",&dz)) err("dz must be specified");
        if (!getparstring("vfile", &vfile)) err("vfile must be specified");
        if (!getparint("nxo",&nxo)) err("nxo must be specified");
        if (!getparint("nxshot",&nxshot)) err("nshot must be specified");
        if (!getparfloat("Fmax",&Fmax)) err("Fmax must be specified");  
        if (!getparfloat("f1",&f1)) f1 = 10.0;
        if (!getparfloat("f2",&f2)) f2 = 20.0;
        if (!getparfloat("f3",&f3)) f3 = 40.0;
        if (!getparfloat("f4",&f4)) f4 = 50.0;
        if (!getparint("lpad",&lpad)) lpad=9999;
        if (!getparint("rpad",&rpad)) rpad=9999;
        if (!getparint("flag",&flag)) flag=1;
        if (!getparint("dip",&dip)) dip=65;
d176 52
a227 52
        /* determine frequency sampling interval*/
        ntfft = npfar(nt);
        nw = ntfft/2+1;
        dw = 2.0*PI/(ntfft*dt);

        /*compute the index of the frequency to be migrated*/
        fw=2.0*PI*f1;
        nf1=fw/dw+0.5;
                 
        fw=2.0*PI*f2;
        nf2=fw/dw+0.5;

        fw=2.0*PI*f3;
        nf3=fw/dw+0.5;

        fw=2.0*PI*f4;
        nf4=fw/dw+0.5;  

        /*the number of frequency to migrated*/
        truenw=nf4-nf1+1;
        fw=0.0+nf1*dw;
        warn("nf1=%d nf2=%d nf3=%d nf4=%d nw=%d",nf1,nf2,nf3,nf4,truenw);

        /* allocate space */
        wl=alloc1float(ntfft);
        wlsp=alloc1complex(nw);

        /*generate the Ricker wavelet*/
        wtmp=ricker(Fmax,dt,&ntw);

        for(it=0;it<ntfft;it++)
        wl[it]=0.0;  
        
        for(it=0;it<ntw;it++)
        wl[it]=wtmp[it];
        free1float( wtmp);

        pfarc(-1,ntfft,wl,wlsp);

        /* allocate space */
        p = alloc2float(ntfft,nxo);
        cq = alloc2complex(nw,nxo);
	

        for (ix=0; ix<nxo; ix++)
                for (it=0; it<ntfft; it++)
                        p[ix][it] = 0.0;


        /*read in a single shot gather*/
        ix=tr.gx/dx;
        memcpy( (void *) p[ix], (const void *) tr.data,nt*FSIZE);
d231 2
a232 2
        while(gettr(&tr)){
                        int igx;
d234 9
a242 9
                        if(tr.sx!=oldsx){ fseek(stdin,(long)(-240-nt*4),SEEK_CUR); break;}
                        igx=tr.gx/dx;
                        memcpy( (void *) p[igx], (const void *) tr.data,nt*FSIZE);

                        if(gxmin>tr.gx)gxmin=tr.gx;
                        if(gxmax<tr.gx)gxmax=tr.gx;
                        nx++;
                        oldsx=tr.sx;
                        }
d244 1
a244 1
        warn("sx %f , gxmin %f  gxmax %f",sx,gxmin,gxmax);
d246 2
a247 2
        /*transform the shot gather from time to frequency domain*/
        pfa2rc(1,1,ntfft,nxo,p[0],cq[0]);
d250 4
a253 4
        /*compute the most left and right index for the migrated section*/
        ix1=sx/dx;
        ix2=gxmin/dx;
        ix3=gxmax/dx;
d255 2
a256 2
        if(ix1>=ix3)ix3=ix1;
        if(ix1<=ix2)ix2=ix1;
d260 4
a263 4
        ix2-=lpad;
        ix3+=rpad;
        if(ix2<0)ix2=0;
        if(ix3>nxo-1)ix3=nxo-1;
d265 2
a266 2
        /*the total traces to be migrated*/
        nx=ix3-ix2+1;
d269 24
a292 28
       /* determine wavenumber sampling (for complex to complex FFT) */
        nxfft = npfa(nx);
        nk = nxfft;
        dk = 2.0*PI/(nxfft*dx);
        fk = -PI/dx;


        /*allocate space for velocity profile within the aperature*/
        v=alloc2float(nx,nz);   
        
        for(iz=0;iz<nz;iz++)
        for(ix=0;ix<nx;ix++){
        v[iz][ix]=vp[iz][ix+ix2];
        }

        vmax=v[0][0];vmin=v[0][0];
        
        for(iz=0;iz<nz;++iz)
        for(ix=0;ix<nx;ix++)
        {
         if(v[iz][ix]>=vmax) vmax=v[iz][ix];
         if(v[iz][ix]<=vmin) vmin=v[iz][ix];
        }


        /*allocate space*/
        cp = alloc2complex(nx,nw);
        cp1 = alloc2complex(nx,nw);
d294 3
a296 2
        /*transpose the frequency domain data from data[ix][iw] to data[iw][ix] and
        apply a Hamming at the same time*/
d298 2
a299 2
        for (ix=0; ix<nx; ix++)
        for (iw=0; iw<nw; iw++){
d301 4
a304 1
        float tmpp=0.0,tmppp=0.0;
d308 2
a309 2
        cp[iw][ix]=crmul(cq[ix+ix2][iw+nf1],tmpp);}
        else{
d312 2
a313 2
        cp[iw][ix]=crmul(cq[ix+ix2][iw+nf1],tmpp);}
        else{
d315 1
a315 1
        }
d319 1
a319 1
        ix=sx/dx-ifx;
d321 1
a321 1
        warn("ix %d",ix);
d323 9
a331 9
        for(iw=0;iw<nw;iw++){
        cp1[iw][ix-ix2]=wlsp[iw+nf1];
        }

                        
        free2float(p);
        free2complex(cq);
        free1float(wl);
        free1complex(wlsp);
d336 3
a338 3
        /*if the horizontal spacing interval is in feet, convert it to meter*/
        if(!flag)
        dx*=0.3048;
d344 12
a355 12
        /*the imaging condition*/
        for(ix=0;ix<nx;ix++){
        for(iw=0,w=fw;iw<nw;w+=dw,iw++){   
                complex tmp;
                float ratio=10.0;
                
                if(fabs(ix+ix2-ixshot)*dx<ratio*iz*dz)
                tmp=cmul(cp[iw][ix],cp1[iw][ix]);
                else tmp=cmplx(0.0,0.0);  
                cresult[ix+ix2][iz]+=tmp.r/ntfft;
        }
        }
d359 1
a359 1
        
d361 13
a373 13
        for(iw=0,w=fw;iw<nw;w+=dw,iw++){
                float kk=0.0;
                complex tmp;
                float ratio=1.5; 
                if(dip<80)ratio=1.5;
                else ratio=1.5;
        
                for(ix=0;ix<nx;ix++){     
                kk+=(pow(cp1[iw][ix].i,2.0)+pow(cp1[iw][ix].r,2.0))/nx;
                }
         
                for(ix=0;ix<nx;ix++){
                tmp=cmul(cp[iw][ix],cp1[iw][ix]);
d375 1
a375 1
                if(fabs(ix-ixshot)*dx<ratio*iz*dz||ixshot-ix<0 )
d377 1
a377 1
                tmp=crmul(tmp,1.0/(kk+1.0e-10));
d379 22
a400 22
                else tmp=cmplx(0.0,0.0);
                
                cresult[ix+ix2][iz]+=tmp.r/ntfft;
        
                }
                }
*/      

        for (ik=0; ik<nx; ++ik)
        for (iw=0,w=fw; iw<nw;w+=dw, ++iw){
        cp[iw][ik]=cmul(cp[iw][ik],cexp(cmplx(0.0,-w*dz/v[iz][ik])));
        cp1[iw][ik]=cmul(cp1[iw][ik],cexp(cmplx(0.0,-w*dz/v[iz][ik])));
        cq[iw][ik] = ik%2 ? cneg(cp[iw][ik]) : cp[iw][ik];
        cq1[iw][ik] = ik%2 ? cneg(cp1[iw][ik]) : cp1[iw][ik];
                }
        
                for (ik=nx; ik<nk; ++ik)
                        for (iw=0; iw<nw; ++iw)
                        {
                        cq[iw][ik] = cmplx(0.0,0.0);
                        cq1[iw][ik] = cmplx(0.0,0.0);
                        }
d402 1
a402 1
                
d404 13
a416 51
               	pfa2cc(-1,1,nk,nw,cq[0]);
                pfa2cc(-1,1,nk,nw,cq1[0]);
        
        /* The second time phase shift */
        v1=vmin;
        v2=vmax;
        
        if((v2-v1)/v1<0.01){
                
        for(ik=0,k=fk;ik<nk;++ik,k+=dk) 
                for(iw=0,w=fw;iw<nw;++iw,w+=dw){
                         
                if(w==0.0)w=1.0e-10/dt;

                kz1=1.0-pow(v1*k/w,2.0);
        
                if(kz1>=0.0){
                phase1 = -w*sqrt(kz1)*dz/v1+w*dz/v1;
                cshift1 = cmplx(cos(phase1), sin(phase1));
                cq[iw][ik] = cmul(cq[iw][ik],cshift1);
                cq1[iw][ik] = cmul(cq1[iw][ik],cshift1);
                }
                else{
                phase1 = -w*sqrt(-kz1)*dz/v1;
                cshift1=cexp(cmplx(phase1,w*dz/v1));
                cq[iw][ik] = cmul(cq[iw][ik],cshift1);
                cq1[iw][ik] = cmul(cq1[iw][ik],cshift1);
                }
        }                
        pfa2cc(1,1,nk,nw,cq[0]);
        pfa2cc(1,1,nk,nw,cq1[0]);
        
        for(ix=0;ix<nx;++ix)
                for(iw=0;iw<nw;++iw){
                cq[iw][ix] = crmul( cq[iw][ix], 1.0/nxfft);
                cp[iw][ix] =ix%2 ? cneg(cq[iw][ix]) : cq[iw][ix];
                cq1[iw][ix] = crmul( cq1[iw][ix], 1.0/nxfft);
                cp1[iw][ix] =ix%2 ? cneg(cq1[iw][ix]) : cq1[iw][ix];
                 
                }
        }
        else{
                
        for(ik=0;ik<=L;ik++)
        c[ik]=vmin+ik*1.0*(vmax-vmin)/(L*1.0);
                         
        for(ik=0;ik<L;ik++)
        {
        P[ik]=0.0;
        }
         
d418 37
d456 3
a458 2
                for(ix=0;ix<nx;ix++){
                for(ik=0;ik<L;ik++){
d460 1
a460 1
                	P[ik]+=1.0/nx; break;
a461 1
                }
d463 5
a467 4
        Sz=0.0;
        for(ik=0;ik<L;ik++)
        {if(P[ik]!=0.00) Sz=Sz-P[ik]*log(P[ik]);
        }
d469 2
a470 2
        Bz=exp(Sz)+0.5;
        Y[0]=0.0; Y[L]=1.0;
d472 14
a485 14
        for(ik=1;ik<L;ik++)
        {Y[ik]=0.0;
        for(ix=0;ix<ik;ix++)
        for(ix=0;ix<ik;ix++)
        Y[ik]=Y[ik]+P[ix];
        }
                 
        V=alloc1float(Bz+1);
        V[0]=vmin;

        
        for(ix=1;ix<=Bz;ix++){
        for(ik=0;ik<L;ik++){
		if((ix*1.0/Bz>Y[ik])&&(ix*1.0/Bz<=Y[ik+1])){        
d489 40
a528 40
        }
        
        }

         
                 
        V[Bz]=V[Bz]*1.005;  
        cq2=ealloc3complex(nk,nw,Bz+1);
        cq3=ealloc3complex(nk,nw,Bz+1);

        for(ix=0;ix<Bz+1;ix++){
                for(iw=0,w=fw;iw<nw;++iw,w+=dw)
                for(ik=0,k=fk;ik<nk;++ik,k+=dk){

                if(w==0.0)w=1.0e-10/dt;

                kz1=1.0-pow(V[ix]*k/w,2.0);
                if(kz1>=0.00){
                        phase1 =-w*sqrt(kz1)*dz/V[ix]+w*dz/V[ix];
                        cshift1 = cexp(cmplx(0.0,phase1));
                        cq2[ix][iw][ik] = cmul(cq[iw][ik],cshift1);
                        cq3[ix][iw][ik] = cmul(cq1[iw][ik],cshift1);
         
                        }
                else{
                phase1 =-w*sqrt(-kz1)*dz/V[ix];
                cshift1 =cexp(cmplx(phase1,w*dz/V[ix]));
                cq2[ix][iw][ik] = cmul(cq[iw][ik],cshift1);
                cq3[ix][iw][ik] = cmul(cq1[iw][ik],cshift1);
                
                }

        }

                
        pfa2cc(1,1,nk,nw,cq2[ix][0]);
        pfa2cc(1,1,nk,nw,cq3[ix][0]);
        
        for(ik=0;ik<nx;++ik)
                for(iw=0,w=fw;iw<nw;w+=dw,++iw){
d531 1
a531 1
                
d536 35
a570 35
                cq2[ix][iw][ik] = crmul( cq2[ix][iw][ik], g*1.0/nxfft);
                cq2[ix][iw][ik] =ik%2 ? cneg(cq2[ix][iw][ik]) : cq2[ix][iw][ik];
                cq3[ix][iw][ik] = crmul( cq3[ix][iw][ik], g*1.0/nxfft);
                cq3[ix][iw][ik] =ik%2 ? cneg(cq3[ix][iw][ik]) : cq3[ix][iw][ik];
         
        	}
	}               

        for(ix=0;ix<nx;++ix)
        for(ik=0;ik<Bz;++ik){
        
        if(((v[iz][ix]>=V[ik])&&(v[iz][ix]<V[ik+1]))) {


                v1=V[ik];v2=V[ik+1];
                
                for(iw=0,w=fw;iw<nw;w+=dw,++iw){

                a1=cq2[ik][iw][ix].r;a2=cq2[ik+1][iw][ix].r;
                theta1=cq2[ik][iw][ix].i ;theta2=cq2[ik+1][iw][ix].i;  
                
                a= a1*(v2-v[iz][ix])/(v2-v1)+a2*(v[iz][ix]-v1)/(v2-v1);
                theta=theta1*(v2-v[iz][ix])/(v2-v1)+theta2*(v[iz][ix]-v1)/(v2-v1);
                cp[iw][ix] =cmplx(a,theta);
         
                
                a1=cq3[ik][iw][ix].r;a2=cq3[ik+1][iw][ix].r;
                theta1=cq3[ik][iw][ix].i ;theta2=cq3[ik+1][iw][ix].i;
        
                a= a1*(v2-v[iz][ix])/(v2-v1)+a2*(v[iz][ix]-v1)/(v2-v1);
                theta=theta1*(v2-v[iz][ix])/(v2-v1)+theta2*(v[iz][ix]-v1)/(v2-v1);
                cp1[iw][ix] =cmplx(a,theta);
                
                
	        }
d573 2
a574 2
                
        }       
d577 4
a580 4
        free3complex(cq2);
        free3complex(cq3);
        free1float(V);
                
d582 2
a583 2
                
                                
d605 5
a609 5
                tr.ns = nz ;
                tr.dt = dz*1000000.0 ;
                tr.d2 = dx;
                tr.offset = 0; 
                tr.cdp = tr.tracl = ix;
d626 1
a626 1
        
d633 1
a633 1
         
d635 1
a635 1
        
@


1.2
log
@small changes
@
text
@d1 1
a1 1
/* SUMIGPREPSPI: $Vision: 1.00 $ ; $Date: 1998/05/04 18:08:16 $*/
d7 1
a7 1
#include <time.h>
d60 1
a60 1
static time_t t1,t2;
d141 1
a141 1
	time(&t1);
d588 1
d591 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 4
/* Copyright (c) Colorado School of Mines, 1998.*/
/* All rights reserved.                       */

/* SUMIGPREPSPI: $Vision: 1.00 $ ; $Date: 1998/04/19 22:00:00 $*/
a8 2
float * ricker(float Freq,float dt,int *Npoint);

d53 3
@
